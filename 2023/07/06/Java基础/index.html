<!DOCTYPE html><html lang="zh-CN" data-default-color-scheme="auto"><head><meta charset="UTF-8"><link rel="apple-touch-icon" sizes="76x76" href="/img/pag.png"><link rel="icon" href="/img/pag.png"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=5,shrink-to-fit=no"><meta http-equiv="x-ua-compatible" content="ie=edge"><meta http-equiv="Content-Security-Policy" content="upgrade-insecure-requests"><meta name="theme-color" content="#2f4154"><meta name="author" content="zzh"><meta name="keywords" content=""><meta name="description" content="Java基础 基于java8及以上，比较杂乱且不完善，自用笔记   JDK Java程序开发工具包，包含JRE和开发人员使用的工具  JRE Java程序的运行环境，包含JVM和运行时所需要的核心类库     内存分布 堆  new出来的结果（对象的实体、数组的实体等）。包括对象中的属性。jdk7以上，字符串常量池也放在了堆中。  虚拟机栈 方法内定义的变量，存储在栈中，先进后出。  方法区 存放"><meta property="og:type" content="article"><meta property="og:title" content="Java基础"><meta property="og:url" content="http://example.com/2023/07/06/Java%E5%9F%BA%E7%A1%80/index.html"><meta property="og:site_name" content="箱庭"><meta property="og:description" content="Java基础 基于java8及以上，比较杂乱且不完善，自用笔记   JDK Java程序开发工具包，包含JRE和开发人员使用的工具  JRE Java程序的运行环境，包含JVM和运行时所需要的核心类库     内存分布 堆  new出来的结果（对象的实体、数组的实体等）。包括对象中的属性。jdk7以上，字符串常量池也放在了堆中。  虚拟机栈 方法内定义的变量，存储在栈中，先进后出。  方法区 存放"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="http://example.com/img/java/java_home.jpg"><meta property="article:published_time" content="2023-07-06T06:25:14.000Z"><meta property="article:modified_time" content="2024-03-10T11:36:42.164Z"><meta property="article:author" content="zzh"><meta property="article:tag" content="java"><meta name="twitter:card" content="summary_large_image"><meta name="twitter:image" content="http://example.com/img/java/java_home.jpg"><meta name="referrer" content="no-referrer-when-downgrade"><title>Java基础 - 箱庭</title><link rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css"><link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css"><link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css"><link rel="stylesheet" href="/css/main.css"><link id="highlight-css" rel="stylesheet" href="/css/highlight.css"><link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css"><script id="fluid-configs">var Fluid=window.Fluid||{};Fluid.ctx=Object.assign({},Fluid.ctx);var CONFIG={hostname:"example.com",root:"/",version:"1.9.5",typing:{enable:!0,typeSpeed:75,cursorChar:"_",loop:!1,scope:["home"]},anchorjs:{enable:!0,element:"h1,h2,h3,h4,h5,h6",placement:"left",visible:"hover",icon:""},progressbar:{enable:!0,height_px:3,color:"#29d",options:{showSpinner:!1,trickleSpeed:100}},code_language:{enable:!0,default:"TEXT"},copy_btn:!0,image_caption:{enable:!0},image_zoom:{enable:!0,img_url_replace:["",""]},toc:{enable:!0,placement:"right",headingSelector:"h1,h2,h3,h4",collapseDepth:2},lazyload:{enable:!0,loading_img:"/img/loading.gif",onlypost:!1,offset_factor:2},web_analytics:{enable:!0,follow_dnt:!0,baidu:null,google:{measurement_id:null},tencent:{sid:null,cid:null},woyaola:null,cnzz:null,leancloud:{app_id:null,app_key:null,server_url:null,path:"window.location.pathname",ignore_local:!1}},search_path:"/local-search.xml",include_content_in_search:!0};if(CONFIG.web_analytics.follow_dnt){var dntVal=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack;Fluid.ctx.dnt=dntVal&&(dntVal.startsWith("1")||dntVal.startsWith("yes")||dntVal.startsWith("on"))}</script><script src="/js/utils.js"></script><script src="/js/color-schema.js"></script><script async>Fluid.ctx.dnt||Fluid.utils.createScript("https://www.googletagmanager.com/gtag/js?id=",(function(){function a(){dataLayer.push(arguments)}window.dataLayer=window.dataLayer||[],a("js",new Date),a("config","")}))</script><meta name="generator" content="Hexo 6.3.0"></head><body><header><div class="header-inner" style="height:70vh"><nav id="navbar" class="navbar fixed-top navbar-expand-lg navbar-dark scrolling-navbar"><div class="container"><a class="navbar-brand" href="/"><strong>子恒的小窝</strong> </a><button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation"><div class="animated-icon"><span></span><span></span><span></span></div></button><div class="collapse navbar-collapse" id="navbarSupportedContent"><ul class="navbar-nav ml-auto text-center"><li class="nav-item"><a class="nav-link" href="/"><i class="iconfont icon-home-fill"></i> <span>首页</span></a></li><li class="nav-item"><a class="nav-link" href="/archives/"><i class="iconfont icon-archive-fill"></i> <span>归档</span></a></li><li class="nav-item"><a class="nav-link" href="/categories/"><i class="iconfont icon-category-fill"></i> <span>分类</span></a></li><li class="nav-item"><a class="nav-link" href="/tags/"><i class="iconfont icon-tags-fill"></i> <span>标签</span></a></li><li class="nav-item"><a class="nav-link" href="/about/"><i class="iconfont icon-user-fill"></i> <span>关于</span></a></li><li class="nav-item" id="search-btn"><a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search"><i class="iconfont icon-search"></i></a></li><li class="nav-item" id="color-toggle-btn"><a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle"><i class="iconfont icon-dark" id="color-toggle-icon"></i></a></li></ul></div></div></nav><div id="banner" class="banner" parallax="true" style="background:url(/img/java/java_home.jpg) no-repeat center center;background-size:cover"><div class="full-bg-img"><div class="mask flex-center" style="background-color:rgba(0,0,0,.3)"><div class="banner-text text-center fade-in-up"><div class="h2"><span id="subtitle">Java基础</span></div><div class="mt-3"><span class="post-meta mr-2"><i class="iconfont icon-author" aria-hidden="true"></i> zzh </span><span class="post-meta"><i class="iconfont icon-date-fill" aria-hidden="true"></i> <time datetime="2023-07-06 14:25" pubdate>2023年7月6日 下午</time></span></div><div class="mt-1"><span class="post-meta mr-2"><i class="iconfont icon-chart"></i> 53k 字 </span><span class="post-meta mr-2"><i class="iconfont icon-clock-fill"></i> 439 分钟 </span><span id="busuanzi_container_page_pv" style="display:none"><i class="iconfont icon-eye" aria-hidden="true"></i> <span id="busuanzi_value_page_pv"></span> 次</span></div></div></div></div></div></div></header><main><div class="container-fluid nopadding-x"><div class="row nomargin-x"><div class="side-col d-none d-lg-block col-lg-2"></div><div class="col-lg-8 nopadding-x-md"><div class="container nopadding-x-md" id="board-ctn"><div id="board"><article class="post-content mx-auto"><h1 id="seo-header">Java基础</h1><p class="note note-info">本文最后更新于：2 个月前</p><div class="markdown-body"><h1 id="Java基础"><a href="#Java基础" class="headerlink" title="Java基础"></a>Java基础</h1><blockquote><p>基于java8及以上，比较杂乱且不完善，自用笔记</p></blockquote><ul><li><p><strong>JDK</strong></p><p>Java程序开发工具包，包含<code>JRE</code>和开发人员使用的<strong>工具</strong></p></li><li><p><strong>JRE</strong></p><p>Java程序的运行环境，包含<code>JVM</code>和运行时所需要的<strong>核心类库</strong></p></li></ul><br><h2 id="内存分布"><a href="#内存分布" class="headerlink" title="内存分布"></a>内存分布</h2><ul><li><p><strong>堆</strong></p><p><code>new</code>出来的结果（对象的实体、数组的实体等）。包括对象中的属性。jdk7以上，字符串常量池也放在了堆中。</p></li><li><p><strong>虚拟机栈</strong></p><p>方法内定义的变量，存储在栈中，先进后出。</p></li><li><p><strong>方法区</strong></p><p>存放类的模板。</p></li></ul><p><img src="/../img/java/01aadc96b225cab571989d6d630c7f1c.png" srcset="/img/loading.gif" lazyload></p><br><h2 id="static"><a href="#static" class="headerlink" title="static"></a><strong>static</strong></h2><ul><li>可以直接调用，不需要类名（对象名）。</li><li>static修饰的方法中只能调用static修饰的变量（包括方法），而普通方法中可以调用所有的变量和方法。（遵守修饰符规定）</li><li>static修饰的变量和方法，随着类的加载而加载，因此在对象<strong>未实例化时</strong>也可直接调用。</li><li>static修饰的代码块只会执行一次。</li></ul><br><h2 id="类加载、构造器、执行顺序"><a href="#类加载、构造器、执行顺序" class="headerlink" title="类加载、构造器、执行顺序"></a><strong>类加载、构造器、执行顺序</strong></h2><br><p><img src="/../img/java/2b6a7fae7706d956d62fc60bd0932ec2.png" srcset="/img/loading.gif" lazyload></p><p>静态加载：在编译时就加载相关的类，依赖性强</p><p>动态加载：运行时加载需要的类，不需要时不加载，降低依赖性</p><br><p><strong>类什么时候加载？</strong></p><ol><li>实例化对象时(new)，静态加载。</li><li>子类被加载时，父类也会加载，静态加载。</li><li>调用类的静态成员时，静态加载。</li><li>通过反射，动态加载。</li></ol><p>构造器的本质作用是为<strong>对象初始化，而不是创建对象</strong></p><br><p><strong>注意事项：</strong></p><ul><li>类的加载不代表对象的实例，只有对象的实例才会引起类的构造器。</li><li>类只会加载一次。</li><li>static和final一起使用的变量不会引起类的加载。</li></ul><br><p><strong>实例类的执行顺序：</strong></p><ul><li>同一个类的情况下：</li></ul><ol><li>静态代码块和静态属性（根据定义顺序）</li><li>普通代码块和普通属性（根据定义顺序）</li><li>构造器</li></ol><ul><li>继承的情况下：</li></ul><ol><li>父类的静态代码块和静态属性（根据定义顺序）</li><li>子类的静态代码块和静态属性（根据定义顺序）</li><li>父类的普通代码块和普通属性（根据定义顺序）</li><li>父类的构造器</li><li>子类的普通代码块和普通属性（根据定义顺序）</li><li>子类的构造器</li></ol><br><h2 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h2><blockquote><p>一种套路：是长期理论之后，总结出来一种解决方案、思考方式。</p></blockquote><p><strong>什么是单例模式？</strong></p><p>采取一定的方法，保证在整个系统中，对某个类<strong>只能存在一个对象实例</strong>，并且该类只提供一个取得其对象的方法。</p><br><p><strong>单例模式的实现方法：</strong></p><p>如果我们要让类在一个虚拟机中只能产生一个对象，我们首先必须将类的<strong>构造器的访问权限设置为</strong><code>private</code>，这样，就不能用<code>new</code>操作符在类的外部产生类的对象了，但在类内部仍可以产生该类的对象。因为在类的外部开始还无法得到类的对象，<strong>只能调用该类的某个静态方法</strong>以返回类内部创建的对象，静态方法只能访问类中的静态成员变量，所以，指向类内部产生的<strong>该类对象的变量也必须定义成静态的</strong>。</p><br><p><strong>饿汉式单例模式（在类加载时便创建对象）</strong></p><ol><li>构造器私有化</li><li>在类加载时创建对象</li><li>对外暴露调用对象的静态方法</li></ol><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Cat</span>&#123;
  <span class="hljs-keyword">private</span> String name;
  <span class="hljs-keyword">private</span> <span class="hljs-title function_">Cat</span><span class="hljs-params">(String name)</span>&#123;   <span class="hljs-comment">//构造器私有化</span>
    <span class="hljs-built_in">this</span>.name = name;
  &#125;
  <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Cat cat=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Cat</span>(<span class="hljs-string">&quot;小白&quot;</span>);   <span class="hljs-comment">//static下不创建对象直接调用</span>
  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Cat <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span>&#123;    <span class="hljs-comment">//static下不创建对象对外暴露对象接口</span>
    <span class="hljs-keyword">return</span> cat;
  &#125;
&#125;</code></pre></div><br><p>**懒汉式单例模式（类加载时不创建对象，需要时才创建对象） **</p><ol><li>构造器私有化</li><li>定义一个static的静态对象</li><li>在对外暴露调用对象的静态方法时再创建对象</li></ol><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Cat</span>&#123;
  <span class="hljs-keyword">private</span> String name;
  <span class="hljs-keyword">private</span> <span class="hljs-title function_">Cat</span><span class="hljs-params">(String name)</span>&#123;   <span class="hljs-comment">//构造器私有化</span>
    <span class="hljs-built_in">this</span>.name = name;
  &#125;
  <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Cat cat;   <span class="hljs-comment">//创建但不实例化</span>
  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Cat <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span>&#123;
    <span class="hljs-keyword">if</span>(cat == <span class="hljs-literal">null</span>)&#123;    <span class="hljs-comment">//判断是否实例化</span>
      cat = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Cat</span>(<span class="hljs-string">&quot;小白&quot;</span>);
    &#125;
    <span class="hljs-keyword">return</span> cat;
  &#125;
&#125;</code></pre></div><p><strong>对比</strong></p><table><thead><tr><th align="left">单例模式</th><th align="center">特点</th><th align="center">优点</th><th align="center">缺点</th></tr></thead><tbody><tr><td align="left">饿汉式</td><td align="center">立即加载</td><td align="center">使用快、线程安全</td><td align="center">生命周期长（占内存）</td></tr><tr><td align="left">懒汉式</td><td align="center">延迟加载</td><td align="center">节省内存空间</td><td align="center">线程不安全</td></tr></tbody></table><p>线程安全的懒汉模式在多线程展示</p><h2 id="final和abstract"><a href="#final和abstract" class="headerlink" title="final和abstract"></a>final和abstract</h2><p><strong>final</strong></p><blockquote><p>最终的</p></blockquote><p><code>final</code>修饰的类<strong>不能被继承</strong>，修饰的方法<strong>不能被重写</strong>，修饰的变量成为常量<strong>不能被修改</strong></p><p><strong>abstract抽象类、抽象方法</strong></p><blockquote><p>随着继承层次中一个个新子类的定义，类变得越来越具体，而父类则更一般，更通用。类的设计应该保证父类和子类能够共享特征。有时将一个父类设计得非常抽象，以至于它没有具体的实例，这样的类叫做抽象类。</p></blockquote><p>被<code>abstract</code>限定的抽象类，<strong>只有方法签名，没有方法体，无法实例化</strong>，而是应该交给子类各自具体实现。Java语法规定，包含抽象方法的类必须是抽象类。</p><p>抽象类<strong>是包含构造器的</strong>。因为子类对象实例化时，需要直接或间接地调用到父类的构造器。</p><p>抽象方法必须要在子类中实现，否则该子类也为抽象类。</p><h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><blockquote><p>接口的本质是契约、标准、规范，就像我们的法律一样。制定好后大家都要遵守。</p><p>继承是是不是的关系、接口是能不能的关系</p><p>接口是对继承的一种补充</p></blockquote><br><ul><li>接口中的属性默认修饰为public static final。</li><li>接口中的方法默认修饰为<code>public abstract</code></li><li>接口可以被接口继承，被类实现。</li><li>无法被实例化（没有构造器）。</li></ul><br><p><strong>接口匿名实现类</strong></p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">USB</span> &#123;
    <span class="hljs-keyword">void</span> <span class="hljs-title function_">start</span><span class="hljs-params">()</span>;
    <span class="hljs-keyword">void</span> <span class="hljs-title function_">end</span><span class="hljs-params">()</span>;
&#125;

<span class="hljs-keyword">class</span> <span class="hljs-title class_">computer</span>&#123;
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">transfer</span><span class="hljs-params">(USB usb)</span>&#123;
        usb.start();
        usb.end();
    &#125;
&#125;
<span class="hljs-comment">//接口匿名实现类</span>
computer.transfer(<span class="hljs-keyword">new</span> <span class="hljs-title class_">USB</span>() &#123;
    <span class="hljs-meta">@Override</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">start</span><span class="hljs-params">()</span> &#123;
        
    &#125;

    <span class="hljs-meta">@Override</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">end</span><span class="hljs-params">()</span> &#123;

    &#125;
&#125;);

<span class="hljs-comment">//实际工作中的开发场景：</span>
<span class="hljs-comment">//提供一个接口的实例</span>
<span class="hljs-keyword">public</span> Comparable <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span>&#123;
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Comparable</span>() &#123;
        <span class="hljs-meta">@Override</span>
        <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">compareTo</span><span class="hljs-params">(Object o)</span> &#123;
            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
        &#125;
    &#125;;
&#125;</code></pre></div><br><p><strong>—-&gt;接口冲突</strong></p><p>类实现了两个接口，而两个接口中定义了<strong>同名同参数的默认方法</strong>。则实现类在没有重写此两个接口默认方法的情况下，会报错。</p><p>要求: 此时实现类必须要重与接口中定义的同名同参数的方法。</p><p><strong>—-&gt;类优先原则</strong></p><p>子类(或实现类)继承了父类并实现了接口。父类和接口中声明了同名同参数的方法。 (其中，接口中的方法是默认方法)。</p><p>默认情况下，子类(或实现类)在没有重写此方法的情况下，调用的是父类中的方法。</p><br><p><code>jdk8</code>以上新特性：</p><p>现在允许存在默认方法<code>default</code>，可以被实现类使用、重写。</p><p>静态方法<code>static</code>修饰，只能被接口本身调用，无法被实现类调用</p><p>抽象类和接口的区别</p><table><thead><tr><th>区别点</th><th>抽象类</th><th>接口</th></tr></thead><tbody><tr><td>定义</td><td>可以包含抽象方法的类</td><td>主要是抽象方法和全局常量的集合</td></tr><tr><td>组成</td><td>构造方法、抽象方法、普通方法、常量、变量</td><td>抽象方法、常量、（默认方法、静态方法）（JDK8）</td></tr><tr><td>使用</td><td>子类继承抽象类<code>extends</code></td><td>子类实现接口<code>implements</code></td></tr><tr><td>关系</td><td>抽象类可以实现多个接口</td><td>接口不能继承抽象类、但允许继承多个接口</td></tr><tr><td>常见设计模式</td><td>模板方法</td><td>简单工厂、工厂方法、代理模式</td></tr><tr><td>对象</td><td>都通过对象的多态性产生实例化对象</td><td>都通过对象的多态性产生实例化对象</td></tr><tr><td>局限</td><td>抽象类有单继承的局限</td><td>接口没有此局限性</td></tr><tr><td>实际</td><td>作为一个模板</td><td>作为一个标准或是表示一种能力</td></tr><tr><td>选择</td><td></td><td>优先使用接口</td></tr></tbody></table><p>只要有基本数据类型和包装类进行比较，比较的是值是否相等，Integer的源码可知，-128~127之间的自动包装不会new一个新的对象。</p><br><h2 id="比较器-x2F-排序"><a href="#比较器-x2F-排序" class="headerlink" title="比较器&#x2F;排序"></a>比较器&#x2F;排序</h2><blockquote><p>基本数据类型可以直接使用比较运算符比较</p><p>引用数据类型使用自然排序、定制排序</p></blockquote><h3 id="自然排序-实现Comparable接口的方式"><a href="#自然排序-实现Comparable接口的方式" class="headerlink" title="自然排序-实现Comparable接口的方式"></a><strong>自然排序-实现Comparable接口的方式</strong></h3><blockquote><p>适合直接修改代码</p></blockquote><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/**</span>
<span class="hljs-comment"> * 自然排序 - 实现Compareable接口 -&gt; 重写compareTo方法</span>
<span class="hljs-comment">*/</span>

<span class="hljs-keyword">class</span> <span class="hljs-title class_">Phone</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Comparable</span> &#123;
    <span class="hljs-comment">/**</span>
<span class="hljs-comment">     * 按照价格-&gt;名称 从低到高排序*</span>
<span class="hljs-comment">     *</span>
<span class="hljs-comment">     * <span class="hljs-doctag">@param</span> o</span>
<span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 0：相同；  大于0：当前对象大；  小于0：当前对象小；</span>
<span class="hljs-comment">     */</span>
    <span class="hljs-meta">@Override</span>
    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">compareTo</span><span class="hljs-params">(Object o)</span> &#123;
        <span class="hljs-keyword">if</span> (o == <span class="hljs-built_in">this</span>) &#123;
            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
        &#125;
        <span class="hljs-keyword">if</span> (o <span class="hljs-keyword">instanceof</span> Phone phone) &#123;
            <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.price - phone.price == <span class="hljs-number">0</span> ? <span class="hljs-built_in">this</span>.name.compareTo(phone.name) : <span class="hljs-built_in">this</span>.price - phone.price;
        &#125;
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<span class="hljs-string">&quot;类型不匹配&quot;</span>);
    &#125;

    <span class="hljs-keyword">private</span> String name;
    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> price;

    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Phone</span><span class="hljs-params">(String name, <span class="hljs-type">int</span> price)</span> &#123;
        <span class="hljs-built_in">this</span>.name = name;
        <span class="hljs-built_in">this</span>.price = price;
    &#125;
&#125;</code></pre></div><br><h3 id="定制排序-实现Comparator类的方式"><a href="#定制排序-实现Comparator类的方式" class="headerlink" title="定制排序-实现Comparator类的方式"></a>定制排序-实现Comparator类的方式</h3><blockquote><p>适合没有实现comparable接口并且，无法修改源代码的时候使用</p><p>适合实现了comparable接口，但是并不想按照预定的比较方式去比较的情况</p></blockquote><p>Comparator类实现了Comparable接口。多数场景中使用 <em>匿名实现类</em> 的方式来创建，用完即。</p><div class="code-wrapper"><pre><code class="hljs java">Phone[] arr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Phone</span>[<span class="hljs-number">3</span>];
arr[<span class="hljs-number">0</span>] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Phone</span>(<span class="hljs-string">&quot;小米14&quot;</span>, <span class="hljs-number">5999</span>);
arr[<span class="hljs-number">1</span>] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Phone</span>(<span class="hljs-string">&quot;苹果15&quot;</span>, <span class="hljs-number">6999</span>);
arr[<span class="hljs-number">2</span>] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Phone</span>(<span class="hljs-string">&quot;华为mate60&quot;</span>, <span class="hljs-number">6499</span>);
Arrays.sort(arr, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Comparator</span>&lt;Phone&gt;() &#123;
    <span class="hljs-meta">@Override</span>
    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">compare</span><span class="hljs-params">(Phone o1, Phone o2)</span> &#123;
        <span class="hljs-keyword">return</span> o1.getPrice() - o2.getPrice();
    &#125;
&#125;);</code></pre></div><h2 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h2><blockquote><p>防止因为外部因素程序出错导致的程序终止。</p></blockquote><p>运行时异常：程序运行时发生的异常。RutimeException</p><p>编译时异常：程序编译时发生的异常。如果不处理则编译器无法生成字节码文件</p><p><strong>异常体系结构：</strong></p><p><img src="/../img/java/1596f5280a4724552da3f5de92c0c5bd.png" srcset="/img/loading.gif" lazyload></p><p><strong>异常处理机制：</strong></p><p>主动抛异常：<code>throw new 异常类</code>;</p><p>交给调用者处理异常：<code>throws</code></p><p><strong><code>throws</code>和<code>throw</code>的区别</strong></p><p><code>throws</code>是用来处理异常，<code>throw</code>是用来新增异常的</p><p>经典面试题目：</p><div class="code-wrapper"><pre><code class="hljs java">main()&#123;
  <span class="hljs-type">int</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> test(<span class="hljs-number">10</span>);
  sout(result);
&#125;

function <span class="hljs-title function_">test</span><span class="hljs-params">(<span class="hljs-type">int</span> num)</span>&#123;
  <span class="hljs-keyword">try</span> &#123;
    <span class="hljs-keyword">return</span> num;
  &#125; <span class="hljs-keyword">catch</span> (Exception e)&#123;
    <span class="hljs-keyword">return</span> num--;
  &#125; <span class="hljs-keyword">finally</span> &#123;
    ++num;<span class="hljs-comment">//在num改变之前，原先num = 10的值已经存入栈帧，尽管后续num被改变，依旧return10</span>
  &#125;
&#125;

<span class="hljs-comment">//考点：</span>
<span class="hljs-comment">//return的数会临时放在操作数栈里面。</span>
<span class="hljs-comment">//虽然数据已经入栈，但因为finally的原因，并不会立马执行return，但此时栈中数据已经存在</span>
<span class="hljs-comment">//后续改动不会影响已经入栈的值</span></code></pre></div><br><h2 id="String体系"><a href="#String体系" class="headerlink" title="String体系"></a>String体系</h2><br><h3 id="String"><a href="#String" class="headerlink" title="String"></a><strong>String</strong></h3><blockquote><p>jdk8.0之前底层使用char[]，jdk9.0之后使用byte[]</p></blockquote><p>String保存的是字符串常量，里面的值不能更改，每次更新String类，并不是在原先的值上做改动，而是在池中<strong>新增</strong>或者<strong>匹配</strong>已经存在改动后的值，由value指向它。<strong>实际上String类的更新，是更新它所指向的地址。</strong></p><p><strong>常量相加，看的是池，变量相加，看的是堆。</strong></p><p>涉及到变量加减，底层源码实际上使用了<code>StringBuilder</code>来进行拼接，最后调用了<code>StringBuilder</code>的<code>toString()</code>方法，而该方法会<code>new String()</code>，新建了一个对象。</p><p>如果该变量加了<code>final</code>修饰，则该<strong>变量变成了常量</strong>。</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;abc&quot;</span>;
<span class="hljs-type">String</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;123&quot;</span>;
<span class="hljs-type">String</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> a + b;
<span class="hljs-comment">//源码分析：在c这一步中：</span>
StringBuilder sb=<span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();
sb.apend(a);
sb.apend(b);
<span class="hljs-type">String</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> sb.toString();<span class="hljs-comment">//toString()方法会在池中创建一个新的对象</span>
<span class="hljs-comment">//在堆中新建了一个value[]对象，由c指向它。</span>
<span class="hljs-comment">//在池中新建了一个对象，用于存放拼接好的字符串，由value[]对象指向它。</span></code></pre></div><p><img src="/../img/java/719d7e0c5ac64eb1cd5833aa4322d5ce.png" srcset="/img/loading.gif" lazyload></p><br><h3 id="StringBuffer与StringBuilder"><a href="#StringBuffer与StringBuilder" class="headerlink" title="StringBuffer与StringBuilder"></a><strong>StringBuffer与StringBuilder</strong></h3><blockquote><p>jdk8.0之前底层使用char[]，jdk9.0之后使用byte[]</p><p>都继承于AbstractStringBuilder</p></blockquote><br><p>**StringBuffer:**线程安全</p><p>**StringBuilder:**线程不安全</p><br><p>以<code>StringBuilder</code>为例：</p><p><strong>内部属性：</strong></p><p><code>char[] value</code> -&gt; 储存字符序列，能存储多大的空间。</p><p><code>int count</code> -&gt; 实际存储字符的个数，类似<code>Sting</code>中的<code>length()</code>。</p><p><strong>构造器：</strong></p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">//空参，默认创造16大小的数组，</span>
<span class="hljs-keyword">public</span> <span class="hljs-title function_">StringBuilder</span><span class="hljs-params">()</span> &#123;
    <span class="hljs-built_in">super</span>(<span class="hljs-number">16</span>); <span class="hljs-comment">// value = new byte[16]</span>
&#125;

<span class="hljs-comment">//带参数，初始化数组的大小</span>
<span class="hljs-keyword">public</span> <span class="hljs-title function_">StringBuilder</span><span class="hljs-params">(<span class="hljs-type">int</span> capacity)</span> &#123;
    <span class="hljs-built_in">super</span>(capacity);<span class="hljs-comment">// value = new byte[capacity]</span>
&#125;
<span class="hljs-keyword">public</span> <span class="hljs-title function_">StringBuilder</span><span class="hljs-params">(String str)</span> &#123;
    <span class="hljs-built_in">super</span>(str);<span class="hljs-comment">// value = new byte[str.length() + 16]</span>
&#125;</code></pre></div><p><strong>如何体现可变性？</strong></p><p><code>char[] value</code>没有<code>final</code>修饰，因此在创建<code>StringBuilder</code>对象后，只需要<strong>改变<code>value</code>指向新的数组</strong>即可（<code>value = new char[capacity]</code>），不需要像<code>String</code>那样新建一个对象。</p><p>一旦<code>count</code>即将超过<code>value.length()</code>时，扩容。</p><p><code>ensureCapacityInternal()</code>方法中判断以及扩容</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">ensureCapacityInternal</span><span class="hljs-params">(<span class="hljs-type">int</span> minimumCapacity)</span> &#123;
    <span class="hljs-comment">// overflow-conscious code</span>
    <span class="hljs-type">int</span> <span class="hljs-variable">oldCapacity</span> <span class="hljs-operator">=</span> value.length &gt;&gt; coder;
    <span class="hljs-keyword">if</span> (minimumCapacity - oldCapacity &gt; <span class="hljs-number">0</span>) &#123;
        value = Arrays.copyOf(value,
                newCapacity(minimumCapacity) &lt;&lt; coder);
    &#125;
&#125;</code></pre></div><p><strong>一些常用方法：</strong></p><p>-&gt;增：<code>append(&#39;xxx&#39;);</code></p><p>-&gt;删：<code>delete(int start , int ned);</code></p><p>​ <code>deleteCharAt(int index);</code></p><p>-&gt;改：<code>replace(int start , int end);</code></p><p>​ <code>setChartAt(int index , char c);</code></p><p>-&gt;查：<code>charAt(int index);</code></p><p>-&gt;插：<code>insert(int index ,xx);</code></p><p>-&gt;长度：<code>length();</code></p><p>-&gt;反转：<code>reverse();</code></p><br><p><code>StringBuilder</code>默认为16字符串数组的容器，与<code>String</code>不同的是，他指向的地址可以保持不变，改变其中的值，而不改变地址。在超出容量之后，才会改变地址指向新增的扩容后的地址，他们都在堆中。</p><br><p><code>String</code>与<code>StringBuilder</code>相互转换中，<code>append</code>方法与<code>StringBuilder</code>构造器方法的区别：</p><ul><li>apped方法添加空指针的字符串会<strong>手动拼接长度为4的null的字符数组</strong>。</li><li>利用构造器会<strong>判断传入字符串的长度</strong>，调用.length方法，会报空指针异常。</li></ul><table><thead><tr><th align="center"></th><th align="center">效率</th><th align="center">线程安全</th><th align="center">区别</th></tr></thead><tbody><tr><td align="center"><strong>String</strong></td><td align="center">低</td><td align="center">-</td><td align="center">改变的是地址而非值，复用性最高</td></tr><tr><td align="center"><strong>StringBuffer</strong></td><td align="center">中</td><td align="center">多线程安全</td><td align="center">改变值，在不超出容量的前提下不改变地址</td></tr><tr><td align="center"><strong>StringBuilder</strong></td><td align="center">高</td><td align="center">多线程不安全，适合单线程</td><td align="center">改变值，在不超出容量的前提下不改变地址</td></tr></tbody></table><br><h2 id="集合体系"><a href="#集合体系" class="headerlink" title="集合体系"></a>集合体系</h2><blockquote><p>看到list想到动态数组，并且需要用<code>equals</code>来进行比较</p><p>看到set想到去重，并且需要<code>hashCode</code>和<code>equals</code>进行比较</p></blockquote><p><strong>java.util.Collection</strong>：存储一个个的数据</p><ul><li>子接口1：<code>List</code>存储有序、可重复的数据（动态数组）<ul><li>实现类：<code>ArrayList</code>、<code>LinkedList</code>、<code>Vector</code></li></ul></li><li>子接口2：<code>Set</code>存储无序、不可重复的数据<ul><li>实现类：<code>HashSet</code>、<code>LinkedHashSet</code>、<code>TreeSet</code></li></ul></li></ul><p><strong>java.util.Map</strong>：存储键值对</p><ul><li>实现类：<code>HashMap</code>、<code>LinkedHashMap</code>、<code>TreeMap</code>、<code>Hashtable</code>、<code>Properties</code></li></ul><br><p><strong>只能存放引用数据类型，基本数据类型会自动装箱</strong></p><br><h3 id="List接口"><a href="#List接口" class="headerlink" title="List接口"></a>List接口</h3><blockquote><p>底层为数组，会动态扩容。因为list有序，进而就有索引（从0开始）。因此在原collection包下拥有的15个方法外额外新增了属于list接口的方法</p></blockquote><p><strong>常用方法：</strong></p><ul><li>增：</li></ul><p><code>add(Object obj)</code>：此时默认在末尾添加。</p><p><code>add(Integer index, Object obj)</code>：在指定索引<code>index</code>位置处增加<code>obj</code>。</p><p><code>addAll(Collection coll)</code>：添加集合，将整个集合中的元素逐个添加</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">//注意：add和addAll的区别：</span>
<span class="hljs-type">ArrayList</span> <span class="hljs-variable">list</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>();
list.add(<span class="hljs-string">&quot;a&quot;</span>);

<span class="hljs-type">ArrayList</span> <span class="hljs-variable">list2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>();
list2.add(<span class="hljs-number">1</span>);
list2.add(<span class="hljs-number">2</span>);
list2.add(<span class="hljs-number">3</span>);

lsit.add(list2)<span class="hljs-comment">//list:[&quot;a&quot;,[1,2,3]] size = 2</span>
list.addAll(list2)<span class="hljs-comment">//list:[&quot;a&quot;,1,2,3] size = 4</span></code></pre></div><ul><li>删：</li></ul><p><code>remove(Object obj)</code>：删除具体的对象，底层调用<code>contains</code>判断是否存在</p><p><code>remove(int index)</code>：删除指定索引的数，并返回此元素</p><p><code>clear()</code>：清空集合。将集合中指向依次指向null，再将size设置为0。</p><p><code>removeAll(Collection coll)</code>：从当前集合中删除所有与coll集合中相同的元素，即移除共同有的，为叉积</p><p><code>retainAll(Collection coll)</code>：从当前集合中删除两个集合中不同的元素，即交集</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">//删除索引为2的元素</span>
remove(<span class="hljs-number">2</span>);
<span class="hljs-comment">//删除数据为2的元素</span>
remove(Integer.valueOf(<span class="hljs-number">2</span>));</code></pre></div><ul><li>改：</li></ul><p><code>set(int index,Object obj)</code>：根据索引来更改</p><ul><li>查：</li></ul><p><code>get(int index)</code>：根据索引来查</p><p><code>contains()</code>：是否包含该元素，注意此处比较的是<code>equals</code>，而非<code>hashcode</code>，根据add的顺序逐个进行<code>equals</code>比较</p><p><code>indexOf(Object obj)</code>：返回<code>obj</code>在集合中首次出现的位置</p><p><code>subList(int fromIndex, int toIndex)</code>：返回从<code>fromIndex</code>到<code>toIndex</code>位置的子集合（左闭右开）</p><ul><li>长度：</li></ul><p><code>size()</code></p><ul><li>遍历：</li></ul><p><code>iterator()</code>：迭代器</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">//迭代器说明</span>
<span class="hljs-type">List</span> <span class="hljs-variable">list</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>();
list.add(<span class="hljs-string">&quot;1&quot;</span>);
list.add(<span class="hljs-string">&quot;2&quot;</span>);
list.add(<span class="hljs-string">&quot;3&quot;</span>);
<span class="hljs-type">Iterator</span> <span class="hljs-variable">iterator</span> <span class="hljs-operator">=</span> list.iterator();
<span class="hljs-keyword">while</span>(iterator.hasNext())&#123;<span class="hljs-comment">//iterator.hasNext()判断下一个数是否存在，是返回true，否则false</span>
  iterator.next();<span class="hljs-comment">//返回当前指针所指向的数，并将指针指向下一个数。</span>
&#125;</code></pre></div><ul><li>比较：</li></ul><p><code>contains(Object obj)</code>：是否包含该数值内容。按照list的添加顺序依次比较，是<code>equals</code>比较，而非比较地址。</p><ul><li>与数组的互相转换：</li></ul><p>数组转集合：<code>Arrays.asList(Object... obj)</code></p><p>集合转数组：<code>toArray()</code></p><p>经典面试题：</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-type">int</span>[] arr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>&#125; <span class="hljs-comment">//基本数据类型</span>
<span class="hljs-type">List</span> <span class="hljs-variable">list</span> <span class="hljs-operator">=</span> Arrays.asList(arr)
list.size()<span class="hljs-comment">//1</span>
sout.list<span class="hljs-comment">//打印出来是对象的地址</span>

Integer[] arr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Integer</span>[]&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>&#125; <span class="hljs-comment">//引用数据类型</span>
<span class="hljs-type">List</span> <span class="hljs-variable">list</span> <span class="hljs-operator">=</span> Arrays.asList(arr)
list.size()<span class="hljs-comment">//3</span>
sout.list<span class="hljs-comment">//[1,2,3]</span></code></pre></div><br><p><strong>ArrayList、LinkedList、Vector的区别</strong></p><p>-&gt;<code>ArrayList</code>：list接口的主要实现类，效率高，线程不安全，底层使用<code>Object[]</code>数组存储。在添加数据、查找数据时效率高，在插入、删除数据时，效率较低。</p><p>-&gt;<code>LinkedList</code>：底层使用双向链表的方式存储，在插入、删除数据是效率高，在添加、查找时效率较低，适合需要对数据频繁改动时使用。</p><p>-&gt;<code>Vector</code>：线程安全的，效率低，底层使用<code>Object[]</code>数组存储，不建议使用</p><br><h3 id="Set接口"><a href="#Set接口" class="headerlink" title="Set接口"></a>Set接口</h3><blockquote><p>大多数使用场景为去重…</p></blockquote><p>方法与<code>list</code>接口中的方法相同。</p><br><p>特点：</p><ul><li><strong>什么是无序性？</strong></li></ul><p>不等于随机性，与元素添加进来的位置有关，该元素所在的位置并非依次紧密排列的，而是根据元素的哈希值来确定位置。此为无序性。</p><ul><li><strong>什么是不可重复性？</strong></li></ul><p>添加到<code>set</code>中的元素是不可以相同的。</p><p><img src="/../img/java/fc5d88bc104e9822e57e6334f41f439b.png" srcset="/img/loading.gif" lazyload></p><p><em>图注：</em></p><p><em>此处table就是set存储中hash表。</em></p><p><em>Hash为通过<code>hashCode()</code>得到的hash值</em></p><br><h4 id="HashSet"><a href="#HashSet" class="headerlink" title="HashSet"></a>HashSet</h4><blockquote><p>底层使用的是HashMap，key为该数据，value指向统一的对象(new Object)。即数组+单向链表+红黑树的结构进行存储</p></blockquote><p>本质是一个数组链表（相邻表）。<strong>不可添加相同的数据</strong>，并且数据在表中排序与数据添加<strong>先后顺序无关</strong>，与该数据的Hash值有关，且输出顺序固定。</p><br><p><strong>添加过程是什么？以及添加新元素时，如何验证该元素是否存在的？</strong></p><ul><li>将(key1,value1)添加到map中。</li></ul><ol><li>首先需要调用<code>key1</code>所在类的<code>hashCode()</code>得到<code>key1</code>的hash值<code>hash1</code>。</li><li>再将得到的<code>hash1</code>经过<code>hash()</code>算法得到<code>hash2</code>。</li><li>再将得到的<code>hash2</code>经过<code>indexFor()</code>算法，就可以得到(key1,value1)在数组table中索引<code>i</code>的位置。</li><li>判断此时数组索引<code>i</code>位置上是否有元素？<ol><li>如果此索引<code>i</code>上没有元素，则（key1，value1）添加成功。</li><li>如果此索引<code>i</code>上有元素（key2，value2）。 ——-&gt;<strong>哈希冲突</strong><ol><li>如果<code>key1</code>的<code>hash2</code>与<code>key2</code>的<code>hash2</code>值不相同，则（key1，value1）添加成功。与旧元素形成单向链表表（头插法，新元素放在首位，其余元素后移）</li><li>如果<code>key1</code>的<code>hash2</code>与<code>key2</code>的<code>hash2</code>值相同，则继续比较<code>equals()</code>。<ol><li>调用<code>key1</code>所在类的<code>equals()</code>方法，将<code>key2</code>作为参数传入，如果结果返回为false，则（key1，value1）添加成功。同上。</li><li>否则，<code>key1</code>与<code>key2</code>为相同，默认情况下，<code>value2</code>替换为<code>value1</code>。</li></ol></li></ol></li></ol></li></ol><p><img src="/../img/java/fc5d88bc104e9822e57e6334f41f439b.png" srcset="/img/loading.gif" lazyload></p><ol><li>如上图Dog添加到表中，优先将Dog对象的值根据hashCode算法算出Hash值。</li><li>再根据Hash值匹配table序列，如果匹配到的序列中没有存放值，则直接添加到首位，否则继续一次匹配该序列中该对象和链表中的每一个值（此处调用equals）是否相同。</li></ol><br><br><p><strong>注意事项：</strong></p><ol><li>新增值时，可以手动重写该对象的HashCode方法和Equals方法，人为控制哪些元素是否是相同的</li><li>HashSet的table表默认长度为16，但并不会等填满16个元素 之后才扩容，而是在总长度*0.75个长度单位时就会以2倍总长度扩容，并在下次达到临界值（x0.75）时继续扩容，例如：16（12）-&gt;32（24）-&gt;64（48）-&gt;…</li><li>如果一条链表的元素个数超过8，并且table的总长度&gt;&#x3D;64，才会进行树化（红黑树）</li><li>对于添加<code>null</code>时，由于<code>HashMap</code>允许key为<code>null</code>，因此HashSet也允许元素为<code>null</code>。</li><li>对于添加多个<code>null</code>时，因为<code>null</code>不是一个对象，因此它没有对应的<code>hashCode()</code>或<code>equals()</code>方法，无法按照上述检测重复。当添加一个<code>null</code>元素时，HashMap会将这个<code>null</code>键映射到一个特定的桶（<code>bucket</code>）。当后续你试图再添加<code>null</code>时，HashMap会根据它的实现，检测到这个<code>null</code>键已经映射到了特定的桶，因此不接受重复的键，也就是不接受重复的<code>null</code>。</li></ol><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">//面试题</span>

<span class="hljs-comment">//Phone 类</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">Phone</span>&#123;
    <span class="hljs-keyword">private</span> String name;
    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> price;

    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Phone</span><span class="hljs-params">(String name, <span class="hljs-type">int</span> price)</span> &#123;
        <span class="hljs-built_in">this</span>.name = name;
        <span class="hljs-built_in">this</span>.price = price;
    &#125;

    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getName</span><span class="hljs-params">()</span> &#123;
        <span class="hljs-keyword">return</span> name;
    &#125;

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setName</span><span class="hljs-params">(String name)</span> &#123;
        <span class="hljs-built_in">this</span>.name = name;
    &#125;

    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getPrice</span><span class="hljs-params">()</span> &#123;
        <span class="hljs-keyword">return</span> price;
    &#125;

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setPrice</span><span class="hljs-params">(<span class="hljs-type">int</span> price)</span> &#123;
        <span class="hljs-built_in">this</span>.price = price;
    &#125;

    <span class="hljs-meta">@Override</span>
    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span> &#123;
        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Phone&#123;&quot;</span> +
                <span class="hljs-string">&quot;name=&#x27;&quot;</span> + name + <span class="hljs-string">&#x27;\&#x27;&#x27;</span> +
                <span class="hljs-string">&quot;, price=&quot;</span> + price +
                <span class="hljs-string">&#x27;&#125;&#x27;</span>;
    &#125;
    <span class="hljs-meta">@Override</span>
    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">equals</span><span class="hljs-params">(Object o)</span> &#123;
        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span> == o) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
        <span class="hljs-keyword">if</span> (o == <span class="hljs-literal">null</span> || getClass() != o.getClass()) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
        <span class="hljs-type">Phone</span> <span class="hljs-variable">phone</span> <span class="hljs-operator">=</span> (Phone) o;
        <span class="hljs-keyword">return</span> price == phone.price &amp;&amp; Objects.equals(name, phone.name);
    &#125;

    <span class="hljs-meta">@Override</span>
    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">hashCode</span><span class="hljs-params">()</span> &#123;
        <span class="hljs-keyword">return</span> Objects.hash(name, price);
    &#125;
&#125;

HashSet&lt;Phone&gt; set = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;();
<span class="hljs-type">Phone</span> <span class="hljs-variable">p1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Phone</span>(<span class="hljs-string">&quot;小米14&quot;</span>, <span class="hljs-number">5999</span>);
<span class="hljs-type">Phone</span> <span class="hljs-variable">p2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Phone</span>(<span class="hljs-string">&quot;苹果15&quot;</span>, <span class="hljs-number">6999</span>);
set.add(p1);
set.add(p2);

p1.setPrice(<span class="hljs-number">6499</span>);
set.remove(p1);<span class="hljs-comment">//remove操作之前，会先调用contains()判断是否存在。set中存放的p1是没有更改属性时计算得到的hash值</span>
              <span class="hljs-comment">//而后续p1更改了属性值，此时计算p1时得到的hash值与set中存放p1的hash值不一致</span>
              <span class="hljs-comment">//因此没有找到更改值后的p1，即没有成功删除。</span>
              
set.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Phone</span>(<span class="hljs-string">&quot;小米14&quot;</span>, <span class="hljs-number">6499</span>));<span class="hljs-comment">//此处成功添加进去。add同样也会先调用contains()判断是否存在</span>
                                  <span class="hljs-comment">//此处添加的hash值与p1的hash值不一样！尽管p1的属性后续被更改，但是hash值在</span>
                                  <span class="hljs-comment">//p1第一次添加时已经确定。即可以添加进去</span>
        
set.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Phone</span>(<span class="hljs-string">&quot;小米14&quot;</span>, <span class="hljs-number">5999</span>));<span class="hljs-comment">//此处成功添加。add同样也会先调用contains()判断是否存在</span>
                                  <span class="hljs-comment">//此处添加的hash值与p1的hash值一样！但是equals()比较得到的值不一样！</span>
                                  <span class="hljs-comment">//因为p1的属性(价格)已经被改动。即可以添加进去</span></code></pre></div><br><h4 id="LinkedHashSet"><a href="#LinkedHashSet" class="headerlink" title="LinkedHashSet"></a>LinkedHashSet</h4><blockquote><p>是HashSet的子类，即在现有的数组+单向链表+红黑树结构的基础上，又添加了一组双向链表，用于记录添加元素的先后顺序。可以按照添加元素的先后顺序进行遍历，便于频繁的查询操作</p></blockquote><p>与HashSet添加方式相同，区别在于多了一组双向链表，用来记录加入的顺序。因此遍历时可以按照添加顺序依次遍历。</p><table><thead><tr><th></th><th>HashSet</th><th>LinkedHashSet</th></tr></thead><tbody><tr><td>特点</td><td>根据hash值进行遍历</td><td>根据添加顺序进行遍历（依旧体现无序性）</td></tr></tbody></table><br><h4 id="TreeSet"><a href="#TreeSet" class="headerlink" title="TreeSet"></a>TreeSet</h4><blockquote><p>底层使用红黑树存储。必须实现了comparable接口或者给予比较器。可以按照添加元素指定的顺序进行遍历</p></blockquote><p>特点：</p><ol><li>可以按照添加元素的<strong>指定属性大小</strong>进行顺序遍历。</li><li><strong>添加的元素必须是同一类元素</strong>。在添加一个新的元素后，会拿新添加的元素和之前的存放的值进行比较，<strong>添加的谁，就拿谁的比较器去和前面的比较</strong>。</li><li>不能存在相同的元素，是否相同<strong>取决于比较器的比较方法</strong>，只会保留第一次遇到的元素，后面遇到的相同的元素都不会存入。</li><li><code>contain()</code>与<code>remove()</code>方法同样取决于比较<strong>两个元素的比较器</strong>返回值是否为0。</li></ol><br><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/**</span>
<span class="hljs-comment"> * 使用自然排序</span>
<span class="hljs-comment"> **/</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">Phone</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Comparable</span> &#123;
    <span class="hljs-comment">/**</span>
<span class="hljs-comment">     * 按照价格-&gt;名称 从低到高排序*</span>
<span class="hljs-comment">     *</span>
<span class="hljs-comment">     * <span class="hljs-doctag">@param</span> o</span>
<span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 0：相同l  大于0：当前对象大  小于0：当前对象小</span>
<span class="hljs-comment">     */</span>
    <span class="hljs-meta">@Override</span>
    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">compareTo</span><span class="hljs-params">(Object o)</span> &#123;
        <span class="hljs-keyword">if</span> (o == <span class="hljs-built_in">this</span>) &#123;
            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
        &#125;
        <span class="hljs-keyword">if</span> (o <span class="hljs-keyword">instanceof</span> Phone phone) &#123;
            <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.price - phone.price == <span class="hljs-number">0</span> ? <span class="hljs-built_in">this</span>.name.compareTo(phone.name) : <span class="hljs-built_in">this</span>.price - phone.price;
        &#125;
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<span class="hljs-string">&quot;类型不匹配&quot;</span>);
    &#125;

    <span class="hljs-keyword">private</span> String name;
    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> price;

    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Phone</span><span class="hljs-params">(String name, <span class="hljs-type">int</span> price)</span> &#123;
        <span class="hljs-built_in">this</span>.name = name;
        <span class="hljs-built_in">this</span>.price = price;
    &#125;
&#125;

<span class="hljs-type">TreeSet</span> <span class="hljs-variable">treeSet</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeSet</span>();
treeSet.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Phone</span>(<span class="hljs-string">&quot;小米14&quot;</span>, <span class="hljs-number">5999</span>));
treeSet.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Phone</span>(<span class="hljs-string">&quot;苹果15&quot;</span>, <span class="hljs-number">6999</span>));
treeSet.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Phone</span>(<span class="hljs-string">&quot;华为mate60&quot;</span>, <span class="hljs-number">6499</span>));


<span class="hljs-comment">/**</span>
<span class="hljs-comment"> * 使用定制排序 </span>
<span class="hljs-comment"> **/</span>
<span class="hljs-type">TreeSet</span> <span class="hljs-variable">treeSet</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeSet</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Comparator</span>() &#123;
    <span class="hljs-meta">@Override</span>
    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">compare</span><span class="hljs-params">(Object o1, Object o2)</span> &#123;
        <span class="hljs-keyword">if</span> (o1 <span class="hljs-keyword">instanceof</span> Phone &amp;&amp; o2 <span class="hljs-keyword">instanceof</span> Phone) &#123;
            <span class="hljs-type">Phone</span> <span class="hljs-variable">p1</span> <span class="hljs-operator">=</span> (Phone) o1;
            <span class="hljs-type">Phone</span> <span class="hljs-variable">p2</span> <span class="hljs-operator">=</span> (Phone) o2;
            <span class="hljs-keyword">return</span> p1.getPrice() - p2.getPrice() == <span class="hljs-number">0</span> ?
              p1.getName().compareTo(p2.getName()) : p1.getPrice() - p2.getPrice();
        &#125;
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<span class="hljs-string">&quot;类型不匹配&quot;</span>);
    &#125;
&#125;);
treeSet.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Phone</span>(<span class="hljs-string">&quot;小米14&quot;</span>, <span class="hljs-number">5999</span>));
treeSet.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Phone</span>(<span class="hljs-string">&quot;苹果15&quot;</span>, <span class="hljs-number">6999</span>));
treeSet.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Phone</span>(<span class="hljs-string">&quot;华为mate60&quot;</span>, <span class="hljs-number">6499</span>));</code></pre></div><br><h3 id="Map接口"><a href="#Map接口" class="headerlink" title="Map接口"></a>Map接口</h3><blockquote><p>由key - value 构成的键值对存储格式</p></blockquote><p>以HashMap为例</p><p><code>key</code>：不可以重复，无序性，所有的<code>key</code>构成一个<code>Set</code>集合，所在类需要重<code>hashcode()</code>和<code>equals()</code>方法；</p><p><code>value</code>：可重复，无序性，所有的<code>value</code>构成一个<code>Collection</code>集合，所在类需要重写<code>equals()</code>方法；</p><p>在Map中，存放的数据实际上是一个个数据，并非直观上的一对对数据。这里的<code>key</code>和<code>value</code>实际上是<code>Map.Entry</code>(<code>jdk8</code>以上为<code>Map.Node</code>)的两个属性。Map存放的是一个个<code>Map.Entry</code>。</p><p><code>key</code>和<code>value</code>构成一个<code>entry</code>。所有的<code>entry</code>彼此之间也是无序的，不可重复的，及也为<code>Set</code>。</p><br><p>HashMap的源码刨析：<a href="/2024/03/10/JDK7%E4%B8%8EJDK8-HashMap%E6%BA%90%E7%A0%81%E5%88%A8%E6%9E%90">HashMap的源码刨析</a></p><p><br><strong>常用方法：</strong></p><ul><li>增：</li></ul><p><code>put(Object key ,Object value)</code>：</p><p><code>putAll(Map m)</code>：将m中所有的<code>key-value</code>存放到当前map中；</p><ul><li>删：</li></ul><p><code>remove(Object key)</code>：返回被删除的value；</p><ul><li>改：</li></ul><p><code>put(Object key ,Object value)</code>：返回更改之前的value；</p><p><code>putAll(Map m)</code>：</p><ul><li>查：</li></ul><p><code>get(Object key)</code>：返回value；</p><p><code>containsKey(Object key)</code>：查找是否包含指定的<code>key</code>，返回<code>boolean</code>；</p><p><code>containsValue(Object value)</code>：查找是否包含指定的<code>value</code>，返回<code>boolean</code>；</p><ul><li>长度：</li></ul><p><code>size()</code>:</p><ul><li>遍历：</li></ul><p><code>keySet()</code>：返回<code>key</code>集，数据类型为<code>Set</code>；</p><p><code>values()</code>：返回<code>value</code>集，数据类型为<code>Collection</code>；</p><p><code>entrySet()</code>：返回<code>entry</code>集，数据类型为<code>Set</code>；</p><br><h4 id="HashMap、Hashtable与LinkedHashMap"><a href="#HashMap、Hashtable与LinkedHashMap" class="headerlink" title="HashMap、Hashtable与LinkedHashMap"></a>HashMap、Hashtable与LinkedHashMap</h4><blockquote><p>HashMap常用，Hashtable线程安全且古老，LinkedHashMap基于HashMap，可以保留添加顺序</p></blockquote><p>参考HashSet</p><p><strong>LinkedHashMap:</strong></p><p>是HashMao的子类；在HashMap使用的数据结构基础上，增加了一对双向链表，用于记录添加元素的先后顺序，即遍历时可以根据添加顺序遍历，适合频繁的遍历操作时使用。</p><br><p><strong>HashMap与Hashtable的区别</strong></p><table><thead><tr><th align="center"></th><th align="center">版本</th><th align="center">线程同步</th><th align="center">效率</th><th align="center">允许null键和值</th><th align="center">扩容</th><th align="center">初始容量</th></tr></thead><tbody><tr><td align="center"><strong>HashMap</strong></td><td align="center">1.2</td><td align="center">不同步</td><td align="center">高</td><td align="center">是</td><td align="center">2倍</td><td align="center">16（12）</td></tr><tr><td align="center"><strong>HashTable</strong></td><td align="center">1.0</td><td align="center">同步</td><td align="center">低</td><td align="center">否</td><td align="center">2倍+1</td><td align="center">11（8）</td></tr></tbody></table><br><h4 id="TreeMap"><a href="#TreeMap" class="headerlink" title="TreeMap"></a>TreeMap</h4><blockquote><p>底层使用红黑树存储，可以按照添加的key的属性的大小顺序进行遍历</p></blockquote><br><br><h4 id="Properties"><a href="#Properties" class="headerlink" title="Properties"></a>Properties</h4><blockquote><p>是Hashtable的子类，key 和 value都为string类型，常用于配置文件</p></blockquote><p><code>load(File file)</code>：加载流中的文件中的数据；</p><p><code>getProperty(String str)</code>：类似于Map中的<code>get()</code>，根据<code>key</code>读取<code>value</code>；</p><br><h3 id="Collections集合工具类"><a href="#Collections集合工具类" class="headerlink" title="Collections集合工具类"></a>Collections集合工具类</h3><blockquote><p>collection是储存一个个元素的接口，又分为list，set子接口</p><p>collections是一个操作list，set，map的集合工具类，类似Arrays数组工具类</p></blockquote><ul><li><strong>排序：</strong></li></ul><p><code>reverse(Lisy)</code>：反转List中元素的顺序；</p><p><code>suffle(List)</code>：对List集合元素进行随机排序；</p><p><code>sort(List ,Comparator)</code>：指定排序顺序、不填比较器时默认自然排序；</p><p><code>swap(List,i,j)</code>：将指定List集合中i处元素与j处元素进行交换；</p><ul><li><strong>查找：</strong></li></ul><p><code>max(Collection)</code>：根据自然排序（一般默认为从小到大），取排序后最后一个数（最右边）；</p><p><code>max(Collection,Comparator)</code>：根据定制排序，取排序后最后一个数（最右边）；</p><p><code>min(Collection)</code>：根据自然排序（一般默认为从小到大），取排序后第一个数（最左边）；</p><p><code>min(Collection,Comparator)</code>：根据定制排序，取排序后第一个数（最左边）；</p><p><code>frequency(Collection,Object)</code>：返回集合中指定元素出现的次数；</p><ul><li><strong>复制与只读：</strong></li></ul><p><code>copy(List dest,List src)</code>：将src的集合复制到dest中。<strong>注意：此处的dest的size必须要大于等于src的size</strong>；</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-type">List</span> <span class="hljs-variable">src</span> <span class="hljs-operator">=</span> Arrays.asList(<span class="hljs-number">45</span>,<span class="hljs-number">43</span>,<span class="hljs-number">65</span>,<span class="hljs-number">6</span>,<span class="hljs-number">43</span>,<span class="hljs-number">2</span>,<span class="hljs-number">32</span>,<span class="hljs-number">45</span>,<span class="hljs-number">56</span>,<span class="hljs-number">34</span>,<span class="hljs-number">23</span>);
<span class="hljs-comment">//错误写法：</span>
<span class="hljs-type">List</span> <span class="hljs-variable">dest</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>();
Collections.copy(dest,src);<span class="hljs-comment">//IndexOutOfBoundsException</span>
<span class="hljs-comment">//正确写法：</span>
<span class="hljs-type">List</span> <span class="hljs-variable">dest</span> <span class="hljs-operator">=</span> Arrays.asList(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[src.size()]);
Collections.copy(dest,src);</code></pre></div><p><code>unmodifiableList(List)</code>：该方法返回指定的List不可修改的视图，即无法添加新的元素以及删除元素，只读。</p><ul><li><strong>同步：</strong></li></ul><p><code>synchronizedList(List)</code>：该方法返回指定的List线程同步的集合。</p><br><h2 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h2><p><strong>进程（process）</strong>：程序的一次执行过程，例如运行中的App。</p><ul><li>每一个进程都有一个<strong>独立的内存空间</strong>，系统运行一个程序即是一个进程从创建、运行到消亡的过程（生命周期）。</li><li>进程为<strong>操作系统调度和分配资源的最小单位</strong>(亦是系统运行的基本单位)</li></ul><p><strong>线程（thread）</strong>：是程序内部的一条执行路径，一个进程中至少包含一个线程。</p><ul><li>当一个进程同一时间并行执行多个线程，那么这个进程就是多线程的。</li><li>线程作为<strong>CPU调度和执行的最小单位</strong>。</li><li>一个进程中的多个线程<strong>共享内存单元</strong>，他们从同一个堆中分配对象，可以访问相同的变量和对象。这使得线程通讯更加简便高效，但也带来安全隐患。</li></ul><p><img src="/../img/java/925dc771ef10f61d983cc683a11e0c5a.png" srcset="/img/loading.gif" lazyload></p><p>上图中红色框框即可代表一个进程（也可以代表jvm实例），不同的线程在该进程中共享方法区、堆。</p><p><strong>不同的进程之间是不共享内存的，它们之间的数据交换和通信成本很高</strong>。</p><br><h3 id="线程创建方式"><a href="#线程创建方式" class="headerlink" title="线程创建方式"></a>线程创建方式</h3><p><strong>1、继承方式（继承Thread类）</strong></p><ol><li>创建一个继承于<code>Thread</code>类的子类。</li><li>重写<code>Thread</code>类的<code>run()</code>方法，方法内写需要执行的操作。</li><li>创建该子类的对象，通过对象调用<code>start()</code>方法。</li></ol><p>注：<code>start()</code>方法会开启线程，并且调用线程的<code>run()</code>方法，直接执行<code>run()</code>方法并不会开启多线程。</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">//方式2: 创建Thread类的匿名子类的匿名对象。</span>
<span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>()&#123;
  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;
  
&#125;.start();</code></pre></div><p><strong>2、接口方式（实现Runnable接口）</strong></p><ol><li>创建一个实现<code>runnable</code>接口的类。</li><li>重写接口中的<code>run()</code>方法。</li><li>创建该实现类的对象。</li><li>将此对象作为参数传递到Thread类的构造器中，创建<code>Thread</code>类的实例。</li><li><code>Thread</code>类的实例调用<code>start()</code>方法。</li></ol><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">//方式2：使用Runnable接口的匿名实现类的匿名对象</span>
<span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Runnable</span>()&#123;
  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span>&#123;
    
  &#125;
&#125;).start();</code></pre></div><p><strong>两种方式对比：</strong></p><p>推荐使用<code>runnable</code>接口的方式，有利于数据的共享。（只需要创建一个实现<code>runnable</code>接口的对象）、</p><p><strong>二者联系：</strong></p><p>第一种继承Thread方法，本质上Thread类实现了Runnable接口</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Thread</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span> (代理模式)</code></pre></div><p><strong>3、实现callable接口</strong></p><ol><li>创建一个实现<code>callable</code>接口并重写了<code>run</code>方法的对象。</li><li>将此对象作为参数传递到<code>FutureTask</code>类中，并创建该类的对象。</li><li>将此对象作为参数传递到<code>Thread</code>类中，并创建该类的对象。</li><li><code>Thread</code>类的实例调用<code>start()</code>方法。</li><li>如需得到返回值，需要调用<code>FutureTask</code>对象的<code>get()</code>方法，得到返回值。</li></ol><p><code>callable</code>特别之处：有返回值、可以通过<code>throws</code>抛出异常；比起第二种多了创建<code>FutureTask</code>对象；<code>FutureTask</code>的<code>get()</code>方法在那个线程被调用，哪个线程会进入阻塞。</p><br><p><strong>4、线程池的方式</strong></p><p><strong>现有问题：</strong></p><p>如果并发的线程数量很多，并且每个线程都是执行一个时间很短的任务就结束了，这样频繁创建线程就会大大降低系统的效率，因为频繁创建线程和销毁线程需要时间。那么有没有一种办法使得线程可以复用，即执行完一个任务，并不被销毁，而是可以继续执行其他的任务?</p><p><strong>思路：</strong></p><p>提前创建好多个线程，放入线程池中，使用时直接获取，使用完放回池中。可以避免频繁创建销毁、实现重复利用。类似生活中的公共交通工具。</p><p><strong>优点：</strong></p><ol><li>提高了程序执行效率（线程已经提前创建好了）</li><li>提高了资源的复用率（执行完毕的线程并未销毁，而是归还，后续可以继续使用）</li><li>可以设置相关参数，维护性好，对线程池中的线程使用进行管理</li></ol><br><br><p><img src="/../img/java/e007eb0d0e01fdc572f5f02d0b2aeb5b.png" srcset="/img/loading.gif" lazyload></p><h3 id="线程的常用方法"><a href="#线程的常用方法" class="headerlink" title="线程的常用方法"></a>线程的常用方法</h3><p>**<code>yield()</code>**：主动释放cpu的执行权。</p><p>**<code>join()</code>**：进入阻塞状态。a线程中调用<code>b线程.join()</code>，则a线程进入阻塞，等待b线程完成后再走a线程。</p><p>**<code>isAlive()</code>**：判断该线程是否存活，返回boolean值。</p><p>**<code>getPriority()/setPriority()</code>**：获取&#x2F;设置线程优先级。正常优先级为5，范围为（1~10）;</p><p><strong><code>wait()</code><strong>：线程进入等待状态，同时</strong>释放同步监视器</strong>；调用者必须是同步监视器</p><p><strong><code>sleep()</code><strong>：线程进入等待状态，但</strong>不会释放同步监视器</strong>;</p><p>**<code>notify()</code>**：随机唤醒监视器里一个等待的线程；调用者必须是同步监视器</p><br><br><h3 id="线程的生命周期"><a href="#线程的生命周期" class="headerlink" title="线程的生命周期"></a>线程的生命周期</h3><p><img src="/../img/java/efbc03de006e41ace09f7f3d078e5774.png" srcset="/img/loading.gif" lazyload></p><br><br><h3 id="如何解决线程安全问题？"><a href="#如何解决线程安全问题？" class="headerlink" title="如何解决线程安全问题？"></a>如何解决线程安全问题？</h3><blockquote><p>使用线程的同步机制</p></blockquote><ol><li><p><strong>同步代码块</strong></p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">synchronized</span>(同步监视器)&#123;
  <span class="hljs-comment">//需要被同步的代码</span>
&#125;</code></pre></div><p>说明：</p><p>需要被同步的代码，即为操作共享数据的代码。</p><p>共享数据：即多个线程都需要操作的数据，比如票数量。</p><p>需要被同步的代码，在被<code>synchronized</code>包裹后，就使得一个线程在操作这些代码的过程中，其他线程必须等待。</p><p>同步监视器：俗称锁，哪个线程获得了锁，哪个线程就能执行需要被同步的代码。它可以是任意一个类的对象充当，但是多个线程必须共用同一个同步监视器。通过接口实现的线程可以用<code>this</code>，通过继承实现的线程可以用<code>类名.class</code></p></li><li><p><strong>同步方法</strong></p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">show</span><span class="hljs-params">()</span>&#123; <span class="hljs-comment">//此时的默认监视器为this</span>
  <span class="hljs-comment">//需要被同步的代码</span>
&#125;</code></pre></div><p>说明：</p><p>无论是哪种方式创建的多线程，用此方法时，**默认监视器都为<code>this</code>**。</p><p>如果为接口方式创建的线程，此时<code>this</code>是唯一的，但如果是继承方式创建的线程，此时<code>this</code>不一定唯一。可以考虑的方式为：<strong>将该方法提升为静态方法</strong>，具体问题还得看逻辑适不适合。</p><p>使用继承方式创建的线程不建议使用该方式达成同步目的。</p></li><li><p><strong>使用<code>lock</code></strong></p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">//1.创建Lock的实例，需确保多个线程共用一个Lock实例</span>
<span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReentrantLock</span>();
<span class="hljs-comment">//2.执行lock()方法，锁定</span>
<span class="hljs-keyword">try</span>&#123;
  lock.lock();
  &#125;<span class="hljs-keyword">finally</span>()&#123;<span class="hljs-comment">//确保释放一定被执行</span>
    <span class="hljs-comment">//3.unlock()调用，释放</span>
    lock.unlock();
  &#125;</code></pre></div><p>lock模式提供了更多更广泛的锁，适用更复杂的场景，并且效率高。</p></li></ol><br><p>在一个线程start（）方法中，真正开启线程的并不是start（）方法里面的run（）方法，而是start0（），它是一个native本地方法，由JVM调用，底层是C&#x2F;C++实现的。</p><p><img src="/5542f47236383d1b2f3524fa9427bff4.png" srcset="/img/loading.gif" lazyload alt="线程.png"></p><br><br><h2 id="File类与IO流"><a href="#File类与IO流" class="headerlink" title="File类与IO流"></a>File类与IO流</h2><h3 id="File类"><a href="#File类" class="headerlink" title="File类"></a>File类</h3><blockquote><p>File类的一个对象，对应操作系统下的一个文件或一个文件目录（文件夹）</p></blockquote><p>java中为了防止\编译（例如\n换行），通常使用<code>\\</code>或者<code>/</code>来代替路径中的\</p><p><strong>构造器</strong></p><p>1.以pathname为路径创建File对象，可以是绝对路径&#x2F;相对路径。</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-title function_">File</span><span class="hljs-params">(String pathname)</span>
File file1=<span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(<span class="hljs-string">&quot;d:/io\\hello.txt&quot;</span>);<span class="hljs-comment">// 此为文件</span>
File file2=<span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(<span class="hljs-string">&quot;abc&quot;</span>);<span class="hljs-comment">// 此为目录，且使用相对路径</span></code></pre></div><p>绝对路径：以windows操作系统为例，包括盘符在内的文件或文件目录的完整路径。</p><p>相对路径：以IDEA编译器为例，如果使用单元测试方法：相当于当前的moudle下。如果使用main()方法：相当于当前的project下。</p><p>如果分不清可以通过<code>File.getAbsolutePath()</code>方法来获取当前对象的绝对路径。</p><br><p>2.以parent为父路径，此parent一定为文件目录，child为子路径创建File对象</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-title function_">File</span><span class="hljs-params">(string parent, String child)</span>
File file1=<span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(<span class="hljs-string">&quot;d:/io\\abc&quot;</span>, <span class="hljs-string">&quot;cc&quot;</span>);<span class="hljs-comment">// 此为d:\io\abc目录下的cc目录</span></code></pre></div><br><p>3.因为file对象还可以代表文件目录，根据一个父File对象和子文件路径创建File对象</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-title function_">File</span><span class="hljs-params">(File parent,String child)</span>
File file1=<span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(<span class="hljs-string">&quot;abc&quot;</span>);<span class="hljs-comment">// 此为目录，且使用相对路径</span>
File file2=<span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(file1, <span class="hljs-string">&quot;cc.txt&quot;</span>);</code></pre></div><p><strong>常用方法</strong></p><ul><li>获取文件和目录基本信息：</li></ul><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> String <span class="hljs-title function_">getName</span><span class="hljs-params">()</span>：获取名称。
<span class="hljs-keyword">public</span> String <span class="hljs-title function_">getPath</span><span class="hljs-params">()</span>：获取路径。
<span class="hljs-keyword">public</span> String <span class="hljs-title function_">getAbsolutePath</span><span class="hljs-params">()</span>：获取绝对路径。
<span class="hljs-keyword">public</span> File <span class="hljs-title function_">getAbsoluteFile</span><span class="hljs-params">()</span>：获取绝对路径表示的文件。
<span class="hljs-keyword">public</span> String <span class="hljs-title function_">getParent</span><span class="hljs-params">()</span>：获取上层文件目录路径。若无，返回<span class="hljs-literal">null</span>。
<span class="hljs-keyword">public</span> Long <span class="hljs-title function_">Length</span><span class="hljs-params">()</span>：获取文件长度（即：字节数）。不能获取目录的长度。
<span class="hljs-keyword">public</span> Long <span class="hljs-title function_">LastModified</span><span class="hljs-params">()</span>：获取最后一次的修改时间，毫秒值。</code></pre></div><ul><li>列出自录的下一级：</li></ul><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> String[] list()：返回一个String数组，表示该File目录中的所有子文件或目录。
<span class="hljs-keyword">public</span> File[] listFiles()：返回一个File数组，表示该File目录中的所有的子文件或目录。</code></pre></div><ul><li>判断功能的方法：</li></ul><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">exists</span><span class="hljs-params">()</span>：此File表示的文件或目录是否实际存在。
<span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isDirectory</span><span class="hljs-params">()</span>：此File表示的是否为目录。
<span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isFile</span><span class="hljs-params">()</span>：此File表示的是否为文件。
<span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">canRead</span><span class="hljs-params">()</span>：判断是否可读。
<span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">canWrite</span><span class="hljs-params">()</span>：判断是否可写。
<span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isHidden</span><span class="hljs-params">()</span>：判断是否隐藏。</code></pre></div><ul><li>移动以及重命名：</li></ul><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">renameTo</span><span class="hljs-params">(File dest)</span>：将文件重命名到指定的文件路径。
注：此处的dest对象文件必须不存在，
    且dest对象文件的上级目录必须存在才会移动并重命名成功。</code></pre></div><ul><li>创建、删除功能：</li></ul><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">createNewFile</span><span class="hljs-params">()</span>：创建文件。若文件存在，则不创建，返回<span class="hljs-literal">false</span>。
<span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">mkdir</span><span class="hljs-params">()</span>：创建文件目录。如果此文件目录的上层目录不存在也无法创建
<span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">mkdirs</span><span class="hljs-params">()</span>：创建文件目录。如果上层文件目录不存在，一并创建。
<span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">delete</span><span class="hljs-params">()</span>：删除文件或者文件夹
删除注意事项：①Java中的删除不走回收站。
              ②要删除一个文件目录，请注意该文件目录内不能包含文件或者文件目录。</code></pre></div><h3 id="IO流"><a href="#IO流" class="headerlink" title="IO流"></a>IO流</h3><blockquote><p>大部分数据传输通过流的形式完成</p></blockquote><table><thead><tr><th align="center"></th><th align="center">字节流</th><th align="center">字符流</th></tr></thead><tbody><tr><td align="center"><strong>输入流</strong></td><td align="center">InputStream</td><td align="center">Reader</td></tr><tr><td align="center"><strong>输出流</strong></td><td align="center">OutputStream</td><td align="center">Writer</td></tr></tbody></table><ul><li><p><strong>由这四个类派生出来的子类名称都是以其父类名作为子类名后缀。</strong></p><p><img src="/../img/java/12029432cd49fb1359cb1d9cdc562f35.png" srcset="/img/loading.gif" lazyload></p></li></ul><p>字节流与字符流：</p><ul><li>字节流（8bit）二进制文件，通常保存声音，视频，图片，pdf，word等。</li><li>字符流，按照字符形式读取，适合读取文本信息。</li></ul><p>缓冲流：</p><p>在内存中建立缓存区，减少与磁盘的交互，提升文件的读写效率。在处理大型文件时建议使用</p><br><p>节点流和处理流（包装流）：</p><ul><li>节点流是底层流，直接和数据源相连。</li><li>处理流，对节点流的一种包装，可以实现各种节点流，消除不同节点流的实现差异，采用了<strong>修饰器设计模式</strong>，体现了多态的特点。</li></ul><p><strong>案例：复制已知文件到目标文件</strong></p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-type">FileReader</span> <span class="hljs-variable">fr</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;
<span class="hljs-type">FileWriter</span> <span class="hljs-variable">fw</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;
<span class="hljs-keyword">try</span> &#123;
    <span class="hljs-comment">//1.创建File对象</span>
    <span class="hljs-type">File</span> <span class="hljs-variable">src</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(<span class="hljs-string">&quot;Hello.txt&quot;</span>);
    <span class="hljs-type">File</span> <span class="hljs-variable">dest</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(<span class="hljs-string">&quot;Hello_copy.txt&quot;</span>);
    
    <span class="hljs-comment">//2.创建输入输出流</span>
    fr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileReader</span>(src);
    fw = <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileWriter</span>(dest);
    
    <span class="hljs-comment">//3.数据的读写</span>
    <span class="hljs-type">char</span>[] cbuffer = <span class="hljs-keyword">new</span> <span class="hljs-title class_">char</span>[<span class="hljs-number">5</span>]; <span class="hljs-comment">//创建小车，用以减少与磁盘的交互次数。容量越大越占内存。</span>
    <span class="hljs-type">int</span> len; <span class="hljs-comment">//记录每次读取到cbuffer中字符的个数。</span>
    <span class="hljs-keyword">while</span> ((len = fr.read(cbuffer)) != -<span class="hljs-number">1</span>) &#123;
        fw.write(cbuffer, <span class="hljs-number">0</span>, len); <span class="hljs-comment">//取目标从0开始到len长度的数据。</span>
    &#125;
&#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;
    e.printStackTrace();
&#125; <span class="hljs-keyword">finally</span> &#123;
    <span class="hljs-comment">//4.流的关闭</span>
    <span class="hljs-keyword">try</span> &#123;
        <span class="hljs-keyword">if</span> (fr != <span class="hljs-literal">null</span>)
            fr.close();
    &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;
        e.printStackTrace();
    &#125;
    <span class="hljs-keyword">try</span> &#123;
        <span class="hljs-keyword">if</span> (fw != <span class="hljs-literal">null</span>)
            fw.close();
    &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;
        e.printStackTrace();
    &#125;
&#125;</code></pre></div><p>注：写入操作必须要在close（）或者flush（）方法之后才会写入数据，否则只会将数据保存在内存中。</p><br><p>序列化和反序列化：</p><ul><li>序列化：在保存数据时，保存数据的<strong>数据类型</strong>与值；</li><li>反序列化：在恢复数据时，恢复数据的<strong>数据类型</strong>与值；</li></ul><p>要实现序列化机制，必须实现以下两个接口之一：</p><ul><li>Serializable（标记接口，里面没有任何方法）</li><li>Externalizable</li></ul><br><p>ObjectXXX在序列化和反序列化时的使用注意事项：</p><ol><li>读写顺序要一致。</li><li>要求序列化和反序列化，需要实现Serializable接口，其对象的引用属性也需要实现该接口。</li><li>序列化时候需要添加上SerialVersionUID属性。如果不声明，系统会自动为当前类生成一个SerialVersionUID，并且每次更新该类时SerialVersionUID会改变，无法做到作为唯一标识符的效果。（SerialVersionUID作用类似于hash值确定是否为同一个对象）</li><li>序列化对象时，默认将所有属性都进行序列化，有static和transient修饰的除外。因为static修饰的属性不属于某一个对象。</li><li>具备继承性。其子类也默认继承实现了Serialization接口。</li></ol><p>对象流有什么用？</p><p>-&gt;实际开发中很少使用对象进行传输，实际使用JSON字符串格式进行传输。需要掌握的是序列化和反序列化这个知识点。</p><br><p>其他的一些流：</p><p>案例：记录日志文件</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/*</span>
<span class="hljs-comment">记录日志的方法。</span>
<span class="hljs-comment">*/</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">log</span><span class="hljs-params">(String msg)</span>&#123;
  <span class="hljs-keyword">try</span>&#123;
    <span class="hljs-comment">//指向一个日志文件</span>
    <span class="hljs-type">PrintStream</span> <span class="hljs-variable">out</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">PrintStream</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileoutputStream</span>(<span class="hljs-string">&quot;log.txt&quot;</span>, <span class="hljs-literal">true</span>);
    <span class="hljs-comment">//改变输出方向</span>
    System.setout(out);
    <span class="hljs-comment">//日期当前时间</span>
    <span class="hljs-type">Date</span> <span class="hljs-variable">nowTime</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>();
    <span class="hljs-type">SimpleDateFormat</span> <span class="hljs-variable">sdf</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SimpleDateFormat</span>( pattern:<span class="hljs-string">&quot;yyyy-MM-dd HH:mm:ss SSS&quot;</span>);
    <span class="hljs-type">String</span> <span class="hljs-variable">strTime</span> <span class="hljs-operator">=</span> sdf.format(nowTime);
    System.out.println(strTime +<span class="hljs-string">&quot;:&quot;</span>+ msg);
  &#125;<span class="hljs-keyword">catch</span> （FileNotFoundException e）&#123;
    e.printStackTrace();
  &#125;
&#125;

<span class="hljs-comment">//测试工具类是否好用</span>
Logger.log(<span class="hljs-string">&quot;调用了System类的gc()方法，建议启动垃圾回收&quot;</span>)；
Logger.log(<span class="hljs-string">&quot;调用了TeamView的addMember()方法&quot;</span>);
Logger.log(<span class="hljs-string">&quot;用户尝试进行登录，验证失败&quot;</span>)；</code></pre></div><h2 id="网络编程API"><a href="#网络编程API" class="headerlink" title="网络编程API"></a>网络编程API</h2><blockquote><p>抛出三个问题：</p><p>1.如何准确定位网络上的一台或多态主机？（ip地址）</p><p>2.如何定位主机上的特定的应用？（端口号）</p><p>3.找到主机后，如何高效可靠的进行数据传输？（规范网络通信协议）</p></blockquote><h3 id="InterAddress类"><a href="#InterAddress类" class="headerlink" title="InterAddress类"></a>InterAddress类</h3><blockquote><p>该对象的实例即代表一个具体的ip地址</p></blockquote><p><strong>实例化方式：</strong></p><p>官方不对外公开构造器，因此只能通过该类的静态方法来返回实例。</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">static</span> InetAddress <span class="hljs-title function_">getByName</span><span class="hljs-params">(String host)</span>：获取指定ip对应的InetAddress的实例
<span class="hljs-keyword">static</span> InetAddress <span class="hljs-title function_">getLocaLHost</span><span class="hljs-params">()</span>：获取本地ip对应的InetAddress的实例</code></pre></div><p><strong>两个常用方法：</strong></p><div class="code-wrapper"><pre><code class="hljs java">getHostName();<span class="hljs-comment">//获取域名</span>
getHostAddresss();<span class="hljs-comment">//获取ip地址</span></code></pre></div><h3 id="Socket类"><a href="#Socket类" class="headerlink" title="Socket类"></a>Socket类</h3><blockquote><p>套接字，由网络上具有唯一标识的IP地址和端口号组合在一起构成。</p><p>允许程序把网络连接当成一个流，数据在Socket间通过IO传输。</p></blockquote><p><strong>流套接字：</strong>使用TCP协议的Socket。</p><ul><li><p>客户端</p><p>构造器：<code>Socket(InetAddress address,int port)</code>：指定连接到目标的ip和端口号。</p><p>方法：<code>shutdownOutput()</code>：停止传输，并不会关闭<code>Socket</code>连接。</p></li></ul><p>​ <code>InputStream getlnputStream()</code>：获取<code>Socket</code>输入流。</p><p>​ <code>OutputStream getOutputStream()</code>：向<code>Socket</code>输出流。</p><ul><li><p>服务端</p><p>构造器：<code>ServerSocket(int port)</code>：监听的端口号。</p><p>方法：<code>Socket accept()</code>：接受请求并处理，返回一个双方连接的<code>Socket</code>。没有收到时会进入阻塞状态。</p></li></ul><br><p>项目：<a href="/2024/03/10/%E5%A4%9A%E7%94%A8%E6%88%B7%E5%8D%B3%E6%97%B6%E9%80%9A%E8%AE%AF%E7%B3%BB%E7%BB%9F">多用户即时通讯系统</a></p><br><p><strong>数据报套接字：</strong>使用UDP协议的Socket</p><p>案例：</p><p>客户端：</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">//1.创建DdtdgramSocket的实例</span>
<span class="hljs-type">DatagramSocket</span> <span class="hljs-variable">ds</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DatagramSocket</span>();
<span class="hljs-comment">//2.将数据、目的地的ip，目的地的端口号都封装在DatagramPacket数据报中</span>
<span class="hljs-type">InetAddress</span> <span class="hljs-variable">inetAddress</span> <span class="hljs-operator">=</span> InetAddress.getByName(host:<span class="hljs-string">&quot;127.0.0.1&quot;</span>);
<span class="hljs-type">int</span> <span class="hljs-variable">port</span> <span class="hljs-operator">=</span> <span class="hljs-number">9090</span>;
<span class="hljs-type">byte</span>[] bytes=<span class="hljs-string">&quot;我是发送端&quot;</span>.getBytes(<span class="hljs-string">&quot;utf-8&quot;</span>);
<span class="hljs-type">DatagramPacket</span> <span class="hljs-variable">packet</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DatagramPacket</span>(bytes,θ,bytes.length,inetAddress,port);
<span class="hljs-comment">//发送数据</span>
ds.send(packet);
ds.close();</code></pre></div><p>服务端：</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">//1.创建DatagramSocket的实例</span>
<span class="hljs-type">int</span> <span class="hljs-variable">port</span> <span class="hljs-operator">=</span> <span class="hljs-number">9090</span>;
<span class="hljs-type">DatagramSocket</span> <span class="hljs-variable">ds</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DatagramSocket</span>(port);
<span class="hljs-comment">//2.创建数据报的对象，用于接收发送端发送过来的数据</span>
<span class="hljs-type">byte</span>[] buffer = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[<span class="hljs-number">1024</span> * <span class="hljs-number">64</span>];
DatagramPacket packet=<span class="hljs-keyword">new</span> <span class="hljs-title class_">DatagramPacket</span>(buffer,<span class="hljs-number">0</span>,buffer.length);
<span class="hljs-comment">//3.接收数据</span>
ds.receive(packet);
<span class="hljs-comment">//4.获取数据，并打印到控制台上</span>
String str=<span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(packet.getData(),<span class="hljs-number">0</span>,packet.getLength());
System.out.println(str);
ds.close();</code></pre></div><h3 id="URL类"><a href="#URL类" class="headerlink" title="URL类"></a>URL类</h3><blockquote><p>一个url对应着互联网上某一资源的网址。实际用途在于提供接口给前端调用</p></blockquote><p><strong>格式</strong>： <code>http://127.0.0.1:8080/examples/abcd.jpg?name=Tom</code></p><p>解释：	<code>应用层协议 / ip地址 :端口号 / 资源地址 ? 参数列表</code></p><p><strong>实例化以及常见方法</strong>：</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">//实例化：</span>
<span class="hljs-keyword">new</span> <span class="hljs-title class_">URL</span>(String url);

<span class="hljs-comment">//常见方法：</span>
<span class="hljs-keyword">public</span> String <span class="hljs-title function_">getProtocol</span><span class="hljs-params">()</span>:获取该URL的协议名
<span class="hljs-keyword">public</span> String <span class="hljs-title function_">getHost</span><span class="hljs-params">()</span>:获取该URL的主机名
<span class="hljs-keyword">public</span> String <span class="hljs-title function_">getPort</span><span class="hljs-params">()</span>:获取该URL的端口号
<span class="hljs-keyword">public</span> String <span class="hljs-title function_">getPath</span><span class="hljs-params">()</span>:获取该URL的文件路径
<span class="hljs-keyword">public</span> String <span class="hljs-title function_">getFile</span><span class="hljs-params">()</span>:获取该URL的文件名
<span class="hljs-keyword">public</span> String <span class="hljs-title function_">getQuery</span><span class="hljs-params">()</span>:获取该URL的查询名</code></pre></div><p><strong>案例：下载指定URL上的资源</strong></p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-type">HttpURLConnection</span> <span class="hljs-variable">urlConnection</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;
<span class="hljs-type">InputStream</span> <span class="hljs-variable">is</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;
<span class="hljs-type">FileOutputStream</span> <span class="hljs-variable">fos</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;
<span class="hljs-keyword">try</span>&#123;
  <span class="hljs-comment">//1.获取URL实例</span>
  <span class="hljs-type">URL</span> <span class="hljs-variable">url</span> <span class="hljs-operator">=</span><span class="hljs-keyword">new</span> <span class="hljs-title class_">URL</span>(spec:<span class="hljs-string">&quot;http://127.0.0.1:8080/examples/abcd.jpg&quot;</span>);
  <span class="hljs-comment">//2.建立与服务器端的连接</span>
  urlConnection =(HttpURLConnection) url.openConnection();
  <span class="hljs-comment">//3.获取输入流、创建输出流</span>
  is = urlconnection.getInputStream(）;
  <span class="hljs-type">File</span> <span class="hljs-variable">file</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(<span class="hljs-string">&quot;dest.jpg&quot;</span>);
  fos = <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputStream</span>(file);
  <span class="hljs-comment">//4.读写数据</span>
  <span class="hljs-type">byte</span>[] buffer = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[<span class="hljs-number">1024</span>];
  <span class="hljs-type">int</span> len;
  <span class="hljs-keyword">while</span> ((len =is.read（buffer))!=-<span class="hljs-number">1</span>)&#123;
    fos.write(buffer,θ,len);
  &#125;
  System.out.println(<span class="hljs-string">&quot;文件下载完成&quot;</span>);
&#125;<span class="hljs-keyword">catch</span>(I0Exception e)&#123;
  e.printStackTrace();
&#125;<span class="hljs-keyword">finally</span>&#123;
  <span class="hljs-comment">//5.关闭资源</span>
  <span class="hljs-keyword">try</span>&#123;
    <span class="hljs-keyword">if</span>(fos != <span class="hljs-literal">null</span>)
      fos.close();
  &#125;<span class="hljs-keyword">catch</span>(IoExceptione)&#123;
    e.printStackTrace();
  &#125;
  <span class="hljs-keyword">try</span>&#123;
    <span class="hljs-keyword">if</span>(is != <span class="hljs-literal">null</span>)
      is.close();
  &#125;<span class="hljs-keyword">catch</span>(IoExceptione]&#123;
    e.printStackTrace();
  &#125;
  <span class="hljs-keyword">if</span>(urlConnection != <span class="hljs-literal">null</span>）
    urlConnection.disconnect();
&#125;</code></pre></div><h2 id="注解-Annotation"><a href="#注解-Annotation" class="headerlink" title="注解(Annotation)"></a>注解(Annotation)</h2><blockquote><p>和注释类似，都是对程序代码进行的补充，但是注解是可以被编译器或者其他程序读取的。</p><p>程序可以根据注解的不同，做出相应的处理。</p><p>替代旧版JavaEE中所遗留的<code>繁冗的代码</code>和<code>XML配置</code></p></blockquote><p>注解（Annotation）是从JDK5.0开始引l入，以”@注解名”在代码中存在。</p><p>Annotation可以像修饰符一样被使用，可用于修饰包、类、构造器、方法、成员变量、参数、局部变量的声明。还可以添加一些参数值，这些信息被保存在Annotation的”name&#x3D;value”对中。</p><p>注解可以在类编译、运行时进行加载，体现不同的功能。</p><h3 id="注解的应用场景"><a href="#注解的应用场景" class="headerlink" title="注解的应用场景"></a>注解的应用场景</h3><ol><li>生成文档相关的注解</li><li>在编译时进行格式检查（JDK内置的三个基本注解）<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">//Java基础涉及到的三个常用注解</span>
@0verride：限定重写父类方法，该注解只能用于方法
<span class="hljs-meta">@Deprecated</span>：用于表示所修饰的元素（类，方法等）已过时。通常是因为所修饰的结构危险或存在更好的选择
<span class="hljs-meta">@SuppressWarnings</span>：抑制编译器警告</code></pre></div></li><li>跟踪代码依赖性，实现替代配置文件的功能</li></ol><h3 id="自定义注解"><a href="#自定义注解" class="headerlink" title="自定义注解"></a>自定义注解</h3><blockquote><p>参考@SuppressWarnings注解怎么写</p></blockquote><p>以<code>@SuppressWarnings</code>为例</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Target(&#123;TYPE,FIELD,METHOD,PARAMETER,CONSTRUCTOR,LOCAL_VARIABLE,MODULE&#125;)</span>
<span class="hljs-meta">@Retention(RetentionPolicy.SOURCE)</span>
<span class="hljs-comment">//上面两个为元注解</span>
<span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> SuppressWarnings&#123;
  String[] value(); <span class="hljs-comment">//注解的属性</span>
&#125;</code></pre></div><p>自定义注解：</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> myAnnotation&#123;
  String <span class="hljs-title function_">value</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> <span class="hljs-string">&quot;hello&quot;</span>;  <span class="hljs-comment">//属性并且默认赋值为hello</span>
&#125;</code></pre></div><p>使用自定义注解：</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@myAnnotation(value = &quot;class&quot;)</span> <span class="hljs-comment">//赋值为class</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span>&#123;
  <span class="hljs-meta">@myAnnotation()</span> <span class="hljs-comment">//不赋值则使用默认值hello</span>
  String name;
&#125;</code></pre></div><h3 id="元注解"><a href="#元注解" class="headerlink" title="元注解"></a>元注解</h3><blockquote><p>修饰注解的注解</p></blockquote><ol><li><p><strong><code>@Target</code></strong>:</p><p>用于描述注解的使用范围<br>可以通过枚举类型ElementType的10个常量对象来指定<br>TYPE，METHOD，CONSTRUCTOR，PACKAGE</p></li><li><p>**<code>@Retention</code>**：</p><p>用于描述注解的生命周期<br>可以通过枚举类型RetentionPolicy的3个常量对象来指定<br>SOURCE（源代码）、CLASS（字节码）、RUNTIME(运行时)<br>唯有RUNTIME阶段才能被反射读取到</p></li><li><p>**<code>@Documented</code>**：</p><p>表明这个注解应该被javadoc工具记录</p></li><li><p><strong><code>@lnherited</code></strong>:</p><p>允许子类继承父类中的注解</p></li></ol><br><h2 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h2><blockquote><p>不更改类的前提下控制程序</p><p>在框架方面会大量运用</p><p>jdk11以上</p></blockquote><p>Java中反射图示：</p><p><img src="/../img/java/717f97a564fe825c9d1cd0f9c8a05373.png" srcset="/img/loading.gif" lazyload></p><h3 id="类的加载过程"><a href="#类的加载过程" class="headerlink" title="类的加载过程"></a>类的加载过程</h3><div class="code-wrapper"><pre><code class="hljs coq">过程<span class="hljs-number">1</span>：类的装载（loading）
-&gt;将类的class文件读入内存，并为之创建一个java.lang.<span class="hljs-keyword">Class</span>对象。此过程由类加载器完成

过程<span class="hljs-number">2</span>：链接（linking）
-&gt;验证（Verify）：确保加载的类信息符合JVM规范，例如：以cafebabe开头，没有安全方面的问题。
-&gt;准备（Prepare）：正式为类变量（static）分配内存并设置类变量默认初始值的阶段，这些内存都将在方法区中进行分
配。
-&gt;解析（<span class="hljs-keyword">Resolve</span>）：虚拟机常量池内的符号引用（常量名）替换为直接引用（地址）的过程。

过程<span class="hljs-number">3</span>：初始化（initialization）
-&gt;执行类构造器&lt;clinit&gt;()方法的过程。
-&gt;类构造器&lt;clinit&gt;()方法是由编译期自动收集类中所有类变量的赋值动作和静态代码块中的语句合并产生的。
</code></pre></div><p><strong>对于<code>Class</code>的理解：</strong></p><p><img src="/../img/java/62b20f5dcf086431466ab2073b7d0ad0.png" srcset="/img/loading.gif" lazyload></p><p>针对于编写好的<code>.java</code>源文件进行编译（使用<code>javac.exe</code>），会生成一个或多个<code>.class</code>字节码文件。接着，我们使用<code>java.exe</code>命令对指定的<code>.class</code>文件进行解释运行。这个解释运行的过程中，我们需要将<code>.class</code>字节码文件加载（使用类的加载器）到内存中（存放在方法区）。加载到内存中的<code>.class</code>文件对应的结构即为<code>Class</code>的一个实例。</p><p><code>Class</code>为描述类的类，他的实例往往是各种类。</p><p><strong><code>Class</code>的实例都可以指向哪些结构呢？</strong></p><p>简言之，所有Java类型！</p><ol><li><code>class</code>：外部类，成员（成员内部类，静态内部类），局部内部类，匿名内部类</li><li><code>interface</code>：接口</li><li><code>[]</code>：数组</li><li><code>enum</code>：枚举</li><li><code>annotation</code>:注解@interface</li><li><code>primitivetype</code>：基本数据类型</li><li><code>void</code></li></ol><p><strong>获取Class类的实例的三种方式：</strong></p><p>是获取，并不是创建。同一个类加载器加载类只会加载一次，因此三种方式获取的实例为同一个。</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">//1.调用运行时类的静态属性：class</span>
<span class="hljs-type">Class</span> <span class="hljs-variable">clazz1</span> <span class="hljs-operator">=</span> dog.class;
System.out.println(clazz1);

<span class="hljs-comment">//2.调用运行时类的对象的getClass()</span>
<span class="hljs-type">dog</span> <span class="hljs-variable">u1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">dog</span>();
<span class="hljs-type">Class</span> <span class="hljs-variable">clazz2</span> <span class="hljs-operator">=</span> u1.getClass();

<span class="hljs-comment">//3.调用class的静态方法forName（String className)</span>
<span class="hljs-type">String</span> <span class="hljs-variable">className</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;com.atguigu02._class.dog&quot;</span>;<span class="hljs-comment">//全类名</span>
<span class="hljs-type">Class</span> <span class="hljs-variable">clazz3</span> <span class="hljs-operator">=</span> Class.forName(className);

System.out.println(clazz1 == clazz2);<span class="hljs-comment">//true</span>
System.out.println(clazz1 == clazz3);<span class="hljs-comment">//true</span></code></pre></div><p>注：通过反射得到的对象判断是否相等的条件为：元素类型+维度。</p><p><strong>通过反射获取类，该类的构造器、变量、方法等：</strong></p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">//目标类</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">dog</span>&#123;
    <span class="hljs-keyword">public</span> String name;
    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> num;
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> age;
    <span class="hljs-keyword">public</span> <span class="hljs-title function_">dog</span><span class="hljs-params">()</span>&#123;
        System.out.println(<span class="hljs-string">&quot;无参构造器被调用&quot;</span>);
    &#125;
    <span class="hljs-keyword">public</span> <span class="hljs-title function_">dog</span><span class="hljs-params">(String name, <span class="hljs-type">int</span> num)</span> &#123;
        <span class="hljs-built_in">this</span>.name = name;
        <span class="hljs-built_in">this</span>.num = num;
    &#125;
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">hi</span><span class="hljs-params">()</span>&#123;
        System.out.println(<span class="hljs-string">&quot;hi~&quot;</span>);
    &#125;
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">hi</span><span class="hljs-params">(<span class="hljs-type">int</span> num)</span>&#123;
        <span class="hljs-built_in">this</span>.num=num;
    &#125;
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">eat</span><span class="hljs-params">()</span>&#123;
        System.out.println(<span class="hljs-string">&quot;i want eat&quot;</span>);
    &#125;
    <span class="hljs-keyword">private</span> String <span class="hljs-title function_">play</span><span class="hljs-params">(String name,Integer age)</span>&#123;
        <span class="hljs-keyword">return</span> name+<span class="hljs-string">&quot; &quot;</span>+age;
    &#125;
    <span class="hljs-meta">@Override</span>
    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span> &#123;
        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;dog&#123;&quot;</span> +
                <span class="hljs-string">&quot;name=&#x27;&quot;</span> + name + <span class="hljs-string">&#x27;\&#x27;&#x27;</span> +
                <span class="hljs-string">&quot;age=&#x27;&quot;</span> + age + <span class="hljs-string">&#x27;\&#x27;&#x27;</span> +
                <span class="hljs-string">&quot;, num=&quot;</span> + num +
                <span class="hljs-string">&#x27;&#125;&#x27;</span>;
    &#125;
&#125;

<span class="hljs-comment">//获取该类的Class对象</span>
Class&lt;?&gt; dogCls = Class.forName(<span class="hljs-string">&quot;Reflection.dog&quot;</span>);

<span class="hljs-comment">//通过无参构造器创建实例</span>
<span class="hljs-type">Object</span> <span class="hljs-variable">dog</span> <span class="hljs-operator">=</span> dogCls.getDeclaredConstructor().newInstance();
<span class="hljs-comment">//通过有参构造器创建实例</span>
<span class="hljs-type">Object</span> <span class="hljs-variable">dog1</span> <span class="hljs-operator">=</span> dogCls.getDeclaredConstructor(String.class, <span class="hljs-type">int</span>.class).newInstance(<span class="hljs-string">&quot;hello&quot;</span>, <span class="hljs-number">1</span>);
System.out.println(dog.getClass());<span class="hljs-comment">//运行类型</span>
System.out.println(dog1==dog);<span class="hljs-comment">//实例化的两个类不是同一个</span>

<span class="hljs-comment">//获取该类的属性   （属性名.对象名）</span>
<span class="hljs-type">Field</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> dogCls.getField(<span class="hljs-string">&quot;name&quot;</span>);<span class="hljs-comment">//获取该类的public属性</span>
name.set(dog,<span class="hljs-string">&quot;mike&quot;</span>);<span class="hljs-comment">//设置属性</span>
System.out.println(name.get(dog));<span class="hljs-comment">//获取属性</span>
<span class="hljs-type">Field</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span> dogCls.getDeclaredField(<span class="hljs-string">&quot;num&quot;</span>);<span class="hljs-comment">//获取该类的非public属性</span>
num.setAccessible(<span class="hljs-literal">true</span>);<span class="hljs-comment">//爆破，允许对非public进行操作</span>
num.set(dog,<span class="hljs-number">10</span>);
System.out.println(num.get(dog));
<span class="hljs-type">Field</span> <span class="hljs-variable">age</span> <span class="hljs-operator">=</span> dogCls.getDeclaredField(<span class="hljs-string">&quot;age&quot;</span>);
age.setAccessible(<span class="hljs-literal">true</span>);
age.set(<span class="hljs-literal">null</span>,<span class="hljs-number">20</span>);<span class="hljs-comment">//当该属性为static时，可以在对象形参写空，因为静态变量与类相绑定，而不是该类的对象</span>
System.out.println(age.get(<span class="hljs-literal">null</span>));

<span class="hljs-comment">//获取该类的方法    （方法名.invoke(对象名)）</span>
<span class="hljs-type">Method</span> <span class="hljs-variable">hi</span> <span class="hljs-operator">=</span> dogCls.getMethod(<span class="hljs-string">&quot;hi&quot;</span>);
hi.invoke(dog);
<span class="hljs-type">Method</span> <span class="hljs-variable">eat</span> <span class="hljs-operator">=</span> dogCls.getDeclaredMethod(<span class="hljs-string">&quot;eat&quot;</span>);
eat.setAccessible(<span class="hljs-literal">true</span>);
eat.invoke(<span class="hljs-literal">null</span>);
<span class="hljs-type">Method</span> <span class="hljs-variable">play</span> <span class="hljs-operator">=</span> dogCls.getDeclaredMethod(<span class="hljs-string">&quot;play&quot;</span>, String.class, Integer.class);
play.setAccessible(<span class="hljs-literal">true</span>);
<span class="hljs-type">Object</span> <span class="hljs-variable">john</span> <span class="hljs-operator">=</span> play.invoke(dog, <span class="hljs-string">&quot;John&quot;</span>, <span class="hljs-number">100</span>);
System.out.println(john);

<span class="hljs-comment">//获取运行时类的父类的泛型</span>
<span class="hljs-type">Class</span> <span class="hljs-variable">clazz</span> <span class="hljs-operator">=</span> Class.forName(<span class="hljs-string">&quot;com.atguigu03.reflectapply.data.Person&quot;</span>);
<span class="hljs-comment">//获取带泛型的父类（Type是一个接口，CLass实现了此接口</span>
<span class="hljs-type">Type</span> <span class="hljs-variable">superclass</span> <span class="hljs-operator">=</span> clazz.getGenericSuperclass();
<span class="hljs-comment">//如果父类是带泛型的，则可以强转为ParameterizedType</span>
<span class="hljs-type">ParameterizedType</span> <span class="hljs-variable">paramType</span> <span class="hljs-operator">=</span> (ParameterizedType) superclass;
<span class="hljs-comment">//调用getActuaLTypeArguments（）获取泛型的参数，结果是一个数组，因为可能有多个泛型参数。</span>
Type[] arguments = paramType.getActualTypeArguments();
<span class="hljs-comment">//获取泛型参数的名称</span>
System.out.println(((class)arguments[o]).getName());</code></pre></div><p><strong>通过反射获取注解</strong></p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">//获取类声明上的注解(@Table)</span>
<span class="hljs-type">Classs</span> <span class="hljs-variable">clazz</span> <span class="hljs-operator">=</span> Customer.class;
<span class="hljs-type">Table</span> <span class="hljs-variable">annotation</span> <span class="hljs-operator">=</span> (Table)clazz.getDeclaredAnnotation(Table.class);
System.out.println(annotation.value());

<span class="hljs-comment">//获取属性声明上的注解(@Column)</span>
<span class="hljs-type">Classs</span> <span class="hljs-variable">clazz</span> <span class="hljs-operator">=</span> Customer.class;
<span class="hljs-type">Field</span> <span class="hljs-variable">nameField</span> <span class="hljs-operator">=</span> clazz.getDeclaredField（name:<span class="hljs-string">&quot;name&quot;</span>);<span class="hljs-comment">//获取属性</span>
<span class="hljs-type">Column</span> <span class="hljs-variable">nameColumn</span> <span class="hljs-operator">=</span> nameField.getDeclaredAnnotation(Column.class);
System.out.println(nameColumn.columnName();<span class="hljs-comment">//cust_name</span>
System.out.println(nameColumn.columnType();<span class="hljs-comment">//varchar（15）</span></code></pre></div><br><p><strong>Java反射机制可以完成：</strong></p><ol><li>在程序运行时判断任意一个对象所属的类.</li><li>在程序运行时构造任意一个类的对象.</li><li>在程序运行时得到任意一个类所具有的成员变量和方法.</li><li>在程序运行时调用任意一个对象的成员变量和方法.</li><li>生成动态代理.</li></ol><br><h3 id="反射机制的动态性"><a href="#反射机制的动态性" class="headerlink" title="反射机制的动态性"></a><strong>反射机制的动态性</strong></h3><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">//利用反射机制动态获取需要的实例</span>
<span class="hljs-keyword">public</span> &lt;T&gt; T <span class="hljs-title function_">getInstance</span><span class="hljs-params">(String className)</span> <span class="hljs-keyword">throws</span> Exception&#123;
  <span class="hljs-type">Class</span> <span class="hljs-variable">clazz</span> <span class="hljs-operator">=</span> Class.forName(className);
  <span class="hljs-type">Constructor</span> <span class="hljs-variable">con</span> <span class="hljs-operator">=</span> clazz.getDeclaredconstructor();<span class="hljs-comment">//获取空参构造器</span>
  con.setAccessible(<span class="hljs-literal">true</span>);<span class="hljs-comment">//允许访问私有的</span>
  <span class="hljs-keyword">return</span> (T) con.newInstance();
&#125;
<span class="hljs-comment">//利用反射机制动态获取需要对象实例的方法</span>
<span class="hljs-keyword">public</span> Object <span class="hljs-title function_">invoke</span><span class="hljs-params">(String className,String methodName)</span>throwsException&#123;
  <span class="hljs-comment">//1.创建全类名对应的运行时类的对象</span>
  <span class="hljs-type">Class</span> <span class="hljs-variable">clazz</span> <span class="hljs-operator">=</span> Class.forName(className);
  <span class="hljs-type">Constructor</span> <span class="hljs-variable">con</span> <span class="hljs-operator">=</span> clazz.getDeclaredConstructor();
  con.setAccessible(<span class="hljs-literal">true</span>);
  <span class="hljs-type">Object</span> <span class="hljs-variable">obj</span> <span class="hljs-operator">=</span> con.newInstance();
  <span class="hljs-comment">//2.获取运行时类中指定的方法，并调用</span>
  <span class="hljs-type">Method</span> <span class="hljs-variable">method</span> <span class="hljs-operator">=</span>clazz.getDeclaredMethod(methodName);
  method.setAccessible(<span class="hljs-literal">true</span>);
  <span class="hljs-keyword">return</span> method.invoke(obj); <span class="hljs-comment">//return method.invoke(getInstance(className))</span>
&#125;</code></pre></div><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">className</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;java.util.Date&quot;</span>;
<span class="hljs-type">Date</span> <span class="hljs-variable">date</span> <span class="hljs-operator">=</span> getInstance(className);
System.out.println(date);<span class="hljs-comment">//得到了实例化对象</span>
System.out.println(invoke(<span class="hljs-string">&quot;java.util.Date&quot;</span>,<span class="hljs-string">&quot;方法名&quot;</span>));<span class="hljs-comment">//调用方法</span></code></pre></div><h3 id="根据反射机制实现榨汁机的案例"><a href="#根据反射机制实现榨汁机的案例" class="headerlink" title="根据反射机制实现榨汁机的案例"></a><strong>根据反射机制实现榨汁机的案例</strong></h3><p>榨汁机榨水果汁，水果分别有苹果（AppLe）、香蕉（Banana）、桔子（Orange）等。</p><p>步骤：</p><ol><li>声明(Fruit)水果接口，包含榨汁抽象方法：<code>void squeeze()</code>。</li><li>声明榨汁机（<code>Juicer</code>)，包含运行方法：<code>public void run(Fruit f)</code>，方法体中，调用f的榨汁方法<code>squeeze()</code></li><li>声明各种水果类，实现水果接口，并重写<code>squeeze()</code>;</li><li>在src下，建立配置文件：<code>config.properties</code>，并在配置文件中配上<code>fruitName=xxx</code>（其中xx为某种水果的全类名）</li><li>在<code>FruitTest</code>测试类中，<ol><li>读取配置文件，获取水果类名，并用反射创建水果对象，</li><li>创建榨汁机对象，并调用<code>run()</code>方法</li></ol></li></ol><p>实现：</p><ul><li>水果接口以及各种水果类<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Fruit</span> &#123;
    <span class="hljs-keyword">void</span> <span class="hljs-title function_">squeeze</span><span class="hljs-params">()</span>;
&#125;</code></pre></div><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Apple</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Fruit</span>&#123;
    <span class="hljs-meta">@Override</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">squeeze</span><span class="hljs-params">()</span> &#123;
        System.out.println(<span class="hljs-string">&quot;榨一杯儿苹果汁&quot;</span>);
    &#125;
&#125;</code></pre></div><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Banana</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Fruit</span>&#123;
    <span class="hljs-meta">@Override</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">squeeze</span><span class="hljs-params">()</span> &#123;
        System.out.println(<span class="hljs-string">&quot;榨一杯儿香蕉汁&quot;</span>);
    &#125;
&#125;</code></pre></div><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Orange</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Fruit</span>&#123;
    <span class="hljs-meta">@Override</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">squeeze</span><span class="hljs-params">()</span> &#123;
        System.out.println(<span class="hljs-string">&quot;榨一杯儿橙汁&quot;</span>);
    &#125;
&#125;</code></pre></div></li><li>榨汁机<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Juicer</span> &#123;
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">(Fruit f)</span>&#123;
        f.squeeze();
    &#125;
&#125;</code></pre></div></li><li><code>FruitTest</code>测试类<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">try</span> (<span class="hljs-type">InputStream</span> <span class="hljs-variable">input</span> <span class="hljs-operator">=</span> FruitTest.class.getClassLoader().getResourceAsStream(<span class="hljs-string">&quot;config.properties&quot;</span>)) &#123;
    <span class="hljs-comment">//1.读取配置文件中的信息，获取全类名。（使用类的加载器方法读取配置文件）</span>
    <span class="hljs-type">Properties</span> <span class="hljs-variable">prop</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Properties</span>();
    <span class="hljs-keyword">if</span> (input == <span class="hljs-literal">null</span>) &#123;
        System.out.println(<span class="hljs-string">&quot;unable to find config.properties&quot;</span>);
        <span class="hljs-keyword">return</span>;
    &#125;
    prop.load(input);
    <span class="hljs-type">String</span> <span class="hljs-variable">fruitName</span> <span class="hljs-operator">=</span> prop.getProperty(<span class="hljs-string">&quot;fruitName&quot;</span>);

    <span class="hljs-comment">//2.通过反射创建全类名对应的实例。</span>
    <span class="hljs-type">Class</span> <span class="hljs-variable">aClass</span> <span class="hljs-operator">=</span> Class.forName(fruitName);
    <span class="hljs-type">Constructor</span> <span class="hljs-variable">con</span> <span class="hljs-operator">=</span> aClass.getDeclaredConstructor();
    con.setAccessible(<span class="hljs-literal">true</span>);
    <span class="hljs-type">Fruit</span> <span class="hljs-variable">fruit</span> <span class="hljs-operator">=</span> (Fruit) con.newInstance();

    <span class="hljs-comment">//3.通过榨汁机调用对象的榨汁方法。</span>
    <span class="hljs-type">Juicer</span> <span class="hljs-variable">juicer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Juicer</span>();
    juicer.run(fruit);
&#125; <span class="hljs-keyword">catch</span> (Exception ex) &#123;
    ex.printStackTrace();
&#125;</code></pre></div></li></ul><h2 id="JDBC"><a href="#JDBC" class="headerlink" title="JDBC"></a>JDBC</h2><blockquote><p>JDBC为访问不同的数据库提供了统一的接口，为使用者屏蔽了细节问题。</p></blockquote><br><h3 id="JDBC的原理示意图"><a href="#JDBC的原理示意图" class="headerlink" title="JDBC的原理示意图"></a>JDBC的原理示意图</h3><p><img src="/../img/java/c38ab5aa61256011e6c0473b01a13928.png" srcset="/img/loading.gif" lazyload></p><br><h3 id="JDBC程序编写步骤"><a href="#JDBC程序编写步骤" class="headerlink" title="JDBC程序编写步骤"></a>JDBC程序编写步骤</h3><ol><li>注册驱动-加载Driver类</li><li>获取链接-得到Connection</li><li>执行增删改查-发送SQL给数据库</li><li>释放资源-关闭相关链接</li></ol><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">//前置工作：需要将jar包导入到项目工程（add as library）</span>

<span class="hljs-comment">//1.注册驱动</span>
<span class="hljs-type">Driver</span> <span class="hljs-variable">driver</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Driver</span>();

<span class="hljs-comment">//2.得到连接-底层是socket</span>
<span class="hljs-comment">//创建连接字符串</span>
String url=<span class="hljs-string">&quot;jdbc:mysql://localhost:3306/数据库名字&quot;</span>
<span class="hljs-comment">//将用户名和密码放入一个Properties对象中</span>
<span class="hljs-type">Properties</span> <span class="hljs-variable">properties</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Properties</span>();
properties.setProperty(<span class="hljs-string">&quot;user&quot;</span>,<span class="hljs-string">&quot;root&quot;</span>)<span class="hljs-comment">//properties的key是规定好的</span>
properties.setProperty(<span class="hljs-string">&quot;password&quot;</span>,<span class="hljs-string">&quot;123456&quot;</span>);
<span class="hljs-comment">//获取连接</span>
<span class="hljs-type">Connection</span> <span class="hljs-variable">connect</span> <span class="hljs-operator">=</span> dirver.connect(url,properties);

<span class="hljs-comment">//3.执行sql</span>
String sql=<span class="hljs-string">&quot;xxx&quot;</span>
<span class="hljs-comment">//statement用于执行静态SQL语句并返回其生成结果的对象</span>
<span class="hljs-type">Statement</span> <span class="hljs-variable">statement</span> <span class="hljs-operator">=</span> connect.creatStatement();
<span class="hljs-type">int</span> rows - statement.executeUpdate(sql);<span class="hljs-comment">//返回受影响的行数</span>

<span class="hljs-comment">//4.关闭连接资源</span>
statement.close();
connect.close();</code></pre></div><br><p><strong>连接的五种方式</strong></p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">//1.直接创建</span>
<span class="hljs-type">Driver</span> <span class="hljs-variable">driver</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Driver</span>();

<span class="hljs-comment">//2.通过反射动态加载，更加灵活，减少依赖性</span>
Class&lt;?&gt; aClass = Class.forName(<span class="hljs-string">&quot;com.mysql.jdbc.Driver&quot;</span>);
<span class="hljs-type">Driver</span> <span class="hljs-variable">driver</span> <span class="hljs-operator">=</span> (Driver)aClass.newInstance();

<span class="hljs-comment">//3.通过DriverManager来统一管理</span>
Class&lt;?&gt; aClass = Class.forName(<span class="hljs-string">&quot;com.mysql.jdbc.Driver&quot;</span>);
<span class="hljs-type">Driver</span> <span class="hljs-variable">driver</span> <span class="hljs-operator">=</span> (Driver)aClass.newInstance();

String url=<span class="hljs-string">&quot;jdbc:mysql://localhost:3306/xxx&quot;</span>；
String user=<span class="hljs-string">&quot;root&quot;</span>;
String password=<span class="hljs-string">&quot;123456&quot;</span>;

DriverManager.registerDriver(driver);<span class="hljs-comment">//注册Driver驱动</span>
<span class="hljs-type">Connection</span> <span class="hljs-variable">connection</span> <span class="hljs-operator">=</span> DriverManager.getConnection(url,user,password);

<span class="hljs-comment">//4.使用Class.forName自动完成注册驱动，简化代码</span>
Class.forName(<span class="hljs-string">&quot;com.mysql.jdbc.Driver&quot;</span>);

String url=<span class="hljs-string">&quot;jdbc:mysql://localhost:3306/xxx&quot;</span>；
String user=<span class="hljs-string">&quot;root&quot;</span>;
String password=<span class="hljs-string">&quot;123456&quot;</span>;

<span class="hljs-type">Connection</span> <span class="hljs-variable">connection</span> <span class="hljs-operator">=</span> DriverManager.getConnection(url,user,password);
<span class="hljs-comment">//1.mysqL驱动5.1.6可以无需CLass .forName(“com.mysqljdbc.Driver”);</span>
<span class="hljs-comment">//2.从jdk1.5以后使用了jdbc4,不再需要显示调用class.forName()</span>
<span class="hljs-comment">//注册驱动而是自动调用驱动jar包下META-IN\services\java.sql.Driver文本中的类名称去注册</span>
<span class="hljs-comment">//3.建议还是写上 CLass .forName(“com.mysql.jdbc.Driver”),更加明确</span>

<span class="hljs-comment">//5.将url，user，password写入properties文件中动态调用</span>
Properties properties=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Properties</span>();
Properties.load(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(<span class="hljs-string">&quot;src\\xxx.properties&quot;</span>));
<span class="hljs-comment">//获取相关值</span>
<span class="hljs-type">String</span> <span class="hljs-variable">url</span> <span class="hljs-operator">=</span> properties.getProperty(<span class="hljs-string">&quot;url&quot;</span>);
<span class="hljs-type">String</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> properties.getProperty(<span class="hljs-string">&quot;user&quot;</span>);
<span class="hljs-type">String</span> <span class="hljs-variable">password</span> <span class="hljs-operator">=</span> properties.getProperty(<span class="hljs-string">&quot;password&quot;</span>);
<span class="hljs-type">String</span> <span class="hljs-variable">driver</span> <span class="hljs-operator">=</span> properties.getProperty(<span class="hljs-string">&quot;driver&quot;</span>);

Class.forName(driver);
<span class="hljs-type">Connection</span> <span class="hljs-variable">connection</span> <span class="hljs-operator">=</span> DriverManager.getConnection(url,user,password);</code></pre></div><br><h3 id="部分API"><a href="#部分API" class="headerlink" title="部分API"></a>部分API</h3><br><p><img src="/../img/java/77e5d258add9dbd3530994aac680206b.png" srcset="/img/loading.gif" lazyload></p><br><ul><li><p><strong>ResultSet</strong></p><p>在执行查询语句后，返回的结果以ResultSet结果集保存，本身也是模拟的一张表。它拥有一个光标，默认指向第一行，通过next方法，它会向下一行移动，如果没有下一行，则会返回flase（-1）。</p><p>resultSet包含了很多数据，其中结果数据存放位置在rowData的rows中。rows是一个ArrayList链表，其中的size代表查询返回多少行数据，真正储存的数据在rows的elementData中。 elementData是一个对象数组，长度取决查询得到的行数，即上面的size，他代表着每行的数据。 elementData数组中又包含internalRowData，他是一个字节数组，代表着每列的数据，长度取决于当前行中列的数量，其中每一个位置该行该列的数据。</p><p>rows：ArrayList链表</p><p>elemetData：Object数组</p><p>internalRowData：byte数组</p><p>因此数据储存的范围：</p><p>rowData -&gt; rows -&gt; elemetData（每行） -&gt; internalRowData（每列）</p></li></ul><p><img src="/../img/java/b9c45d5fb0fe8d4a6869b578cc1aa651.png" srcset="/img/loading.gif" lazyload></p><br><ul><li><p><strong>Statement和PreparedStatement</strong></p><p>我们在建立连接之后，需要对数据库进行访问，执行命令或者是sql语句，可以通过statement用于执行静态sql语句，并返回结果对象。</p><p>statement存在sql注入，不要使用！preparedStatement经过预处理后不会存在sql注入问题。</p><p>preparedStatement可以对需要执行的sql语句中的参数用 “ ？”来占位，调用setXXX（）方法来设置这些参数。setXXX（）有两个参数，第一个为占位符所在的索引（下标从1开始），第二个为需要赋的值。</p><p><strong>PreparedStatement的好处：</strong></p><p>1.利于拼接sql语句，减少语法错误。</p><p>2.有效解决了sql注入问题。</p><p>3.大大减少了编译次数，效率更高。</p></li></ul><br><h3 id="JDBC中事务与批处理"><a href="#JDBC中事务与批处理" class="headerlink" title="JDBC中事务与批处理"></a>JDBC中事务与批处理</h3><p><strong>事务的操作：</strong></p><p>默认情况下，commition是默认自动提交的，要想将很多sql语句作为一个整体，需要手动关掉connection的setAutoCommit为flase，这样需要手动connection.commit（）提交如果捕获到异常，可以在异常处理中手动回滚rollback()，默认回滚到事务开启的地方。</p><br><p><strong>批处理：</strong></p><p>当需要成批插入或者更新记录时，可以采用java的批量处理机制，这一机制允许多条语句一次性成批提交给数据库处理，通常情况下比单独处f理更加有效。批处理往往和PreparedStatement一起使用，既可以减少编译次数，又可以减少运行次数，效率大大提高。</p><p><strong>要使用批处理，需要对url中添加rewriteBatchedStatements&#x3D;true,否则不会生效</strong></p><p>JDBC批处理的方法：</p><div class="code-wrapper"><pre><code class="hljs java">String url=<span class="hljs-string">&quot;jdbc:mysql://localhost:3306/xxx?rewriteBatchedStatements=true&quot;</span>；
preparedStatement.addBatch();<span class="hljs-comment">//添加需要批处理的sql语句或参数；</span>
preparedStatement.executeBatch();<span class="hljs-comment">//执行批量处理语句；</span>
preparedStatement.clearBatch();<span class="hljs-comment">//清空批处理包的语句；</span></code></pre></div><p>preparedStatement.addBatch()后，sql语句储存在preparedStatement中的batchedArgs的elementData对象数组中。并且elementData对象数组默认为10的大小，以1.5倍扩容。其中每一个sql对象中的问号占位符参数存放在parameterStrings字节数组中。</p><p>preparedStatement：预处理对象。</p><p>batchedArgs：属于preparedStatement对象中。是一个ArrayList数组，存放批处理的sql语句的主要位置。</p><p>elementData：属于batchedArgs中，是一个对象数组，存放每个sql对象。</p><p>parameterStrings：存放占位符的参数。</p><p>因此批量处理的sql储存的范围为：</p><p>preparedStatement -&gt; batchedArgs -&gt; elementData</p><p><img src="/../img/java/6923c6bd8b5ca60dff00076776647d31.png" srcset="/img/loading.gif" lazyload></p><p><img src="/../img/java/d67d3e9c5ca7c15a0b7e655cc4b80e61.png" srcset="/img/loading.gif" lazyload></p><br><h3 id="JavaBean"><a href="#JavaBean" class="headerlink" title="JavaBean"></a>JavaBean</h3><blockquote><p>通过数据集拿到的数据，不方便分类管理和拿取，且需要和connection相关联，因此此时JavaBean出现了</p><p>将得到的数据当成一个对象，其中每个列名即为该对象的一个字段，很多条数据就很多个对象，用集合来储存。这便是JavaBean，一种处理方式&#x2F;逻辑，体现了java面向对象和多态的特点，方便管理和规划 。同时它也叫做PoJO，domain，实体类</p></blockquote><p>JavaBean中数据类型与Mysql数据库中数据类型的对应关系：</p><table><thead><tr><th align="center">Mysql中</th><th align="center">JavaBean中</th></tr></thead><tbody><tr><td align="center">int</td><td align="center">Integer</td></tr><tr><td align="center">char、varchar</td><td align="center">String</td></tr><tr><td align="center">double</td><td align="center">Double</td></tr><tr><td align="center">date</td><td align="center">date&#x2F;String</td></tr></tbody></table><p>注：int,double 等在 Java 中都用包装类，因为 mysql 中的所有类型都可能是NULL，而 Java 只有引用数据类型才有NULL值。</p><br><h3 id="数据库连接池"><a href="#数据库连接池" class="headerlink" title="数据库连接池"></a>数据库连接池</h3><blockquote><p>传统的JDBC数据库连接使用 DriverManager来获取，每次向数据库建立连接的时候都要将 Connection 加载到内存中再验证IP地址，用户名和密码(0.05s~1s时间)。需要数据库连接的时候就向数据库要求一个，频繁的进行数据库连接操作将占用很多的系统资源，容易造成服务器崩溃。</p><p>每一次数据库连接，使用完后都得断开，如果程序出现异常而未能关闭，将导致数据库内存泄漏，最终将导致重启数据库。</p><p>传统获取连接的方式，不能控制创建的连接数量，如连接过多，也可能导致内存泄漏，MySQL崩溃。</p><p>简而言之，传统JDBC方法对connection没有任何优化，用户持有connection过多会影响其他用户的连接等待。这里需要做的就是对connection进行代理优化和控制。</p></blockquote><p><strong>特点：</strong></p><ol><li>预先在缓冲池中放入一定数量的连接，当需要建立数据库连接时，只需从“缓冲池”中取出一个，使用完毕之后再放回去。</li><li>数据库连接池负责分配、管理和释放数据库连接，它允许应用程序重复使用一个现有的数据库连接，而不是重新建立一个。</li><li>当应用程序向连接池请求的连接数超过最大连接数量时，这些请求将被加入到等待队列中。</li></ol><p><img src="/../img/java/aca234ed3f28f8bc2977e6de9bda6c16.png" srcset="/img/loading.gif" lazyload></p><p>Java官方为数据库连接池提供了接口：DataSource，第三方去实现。</p><p><strong>几种常用数据库连接池：</strong></p><ol><li>C3PO数据库连接池，速度相对较慢，稳定性不错 （hibernate, spring）；</li><li>Druid(德鲁伊) 是阿里提供的数据库连接池，集DBCP 、C3PO 、Proxool优点于一身的数据库连接池 （推荐使用）</li></ol><br><p><strong>C3P0</strong></p><p>需要在libs下手动加入jar包 -&gt; 引入项目（add as liarbry）</p><p>配置文件拷贝到项目的src目录</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">//获取相关信息（driver，url，user，psw）</span>
<span class="hljs-comment">//创建一个数据源对象</span>
<span class="hljs-type">ComboPooledDataSource</span> <span class="hljs-variable">comboPooledDataSource</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ComboPooledDataSource</span>();
<span class="hljs-comment">//设置相关参数</span>
comboPooledDataSource.setDriverClass(driver);
comboPooledDataSource.setJdbcUrl(url);
comboPooledDataSource.setUser(user);
comboPooledDataSource.setPassword(password);
<span class="hljs-comment">//初始化连接数</span>
comboPooledDataSource.setInitialPoorSize(<span class="hljs-number">10</span>);
<span class="hljs-comment">//设置最大连接</span>
comboPooledDataSource.setMaxPoorSize(<span class="hljs-number">50</span>);
<span class="hljs-comment">//connection</span>
<span class="hljs-type">Connection</span> <span class="hljs-variable">connection</span> <span class="hljs-operator">=</span> comboPooledDataSource.getConnection();



<span class="hljs-comment">//方法二：通过配置文件直接更改。</span>
<span class="hljs-type">ComboPooledDataSource</span> <span class="hljs-variable">comboPooledDataSource</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ComboPooledDataSource</span>(<span class="hljs-string">&quot;配置文件名字&quot;</span>);
<span class="hljs-type">Connection</span> <span class="hljs-variable">connection</span> <span class="hljs-operator">=</span> comboPooledDataSource.getConnection();</code></pre></div><br><p><strong>Druid</strong></p><p>需要在libs下手动加入jar包 -&gt; 引入项目（add as liarbry）</p><p>配置文件拷贝到项目的src目录</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">//获取配置文件</span>
<span class="hljs-type">Properties</span> <span class="hljs-variable">properties</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Properties</span>();
properties.load(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(<span class="hljs-string">&quot;src\\druid.properties&quot;</span>));
<span class="hljs-comment">//创建一个指定参数的数据库连接池</span>
<span class="hljs-type">DataSource</span> <span class="hljs-variable">dataSource</span> <span class="hljs-operator">=</span> DruidDataSourceFactory.createDataSource(properties);
<span class="hljs-type">Connection</span> <span class="hljs-variable">connection</span> <span class="hljs-operator">=</span> dataSource.getConnection();</code></pre></div><br><h3 id="结果集工具类"><a href="#结果集工具类" class="headerlink" title="结果集工具类"></a>结果集工具类</h3><blockquote><p>有很多时候查询出来的结果需要多次使用，查询返回的ResultSet结果集是与connection相关的，一旦连接关闭，则结果集就无法使用。</p><p>用户也不能一直持有connection，因此需要对查询得到的结果进行转存。</p></blockquote><p><img src="/../img/java/a0c5c6aaf4bfe683afc0874250ec1984.png" srcset="/img/loading.gif" lazyload></p><p><strong>核心思路：</strong>将得到的结果集中每行以一个对象的形式储存，最后将每行数据（对象）存在集合中，这样脱离出来了ResultSet，也脱离了connection。</p><br><p><strong>Apache-DBUtils</strong></p><ol><li>commons-dbutils 是 Apache 组织提供的一个开源 JDBC工具类库，它是对JDBC的封装，使用dbutils能极大简化jdbc编码的工作量。</li><li>QueryRunner类: 该类封装了SQL的执行，是线程安全的。可以实现增、删、改、查、批处理</li></ol><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">//大致方法：</span>
ArrayHandler: <span class="hljs-comment">//把结果集中的第一行数据转成对象数组</span>
ArrayListHandler: <span class="hljs-comment">//把结果集中的每一行数据都转成一个数组，再存放到List中</span>
BeanHandler: <span class="hljs-comment">//将结果集中的第一行数据封装到一个对应的JavaBean实例中</span>
BeanListHandler: <span class="hljs-comment">//将结果集中的每一行数据都封装到一个对应的JavaBean实例中，存放到List里</span>
ColumnListHandler: <span class="hljs-comment">//将结果集中某一列的数据存放到List中</span>
KeyedHandler(name): <span class="hljs-comment">//将结果集中的每行数据都封装到Map里，再把这些map再存到一个map里，其key为指定的key</span>
MapHandler: <span class="hljs-comment">//将结果集中的第一行数据封装到一个Map里，key是列名，value就是对应的值</span>
MapListHandler: <span class="hljs-comment">//将结果集中的每一行数据都封装到一个Map里，然后再存放到List</span>

ScalarHandler();<span class="hljs-comment">//返回单行单列</span>
BeanHandler();<span class="hljs-comment">//返回单行多列</span>
BeanListHandler<span class="hljs-comment">//返回多行多列</span>

<span class="hljs-comment">//举例：</span>
<span class="hljs-type">Connection</span> <span class="hljs-variable">connection</span> <span class="hljs-operator">=</span> JDBCUtilsByRruid.getConnection();<span class="hljs-comment">//获取连接</span>
<span class="hljs-type">QueryRunner</span> <span class="hljs-variable">queryRunner</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">QueryRunner</span>();<span class="hljs-comment">//创建QueryRunner类</span>
<span class="hljs-type">String</span> <span class="hljs-variable">sql</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;select * from xxx where id = ?&quot;</span>;
<span class="hljs-comment">/**</span>
<span class="hljs-comment">* 1.query方法是执行sql语句，得到 resultSet -&gt; 封装到 ArrayList 集合中</span>
<span class="hljs-comment">* 2.new BeanListHandler&lt;&gt;(Actor.class):在 resultSet -&gt; Actor对象 -&gt; 封装到 ArrayList中</span>
<span class="hljs-comment">* 3.这个“1”是可变参数，是sql语句中“？”占位符的赋值，此处是查找id = 1的数据</span>
<span class="hljs-comment">* 4.底层得到的resultSet、preparedStatement，会在query这个方法中关闭，无需手动关闭</span>
<span class="hljs-comment">*/</span>
List&lt;Actor&gt; list =
    queryRunner.query(connection , sql , <span class="hljs-keyword">new</span> <span class="hljs-title class_">BeanListHandler</span>&lt;&gt;(Actor.class) , <span class="hljs-number">1</span>);
<span class="hljs-comment">//dml的操作：</span>
<span class="hljs-type">int</span> <span class="hljs-variable">affectedRow</span> <span class="hljs-operator">=</span> queryRunner.upDate(connection , sql , <span class="hljs-string">&quot;&quot;</span> ,<span class="hljs-string">&quot;&quot;</span>);<span class="hljs-comment">//返回受影响的行数</span></code></pre></div><br><h3 id="DAO的引出"><a href="#DAO的引出" class="headerlink" title="DAO的引出"></a>DAO的引出</h3><blockquote><p>DAO &#x3D; data access object ，数据访问对象，内部封装了操作数据库相关表的增删改查操作。</p></blockquote><p>上述用apache-dbutil（结果集） + Druid（连接池）简化了JDBC的开发，但是还是有很多不足：</p><ol><li>sql语句固定，不能通过参数传入，通用性不佳。</li><li>对于查询操作，返回值不能固定，需要使用泛型。</li><li>只能对单一表进行操作，无法实现业务需求复杂的情况。</li></ol><br><p>因此，我们可以对上述进行优化，将写sql的地方单独拿出来，如下图：</p><p><img src="/../img/java/401b85c552f4f1c10f96a39387f0dd27.png" srcset="/img/loading.gif" lazyload></p><br><h2 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h2><blockquote><p>处理文本的利器。一个正则表达式，就是用某种模式去匹配字符串的一个公式</p></blockquote><p><strong>语法与分析：</strong></p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">//1.创建模式对象，即正则表达式</span>
<span class="hljs-type">Pattern</span> <span class="hljs-variable">pattern</span> <span class="hljs-operator">=</span> Pattern .compile(<span class="hljs-string">&quot;\\d&quot;</span>) <span class="hljs-string">&quot;\d&quot;</span>表示任意一个数字。第一个<span class="hljs-string">&quot;\&quot;表示转义字符</span>
<span class="hljs-string">//2.创建匹配器</span>
<span class="hljs-string">Matcher matcher = pattern .matcher(&quot;</span>str<span class="hljs-string">&quot;):</span>
<span class="hljs-string">//3.开始匹配</span>
<span class="hljs-string">while (matcher.find())&#123;</span>
<span class="hljs-string">  System.out.println(matcher.group(0));</span>
<span class="hljs-string">&#125;</span>
<span class="hljs-string"></span>
<span class="hljs-string">//源码分析：</span>
<span class="hljs-string">matcher.find():</span>
<span class="hljs-string">  1.根据指定的规则，匹配到子字符串。</span>
<span class="hljs-string">  2.将找到的子字符串的索引记录到matcher对象的属性int []groups中。</span>
<span class="hljs-string">    groups[0] = 子字符串的首位索引  groups[1] = 子字符串的末尾索引+1；（左开右闭原则）</span>
<span class="hljs-string">  3.同时记录oldLast的值为 子字符串的末尾索引+1，用于下次find时的定位。</span>
<span class="hljs-string">  4.清空groups数组（清空原因在于后续分组的情况）。</span>
<span class="hljs-string">  </span>
<span class="hljs-string">matcher.group(0):  //注意这里的group和上面的groups不是一个东西！</span>
<span class="hljs-string">  1.源码可以看出，调用group(*)方法时，retrun的是与groups(*2)和groups(*2+1)。</span>
<span class="hljs-string">  </span>
<span class="hljs-string">  </span>
<span class="hljs-string">分组的情况：（即在模式对象中的匹配字符串用“（）”分组）</span>
<span class="hljs-string"></span>
<span class="hljs-string">matcher.find():</span>
<span class="hljs-string">  1.根据指定的规则，匹配到子字符串。</span>
<span class="hljs-string">  2.将找到的子字符串的索引记录到matcher对象的属性int []groups中。</span>
<span class="hljs-string">    groups[0] = 子字符串的首位索引  groups[1] = 子字符串的末尾索引+1；（左开右闭原则）</span>
<span class="hljs-string">    groups[1] = 第一组的首位索引    groups[2] = 第一组的末尾索引+1;</span>
<span class="hljs-string">    groups[3] = 第二组的首位索引    groups[4] = 第二组的末尾索引+1</span>
<span class="hljs-string">  3.同时记录oldLast的值为 子字符串的末尾索引+1，用于下次find时的定位。</span>
<span class="hljs-string">  4.清空groups数组。</span>
<span class="hljs-string">  </span>
<span class="hljs-string">matcher.group(*):</span>
<span class="hljs-string">  1.源码可以看出，调用group(*)方法时，return的是与groups(*2)和groups(*2+1)。</span>
<span class="hljs-string">  2.因此在matcher.group(0)时，return的是groups[0]和groups[1]，这是返回所有的匹配值;</span>
<span class="hljs-string">    而matcher.group(1)时，return的是groups[1*2=2]和groups[1*2+1=3]，可知返回的是第一组的值</span>
<span class="hljs-string">    matcher.group(2)时，return的是groups[2*2=4]和groups[2*2+1=5]，可知返回的是第二组的值</span>
<span class="hljs-string">    后续以此类推</span></code></pre></div><h3 id="限定符"><a href="#限定符" class="headerlink" title="限定符"></a><strong>限定符</strong></h3><blockquote><p>限定字符出现的次数</p></blockquote><table><thead><tr><th align="center">符号</th><th align="center">解释</th><th align="center">实例</th><th align="center">解释</th></tr></thead><tbody><tr><td align="center">*</td><td align="center">重复0-n次（默认贪婪匹配，尽可能匹配多的）</td><td align="center">(ab)*</td><td align="center">仅包含ab的字符（ab、ababab）</td></tr><tr><td align="center">+</td><td align="center">重复1-n次</td><td align="center">a+b*</td><td align="center">至少一个a与任意b的字符（aaab、abb、abbbbb）</td></tr><tr><td align="center">?</td><td align="center">可有可无</td><td align="center">m+abc?</td><td align="center">至少一个m与ab或abc字符（mab、mmabc、mmab）</td></tr><tr><td align="center">?</td><td align="center">当此字符紧随任何其他限定符 (*、+、?、{n}、{n,}、{n,m})之后时，匹配模式是”非贪心的”。</td><td align="center">o+?</td><td align="center">在字符串”oooo”中，”o+?”只匹配单个”o”，而”o+”匹配所有”o”</td></tr><tr><td align="center">{n}</td><td align="center">只能出现n次</td><td align="center">[abcd]{2}</td><td align="center">由abcd任意组成长度为2的字符串(（ab、ad、ac）</td></tr><tr><td align="center">{n,}</td><td align="center">至少出现n次</td><td align="center">[abcd]{2,}</td><td align="center">由abcd任意组成长度大于2的字符串(（ab、ad、abcd）</td></tr><tr><td align="center">{n,m}</td><td align="center">至少n次最多m次（默认贪婪匹配，尽可能匹配多的）</td><td align="center">{abcd}{1，3}</td><td align="center">由abcd任意组成长度大于1小于3的字符串(（a、ad、abc）</td></tr></tbody></table><h3 id="匹配符"><a href="#匹配符" class="headerlink" title="匹配符"></a><strong>匹配符</strong></h3><blockquote><p>选择字符出现的范围</p></blockquote><table><thead><tr><th align="center">符号</th><th align="center">含义</th><th align="center">示例</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">[ ]</td><td align="center">可接收的字符列表</td><td align="center">[edfg]</td><td align="center">匹配edfg中的任意一个字符</td></tr><tr><td align="center">[^]</td><td align="center">不可接受的字符列表</td><td align="center">[^edfg]</td><td align="center">匹配除了edfg中的任意一个字符</td></tr><tr><td align="center">-</td><td align="center">连字符</td><td align="center">A-Z</td><td align="center">任意一个大写字母（A-Z之间）</td></tr><tr><td align="center">.</td><td align="center">除\n（换行）以外的任何字符</td><td align="center">a..b</td><td align="center">以a开头，b结尾，中间两个任意字符（aXXb）</td></tr><tr><td align="center">\d</td><td align="center">单个数字字符 &#x3D;&#x3D;[0-9]</td><td align="center">\d{2}(\d)?</td><td align="center">包含2个或3个数字的字符串（123、1234）</td></tr><tr><td align="center">\D</td><td align="center">单个非数字字符 &#x3D;&#x3D;[^0-9]</td><td align="center">\D(\d)*</td><td align="center">以非数字开头的，后面任意数字（a、D3245）</td></tr><tr><td align="center">\w</td><td align="center">单个数字，大小写字母字符&#x3D;&#x3D;[0-9a-zA-Z]</td><td align="center">\d{3}\w{4}</td><td align="center">三个数字开头+四个数字、大小写字母字符（123pasd、1234567）</td></tr><tr><td align="center">\W</td><td align="center">单个非数字大小写字母字符&#x3D;&#x3D;[^0-9a-zA-Z]</td><td align="center">\W+\d{2}</td><td align="center">以至少一个非数字字母字符开头，2个数字字符结尾的字符串（#29、#?@10）</td></tr><tr><td align="center">\s</td><td align="center">单个任意空字符（空格，制表符等）</td><td align="center"></td><td align="center"></td></tr><tr><td align="center">\S</td><td align="center">单个非任意空字符</td><td align="center"></td><td align="center"></td></tr><tr><td align="center">(?i)</td><td align="center">不区分大小写</td><td align="center">a((?i)b)c</td><td align="center">只有b不区分大小写</td></tr><tr><td align="center">|</td><td align="center">选择匹配</td><td align="center">a|b</td><td align="center">a或b</td></tr></tbody></table><h3 id="定位符"><a href="#定位符" class="headerlink" title="定位符"></a><strong>定位符</strong></h3><blockquote><p>规定要匹配的字符串出现的位置，比如在字符串的开始还是结束</p></blockquote><table><thead><tr><th>符号</th><th>含义</th><th>示例</th><th>说明</th><th>匹配输入</th></tr></thead><tbody><tr><td>^</td><td>指定起始字符</td><td>^[0-9]+[a-z]*</td><td>至少以1个数字开头，后面任意的小写字母的字符串</td><td>123、6aa、555edf</td></tr><tr><td>$</td><td>指定结束字符</td><td>^[0-9]\-[a-z]$</td><td>至少以1个数字开头，后面连接”-“并以小写字母结尾的字符串</td><td>1-a</td></tr><tr><td>\b</td><td>匹配目标字符串的边界</td><td>han\b</td><td>边界是指之间有空格，或者是结束位置</td><td>123&#x3D;&#x3D;han&#x3D;&#x3D; nn&#x3D;&#x3D;han&#x3D;&#x3D;</td></tr><tr><td>\B</td><td>匹配目标字符串的非边界</td><td>han\B</td><td>与\b相反</td><td>&#x3D;&#x3D;han&#x3D;&#x3D;shunping</td></tr></tbody></table><p><strong>整体匹配(matches)</strong></p><blockquote><p>用于验证输入的字符串是否满足条件</p><p>返回值：boolean</p></blockquote><div class="code-wrapper"><pre><code class="hljs java">String str=<span class="hljs-string">&quot;nihaode_wtbu123.cc2&amp;SJ&quot;</span>;
String regStr=<span class="hljs-string">&quot;.*wtbu.*&quot;</span>;
<span class="hljs-type">boolean</span> <span class="hljs-variable">matches</span> <span class="hljs-operator">=</span> Pattern.matches(regStr, str);
<span class="hljs-comment">//或者boolean matches = str.matches(regStr);</span>
System.out.println(matches);</code></pre></div><p><strong>分组、捕获、反向引用</strong></p><blockquote><p>分组即用括号包起来的一种复杂的匹配模式</p><p>捕获即把分组的内容保存在内存中并以命名或数字编号的形式，方便引用</p><p>反向引用即获取捕获中的内容，并且可以当作新的匹配模式去使用。内部反向引用用\，外部则用$</p></blockquote><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-number">1</span>、匹配五个连续相同的数字
(\\d)\\<span class="hljs-number">1</span>&#123;<span class="hljs-number">4</span>&#125;
<span class="hljs-number">2</span>、匹配千位数与个位数相同，百位数与十位数相同（<span class="hljs-number">5225</span>、<span class="hljs-number">1551</span>）
(\\d)(\\d)\\<span class="hljs-number">2</span>\\<span class="hljs-number">1</span></code></pre></div><p><strong>案例</strong></p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// 去重</span>
String content=<span class="hljs-string">&quot;我我要要要学Javaa&quot;</span>
content = Pattern.compile(<span class="hljs-string">&quot;(.)\\1+&quot;</span>).matcher(content).replaceAll(<span class="hljs-string">&quot;$1&quot;</span>)
<span class="hljs-comment">//验证邮箱合法</span>
String content=<span class="hljs-string">&quot;z118_4490022@qq.com&quot;</span>
content.matches(<span class="hljs-string">&quot;[\\w]+@([a-zA-Z]+\\.)+[a-zA-Z]&quot;</span>)
<span class="hljs-comment">//验证是否是数字</span>
String content=<span class="hljs-string">&quot;-0.89&quot;</span>
content.matches(<span class="hljs-string">&quot;[-+]?\\d+(\\.\\d+)?&quot;</span>)</code></pre></div><h2 id="Java8特性"><a href="#Java8特性" class="headerlink" title="Java8特性"></a>Java8特性</h2><h3 id="lambda表达式"><a href="#lambda表达式" class="headerlink" title="lambda表达式"></a>lambda表达式</h3><blockquote><p>使用更简洁的方式</p><p>使用前提：满足函数式接口：（接口中只声明了一个抽象方法）</p></blockquote><p><strong>语法：</strong></p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">//标准形式：</span>
<span class="hljs-type">Runnable</span> <span class="hljs-variable">r1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Runnable</span>()&#123;
  <span class="hljs-meta">@Override</span>
  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;
    System.out.printIn(<span class="hljs-string">&quot;我爱北京天安门&quot;</span>);
&#125;
r1.run();

<span class="hljs-comment">//lambda形式</span>
<span class="hljs-type">Runnable</span> <span class="hljs-variable">r2</span> <span class="hljs-operator">=</span> () -&gt; System.out.println(<span class="hljs-string">&quot;我爱北京天安门&quot;</span>);
r2.run();

  ()：方法参数
  -&gt;：lambda操作符\箭头函数
  &#123;&#125;：方法体</code></pre></div><p><strong>本质：</strong></p><p>作为函数式接口的实例（接口实现类的对象）</p><p><strong>使用情况：</strong></p><p><code>-&gt;</code>左边：当<code>()</code>中没有参数时，只需要写<code>()</code>；如果只有一个参数时，其<code>()</code>可以省略，例如<code>e -&gt; &#123;sout(e)&#125;</code>；有一个以上参数时<code>()</code>不可以省略。</p><p><code>-&gt;</code>右边：当<code>&#123;&#125;</code>中只有一条语句时（包括<code>return</code>语句），其<code>&#123;&#125;</code>和<code>return</code>关键字都可以省略。例如<code>e -&gt; e + 1</code>;</p><br><h3 id="Java内置核心函数式接口"><a href="#Java内置核心函数式接口" class="headerlink" title="Java内置核心函数式接口"></a>Java内置核心函数式接口</h3><p><strong>什么是函数式接口?</strong></p><p>如果接口中只声明有一个抽象方法，则此接口就称为函数式接口。</p><p>只有给函数式接口提供实现类的对象时，我们才可以使用lambda表达式。</p><p>函数式接口会有<code>@FunctionInterface</code>注解标记。</p><table><thead><tr><th align="left">函数式接口</th><th align="center">参数类型</th><th align="center">返回类型</th><th align="left">用途</th></tr></thead><tbody><tr><td align="left"><code>Consumer&lt;T&gt;</code> 消费型接口</td><td align="center">T</td><td align="center">void</td><td align="left">对类型为T的对象应用操作，包含方法：<code>void accept(T t)</code></td></tr><tr><td align="left"><code>Supplier&lt;T&gt;</code>供给型接口</td><td align="center">无</td><td align="center">T</td><td align="left">返回类型为T的对象，包含方法：<code>T get()</code></td></tr><tr><td align="left"><code>Function&lt;T,R&gt;</code>函数型接口</td><td align="center">T</td><td align="center">R</td><td align="left">对类型为T的对象应用操作，并返回结果。结果是R类型的对象。包含方法：<code>R apply(T t)</code></td></tr><tr><td align="left"><code>Predicate&lt;T&gt;</code>断定型接口</td><td align="center">T</td><td align="center">boolean</td><td align="left">确定类型为T的对象是否满足某约束，并返回boolean值。包含方法：<code>boolean test(T t)</code></td></tr></tbody></table><p>更多的在<code>java.util.function</code>包下</p><p><strong>案例</strong></p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">//Consumer&lt;T&gt; 消费型接口</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">text</span><span class="hljs-params">()</span>&#123;
    <span class="hljs-comment">//原写法</span>
    happyTime(<span class="hljs-number">500</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Consumer</span>&lt;Double&gt;() &#123;
        <span class="hljs-meta">@Override</span>
        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">accept</span><span class="hljs-params">(Double aDouble)</span> &#123;
            System.out.println(<span class="hljs-string">&quot;学习太累，去天上人间买了瓶矿泉水，价格为&quot;</span>+aDouble);
        &#125;
    &#125;);
    <span class="hljs-comment">//lambda写法</span>
    happyTime(<span class="hljs-number">400</span>,money -&gt; System.out.println(<span class="hljs-string">&quot;学习太累，去白马会所喝了口水，价格为&quot;</span>+money));
&#125;
<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">happyTime</span><span class="hljs-params">(<span class="hljs-type">double</span> money, Consumer&lt;Double&gt; con)</span>&#123;
    con.accept(money);
&#125;



<span class="hljs-comment">//Predicate&lt;T&gt; 断定型接口</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">text2</span><span class="hljs-params">()</span>&#123;
    List&lt;String&gt; list= Arrays.asList(<span class="hljs-string">&quot;北京&quot;</span>,<span class="hljs-string">&quot;南京&quot;</span>,<span class="hljs-string">&quot;东京&quot;</span>,<span class="hljs-string">&quot;吴京&quot;</span>,<span class="hljs-string">&quot;天津&quot;</span>);
    <span class="hljs-comment">//原写法</span>
    List&lt;String&gt; newString = filterString(list, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Predicate</span>&lt;String&gt;() &#123;
        <span class="hljs-meta">@Override</span>
        <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">test</span><span class="hljs-params">(String s)</span> &#123;
            <span class="hljs-keyword">return</span> s.contains(<span class="hljs-string">&quot;京&quot;</span>);
        &#125;
    &#125;);
    System.out.println(newString);
    <span class="hljs-comment">//lambda写法</span>
    List&lt;String&gt; newString2 = filterString(list, s -&gt; s.contains(<span class="hljs-string">&quot;京&quot;</span>));
    System.out.println(newString2);
&#125;
<span class="hljs-keyword">public</span> List&lt;String&gt; <span class="hljs-title function_">filterString</span><span class="hljs-params">(List&lt;String&gt; list, Predicate&lt;String&gt; pre)</span>&#123;
    ArrayList&lt;String &gt; arrayList=<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();
    <span class="hljs-keyword">for</span> (String s : list) &#123;
        <span class="hljs-keyword">if</span> (pre.test(s))&#123;
            arrayList.add(s);
        &#125;
    &#125;
    <span class="hljs-keyword">return</span> arrayList;
&#125;</code></pre></div><h3 id="方法引用"><a href="#方法引用" class="headerlink" title="方法引用"></a>方法引用</h3><blockquote><p>可以看作是基于lambda表达式的进一步刻画。</p></blockquote><p>当需要提供一个函数式接口的实例时，我们可以使用lambda表达式提供此实例。当满足一定条件下，我们还可以使用方法引用或构造器引用替换lambda表达式。</p><p>因此<strong>方法引用也可以作为函数式接口的实例</strong></p><p><strong>格式：</strong></p><ol><li><p><code>对象::实例方法(非静态方法)</code>：</p><p>要求：函数式接口中的抽象方实现时调用的对象的某个方法b的形参列表和返回值类型都相同此时，可以考虑使用方法b实现对方法a的替换、覆盖。此替换或覆盖即为方法引用。</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">//1.通过new的方式创建</span>
Consumer&lt;String&gt; consumer = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Consumer</span>&lt;String&gt;() &#123;
    <span class="hljs-meta">@Override</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">accept</span><span class="hljs-params">(String s)</span> &#123;
        System.out.println(s);
    &#125;
&#125;;

<span class="hljs-comment">//2.使用lambda表达式</span>
Consumer&lt;String&gt; consumer1 = s -&gt; System.out.println(s);

<span class="hljs-comment">//3.使用方法引用</span>
Consumer&lt;String&gt; consumer2 = System.out::println;</code></pre></div></li><li><p><code>类::静态方法</code>：</p><p>要求：同上。</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">//1.通过new的方式创建</span>
Comparator&lt;Integer&gt; comparator = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Comparator</span>&lt;Integer&gt;() &#123;
    <span class="hljs-meta">@Override</span>
    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">compare</span><span class="hljs-params">(Integer o1, Integer o2)</span> &#123;
        <span class="hljs-keyword">return</span> Integer.compare(o1, o2);
    &#125;
&#125;;

<span class="hljs-comment">//2.使用lambda表达式</span>
Comparator&lt;Integer&gt; comparator1 = (o1, o2) -&gt; o1.compareTo(o2);

<span class="hljs-comment">//3.使用方法引用</span>
Comparator&lt;Integer&gt; comparator3 = Integer::compare;</code></pre></div></li><li><p><code>类::实例方法</code>：</p><p>要求：函数式接口中的抽象方法a与其内部实现时调用的对象的某个方法b的返回值类型相同。同时，抽象方法a中有n个参数，方法b中有n-1个参数，且抽象方法a的第1个参数作为方法b的调用者，且抽象方法a的后n-1个参数与方法b的n-1个参数的类型相同（或一致）。则可以考虑使用方法b实现对方法a的替换、覆盖。此替换或覆盖即为方法引用。</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">//1.通过new的方式创建</span>
Comparator&lt;String&gt; comparator = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Comparator</span>&lt;String&gt;() &#123;
    <span class="hljs-meta">@Override</span>
    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">compare</span><span class="hljs-params">(String o1, String o2)</span> &#123;
        <span class="hljs-keyword">return</span> o1.compareTo(o2);
    &#125;
&#125;;

<span class="hljs-comment">//2.使用lambda表达式</span>
Comparator&lt;String&gt; comparator1 = (o1, o2) -&gt; o1.compareTo(o2);

<span class="hljs-comment">//3.使用方法引用</span>
Comparator&lt;String&gt; comparator3 = String::compareTo;</code></pre></div></li></ol><h4 id="构造器引用"><a href="#构造器引用" class="headerlink" title="构造器引用"></a>构造器引用</h4><ol><li>空参构造器：<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">//1.通过new的方式创建</span>
Supplier&lt;Apple&gt; supplier = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Supplier</span>&lt;Apple&gt;() &#123;
    <span class="hljs-meta">@Override</span>
    <span class="hljs-keyword">public</span> Apple <span class="hljs-title function_">get</span><span class="hljs-params">()</span> &#123;
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Apple</span>();
    &#125;
&#125;;

<span class="hljs-comment">//2.使用lambda表达式</span>
Supplier&lt;Apple&gt; supplier1 = () -&gt; <span class="hljs-keyword">new</span> <span class="hljs-title class_">Apple</span>();

<span class="hljs-comment">//3.使用方法引用</span>
Supplier&lt;Apple&gt; supplier2 = Apple::<span class="hljs-keyword">new</span>;</code></pre></div></li><li>有参构造器：<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">//1.通过new的方式创建</span>
BiFunction&lt;String, Float, Employee&gt; biFunction = <span class="hljs-keyword">new</span> <span class="hljs-title class_">BiFunction</span>&lt;String, Float, Employee&gt;() &#123;
    <span class="hljs-meta">@Override</span>
    <span class="hljs-keyword">public</span> Employee <span class="hljs-title function_">apply</span><span class="hljs-params">(String name, Float sal)</span> &#123;
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Employee</span>(name, sal);
    &#125;
&#125;;

<span class="hljs-comment">//2.使用lambda表达式</span>
BiFunction&lt;String, Float, Employee&gt; biFunction1 = (name, sal) -&gt; <span class="hljs-keyword">new</span> <span class="hljs-title class_">Employee</span>(name, sal);

<span class="hljs-comment">//3.使用方法引用</span>
BiFunction&lt;String, Float, Employee&gt; biFunction2 = Employee::<span class="hljs-keyword">new</span>;</code></pre></div></li></ol><br><h3 id="Stream-API"><a href="#Stream-API" class="headerlink" title="Stream API"></a>Stream API</h3><blockquote><p>java对数据处理的一种补充，对集合数据进行操作，类似于使用SQL执行的数据查询</p></blockquote><p><strong>背景：</strong></p><p>实际开发中，项目中多数数据源都来自于Mysql，Oracle等。但现在数据源可以更多了，有MongDB，Radis等，而这些NOSQL的数据就需要Java层面去处理</p><p><strong>Stream 和 Collection 集合的区别</strong></p><p>Collection 是一种静态的内存数据结构，而 Stream 是有关计算的。</p><p>Collection 主要面向内存，存储在内存中，后者主要是面向 CPU，通过 CPU 实现计算。</p><p><strong>注意事项</strong></p><ol><li>Stream自己不会储存数据</li><li>Stream不会改变源对象。相反，他们会返回一个持有结果的新Stream</li><li>Stream操作时延迟执行的。这意味着他们会等到需要结果的时候才执行</li></ol><p><strong>Stream的三个操作</strong></p><ol><li><p>创建Stream</p><p>一个数据源（集合、数组等），获取一个流</p></li><li><p>中间操作</p><p>一个中间操作链，对数据源的数据进行处理（filter、map等）</p></li><li><p>终止操作（终端操作）</p><p>一旦执行终止操作，<strong>才会执行中间操作链</strong>，并产生结果。<strong>之后该Stream不会在被使用</strong></p></li></ol><p><img src="/../img/java/b79aa6b3d93ccbae45268b16f2d3e3fd.png" srcset="/img/loading.gif" lazyload></p><h4 id="Stream的实例化："><a href="#Stream的实例化：" class="headerlink" title="Stream的实例化："></a><strong>Stream的实例化：</strong></h4><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">//创建方式一：通过集合创建</span>
ArrayList&lt;Object&gt; lsit = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();
Stream&lt;Object&gt; stream = lsit.stream();<span class="hljs-comment">//顺序流</span>
Stream&lt;Object&gt; stream1 = lsit.parallelstream();<span class="hljs-comment">//并行流</span>

<span class="hljs-comment">//创建方式二：通过数组创建</span>
<span class="hljs-type">int</span>[] ints=<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">5</span>];
<span class="hljs-type">IntStream</span> <span class="hljs-variable">stream2</span> <span class="hljs-operator">=</span> Arrays.stream(ints);

<span class="hljs-comment">//创建方式三：通过Stream.of()创建</span>
Stream&lt;Integer&gt; integerStream = Stream.of(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>);

<span class="hljs-comment">//迭代</span>
<span class="hljs-comment">//遍历前10个偶数</span>
Stream.iterate(<span class="hljs-number">0</span>, s -&gt; s + <span class="hljs-number">2</span>).limit(<span class="hljs-number">10</span>).forEach(System.out::print);
<span class="hljs-comment">//生成</span>
<span class="hljs-comment">//生成10个随机数</span>
Stream.generate(Math::random).limit(<span class="hljs-number">10</span>).forEach((System.out::print));</code></pre></div><h4 id="Stream的中间操作"><a href="#Stream的中间操作" class="headerlink" title="Stream的中间操作"></a><strong>Stream的中间操作</strong></h4><p><strong>筛选与切片</strong></p><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td><code>filert(Predicate p)</code></td><td>接收lambda，从流中排除某些元素</td></tr><tr><td><code>distinct()</code></td><td>去重，通过<code>hashcode()</code>和<code>equals()</code>实现</td></tr><tr><td><code>limit(long maxSize)</code></td><td>截断，使其元素不超过<code>maxSize</code></td></tr><tr><td><code>skip(long n)</code></td><td>返回跳过了前<code>n</code>个元素的流</td></tr></tbody></table><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">//filter(Predicate p)--从流中排除某些元素</span>
Stream&lt;Employee&gt; stream = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;Employee&gt;().stream();
stream.filter(e-&gt;e.getSalary()&gt;<span class="hljs-number">1000</span>)
<span class="hljs-comment">//limit(n)--截断流。使其元素不超过指定数量</span>
stream.limit(<span class="hljs-number">3</span>)
<span class="hljs-comment">//skip(n)--跳过元素。返回一个扔掉前n个元素的流</span>
stream.skip(<span class="hljs-number">3</span>)
<span class="hljs-comment">//distinct()--去重。通过流所生成元素的hashcode和equals去除重复元素</span>
stream.distinct()</code></pre></div><p><strong>映射</strong></p><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td><code>map(Function f)</code></td><td>接收一个函数作为参数，该函数会被应用到每个元素上并将其映射成一个新的元素。</td></tr><tr><td><code>mapToXXX(ToXXXFunction f)</code></td><td>同上，其中<code>XXX</code>表示数据基本类型</td></tr><tr><td><code>flagMap(Function f)</code></td><td>接收一个函数作为参数，将流中的每个值都换成另一个流，然后把所有的流连接成一个流</td></tr></tbody></table><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">//map(Function f)--接受一个函数作为参数，将元素转换成其他形式或提取信息</span>
Stream&lt;Integer&gt; integerStream = Stream.of(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>);
integerStream.map(s-&gt;s+<span class="hljs-number">1</span>).forEach(System.out::print);

<span class="hljs-comment">//flatMap(Function f)--接受一个函数作为参数，将流中的每个值都换成另一个流并且展开存放</span>
List&lt;String&gt; list = Arrays.asList(<span class="hljs-string">&quot;aa&quot;</span>,<span class="hljs-string">&quot;bb&quot;</span>,<span class="hljs-string">&quot;cc&quot;</span>);
Stream&lt;Character&gt; characterStream = list.stream().flatMap(text::fromStringToStream);
characterStream.forEach(System.out::print);
<span class="hljs-comment">//将字符串的每个字符转成steam流</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Stream&lt;Character&gt; <span class="hljs-title function_">fromStringToStream</span><span class="hljs-params">(String str)</span> &#123;
    ArrayList&lt;Character&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();
    <span class="hljs-keyword">for</span> (Character c : str.toCharArray()) &#123;
        list.add(c);
    &#125;
    <span class="hljs-keyword">return</span> list.stream();
&#125;
<span class="hljs-comment">//flagMap和map的区别？</span>
<span class="hljs-comment">//如果使用map：stream中包含的是stream(Character)</span>
Stream&lt;Stream&lt;Character&gt;&gt; streamStream = list.stream().map(text::fromStringToStream);
streamStream.forEach(s-&gt;&#123;
    s.forEach(System.out::print);
&#125;);
<span class="hljs-comment">//而使用flatMap：stream中包含的是Character</span>
Stream&lt;Character&gt; characterStream = list.stream().flatMap(text::fromStringToStream);
<span class="hljs-comment">//综上，区别在于flatMap会将元素为stream流给展开再填入</span></code></pre></div><p><strong>排序</strong></p><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td><code>sorted()</code></td><td>产生一个新流，按其中自然排序排序</td></tr><tr><td><code>sorted()</code></td><td>产生一个新流，按其中比较器顺序排序</td></tr></tbody></table><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">//sorted()--自然排序（小-&gt;大）前提：实现了Comparable接口！！！</span>
Stream&lt;Integer&gt; integerStream = Stream.of(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>);
integerStream.sorted().foreach(System.out::print);

<span class="hljs-comment">//sorted(Comparator com)--定制排序</span>
List&lt;Employee&gt; list = EmployeeData.getEmployee();<span class="hljs-comment">//拿到list</span>
list.stream().sorted((e1,e2) -&gt; Integer.compare(e1.getAge(),e2.getAge()));</code></pre></div><h4 id="Stream终止操作"><a href="#Stream终止操作" class="headerlink" title="Stream终止操作"></a>Stream终止操作</h4><p><strong>匹配与查找</strong></p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">//allMatch(Predicate p)--检查是否匹配所有元素</span>
<span class="hljs-comment">//是否所有的员工年龄都大于18？</span>
<span class="hljs-type">boolean</span> <span class="hljs-variable">allMatch</span> <span class="hljs-operator">=</span> employees.stream().allMatch(e-&gt;e.getAge()&gt;<span class="hljs-number">18</span>);

<span class="hljs-comment">//anyMatch(Predicate p)--检查是否匹配任意一个元素</span>
<span class="hljs-comment">//是否有员工的工资大于10000？</span>
<span class="hljs-type">boolean</span> <span class="hljs-variable">anyMatch</span> <span class="hljs-operator">=</span> employees.stream().anyMatch(e-&gt;e.getSalary()&gt;<span class="hljs-number">10000</span>);

<span class="hljs-comment">//noneMatch(Predicate p)--检查是否没有匹配的元素</span>
<span class="hljs-comment">//是否有员工姓雷？</span>
<span class="hljs-type">boolean</span> <span class="hljs-variable">noneMatch</span> <span class="hljs-operator">=</span> employees.stream().noneMatch(e-&gt;e.getName().startsWith(<span class="hljs-string">&quot;雷&quot;</span>));

<span class="hljs-comment">//findFirst()--返回第一个元素</span>
Optional&lt;Employee&gt; employee = employees.stream().findFirst();

<span class="hljs-comment">//count()--返回个数</span>
<span class="hljs-type">long</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> employees.stream().filter(e-&gt;e.getSalary()&gt;<span class="hljs-number">5000</span>).count();

<span class="hljs-comment">//max(Comparator c)--返回最大值（排序最右边）</span>
Optional&lt;Double&gt; maxSalary = employees.stream().map(e-&gt;e.getSalary()).max(Double::compare);

<span class="hljs-comment">//min(Comparator c)--返回最小值（排序最左边）</span>
Optional&lt;Double&gt; employee = employees.stream().min((e1,e2)-&gt;Double.compare(e1.getSalary(),e2.getSalary));</code></pre></div><p><strong>归约</strong></p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">//reduce(T identity,BinaryOperator)--可以将流中元素发布反复结合起来，得到一个值。</span>
<span class="hljs-comment">//计算1-10的自然数和</span>
List&lt;Integer&gt; list = Array.asList(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>,<span class="hljs-number">10</span>);
<span class="hljs-type">Integer</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> list.stream().reduce(<span class="hljs-number">0</span> , Integer::sum);</code></pre></div><p><strong>收集</strong></p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">//collect(Collector c)--可以将流中元素转成list、set、map</span>
List&lt;Integer&gt; list = Array.asList(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>,<span class="hljs-number">10</span>);
List&lt;Integer&gt; list2 = list.stream().filter(e-&gt;e&gt;<span class="hljs-number">5</span>).collect(Collectors.toList());</code></pre></div><h3 id="Optional类"><a href="#Optional类" class="headerlink" title="Optional类"></a>Optional类</h3><blockquote><p>Optional<t>类(java.util.Optional) 是一个容器类，它可以保存类型T的值，代表这个值存在。或者仅仅保存null，表示这个值不存在。原来用 null 表示一个值不存在，现在 Optional 可以更好的表达这个概念。并且可以避免空指针异常。</t></p></blockquote><br><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-type">Boy</span> <span class="hljs-variable">boy</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Boy</span>(<span class="hljs-string">&quot;张三&quot;</span>);
<span class="hljs-comment">//Optional.of(T t)--不能存放空的对象，为空返回空指针异常</span>
boy=<span class="hljs-literal">null</span>;
Optional&lt;Boy&gt; o = Optional.of(boy);<span class="hljs-comment">//java.lang.NullPointerException</span>

<span class="hljs-comment">//Optional.ofNullable(T t)--允许存在空的对象，为空返回Optional.empty</span>
boy=<span class="hljs-literal">null</span>;
Optional&lt;Boy&gt; o = Optional.ofNullable(boy);
System.out.println(o);<span class="hljs-comment">//Optional.empty</span>

<span class="hljs-comment">//optional对象的isPresent()--判断optional容器中是否包含对象，返回boolean</span>


<span class="hljs-comment">//optional对象的orElse(T other)--如果为空则返回other，否则返回原本的值</span>
boy=<span class="hljs-literal">null</span>;
Optional&lt;Boy&gt; o = Optional.ofNullable(boy);
<span class="hljs-type">Boy</span> <span class="hljs-variable">boy1</span> <span class="hljs-operator">=</span> o.orElse(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Boy</span>(<span class="hljs-string">&quot;李四&quot;</span>));
System.out.println(boy1);<span class="hljs-comment">//Boy&#123;name=&#x27;李四&#x27;&#125;</span>
</code></pre></div><h3 id="JDK8新日期时间API"><a href="#JDK8新日期时间API" class="headerlink" title="JDK8新日期时间API"></a>JDK8新日期时间API</h3><blockquote><p>仅展示常用的</p></blockquote><br><h4 id="LocalDate、LocalTime、LocalDateTime"><a href="#LocalDate、LocalTime、LocalDateTime" class="headerlink" title="LocalDate、LocalTime、LocalDateTime"></a>LocalDate、LocalTime、LocalDateTime</h4><p>**静态方法(实例化)**：<code>now()</code>、<code>of()</code></p><p>获取时间：<code>getXXX()</code></p><p>设置时间：<code>setXXX()</code>，返回新的对象（体现出不可变性）</p><p>添加减去：<code>plusXXX()</code>、<code>minusXXX()</code></p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">//now() 根据当前时间创建对象</span>
<span class="hljs-type">LocalDate</span> <span class="hljs-variable">localDate</span> <span class="hljs-operator">=</span> LocalDate.now(); <span class="hljs-comment">// 获取当前日期 yyyy-MM-dd</span>
<span class="hljs-type">LocalDate</span> <span class="hljs-variable">localTime</span> <span class="hljs-operator">=</span> LocalTime.now(); <span class="hljs-comment">// 获取当前时间 HH:mm:MM.xxxxx</span>
<span class="hljs-type">LocalDate</span> <span class="hljs-variable">localDateTime</span> <span class="hljs-operator">=</span> LocalDateTime.now(); <span class="hljs-comment">// 获取当前日期和时间 yyyy-MM-dd HH:mm:MM.xxxxx</span>

<span class="hljs-comment">//of() 根据指定日期创建对象</span>
<span class="hljs-type">LocalDate</span> <span class="hljs-variable">localDate</span> <span class="hljs-operator">=</span> LocalDate.of(<span class="hljs-number">2023</span>,<span class="hljs-number">11</span>,<span class="hljs-number">22</span>); <span class="hljs-comment">// 设置日期 yyyy-MM-dd</span>
<span class="hljs-type">LocalDate</span> <span class="hljs-variable">localTime</span> <span class="hljs-operator">=</span> LocalTime.of(<span class="hljs-number">11</span>,<span class="hljs-number">02</span>,<span class="hljs-number">30</span>,<span class="hljs-number">1234</span>); <span class="hljs-comment">// 设置时间 HH:mm:MM.xxxxx</span>
<span class="hljs-type">LocalDate</span> <span class="hljs-variable">localDateTime</span> <span class="hljs-operator">=</span> LocalDateTime.of(); <span class="hljs-comment">// 设置日期和时间 yyyy-MM-dd HH:mm:MM.xxxxx</span>
</code></pre></div><h3 id="Instant"><a href="#Instant" class="headerlink" title="Instant"></a>Instant</h3><blockquote><p>瞬时，类似Date</p></blockquote><p>实例化：<code>now()</code>，<code>ofEpochMilli()</code></p><p><code>toEpochMilli()</code>：获取当前的毫秒数（时间戳）</p><br><h3 id="DateTimeFormatter"><a href="#DateTimeFormatter" class="headerlink" title="DateTimeFormatter"></a>DateTimeFormatter</h3><blockquote><p>日期时间格式化</p></blockquote><p>静态方法：<code>ofPattern()</code>返回一个指定字符格式的<code>DateTimeFormatter</code></p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">//自定义格式</span>
<span class="hljs-type">DateTimeFormatter</span> <span class="hljs-variable">dateTimeFormatter</span> <span class="hljs-operator">=</span> DateTimeFormatter.ofPattern(<span class="hljs-string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);

<span class="hljs-comment">//将日期转换为自定义格式字符串</span>
<span class="hljs-type">LocalDateTime</span> <span class="hljs-variable">localDateTime</span> <span class="hljs-operator">=</span> LocalDateTime.now();
<span class="hljs-type">String</span> <span class="hljs-variable">strDateTime</span> <span class="hljs-operator">=</span> dateTimeFormatter.format(localDateTime); <span class="hljs-comment">//2023-11-22 15:23:42</span>

<span class="hljs-comment">//将字符串转换为日期</span>
<span class="hljs-type">TemporalAccessor</span> <span class="hljs-variable">temporalAccessor</span> <span class="hljs-operator">=</span> dateTimeFormatter.parse(<span class="hljs-string">&quot;2023-11-22 15:23:42&quot;</span>); <span class="hljs-comment">//TemporalAccessor是一个接口，已被日期等实现</span>
<span class="hljs-type">LocalDateTime</span> <span class="hljs-variable">localDateTime</span> <span class="hljs-operator">=</span> LocalDateTime.from(temporalAccessor);  <span class="hljs-comment">//将TemporalAccessor转换为LocalDateTime，2023-11-22T15:23:42</span></code></pre></div></div><hr><div><div class="post-metas my-3"><div class="post-meta mr-3 d-flex align-items-center"><i class="iconfont icon-category"></i> <span class="category-chains"><span class="category-chain"><a href="/categories/%E5%AD%A6%E4%B9%A0/" class="category-chain-item">学习</a> <span>></span> <a href="/categories/%E5%AD%A6%E4%B9%A0/%E7%AC%94%E8%AE%B0/" class="category-chain-item">笔记</a></span></span></div><div class="post-meta"><i class="iconfont icon-tags"></i> <a href="/tags/java/" class="print-no-link">#java</a></div></div><div class="post-prevnext my-3"><article class="post-prev col-6"><a href="/2023/07/07/Mysql%E5%9F%BA%E7%A1%80/" title="Mysql基础"><i class="iconfont icon-arrowleft"></i> <span class="hidden-mobile">Mysql基础</span> <span class="visible-mobile">上一篇</span></a></article><article class="post-next col-6"><a href="/2023/03/27/%E4%B9%89%E6%97%A0%E5%8F%8D%E9%A1%BE%E7%9A%84%E9%9D%92%E6%98%A5%E9%87%8C-%E7%88%B1%E6%83%85%E4%B8%8D%E8%BF%87%E6%98%AF%E5%AF%A5%E5%AF%A5%E5%87%A0%E7%AC%94/" title="义无反顾的青春里 爱情不过是寥寥几笔"><span class="hidden-mobile">义无反顾的青春里 爱情不过是寥寥几笔</span> <span class="visible-mobile">下一篇</span> <i class="iconfont icon-arrowright"></i></a></article></div></div><article id="comments" lazyload><div id="valine"></div><script type="text/javascript">Fluid.utils.loadComments("#valine",(function(){Fluid.utils.createScript("https://lib.baomitu.com/valine/1.5.1/Valine.min.js",(function(){var i=Object.assign({appId:"pAMB2w8iZ0dGgDjqXTDPwmSN-gzGzoHsz",appKey:"wGSfk5DAXSATlDCQopSwETpU",path:"window.location.pathname",placeholder:null,avatar:"retro",meta:["nick","mail","link"],requiredFields:[],pageSize:10,lang:"zh-CN",highlight:!1,recordIP:!1,serverURLs:"",emojiCDN:null,emojiMaps:null,enableQQ:!1},{el:"#valine",path:window.location.pathname});new Valine(i),Fluid.utils.waitElementVisible("#valine .vcontent",()=>{var i="#valine .vcontent img:not(.vemoji)";Fluid.plugins.imageCaption(i),Fluid.plugins.fancyBox(i)})}))}))</script><noscript>Please enable JavaScript to view the comments</noscript></article></article></div></div></div><div class="side-col d-none d-lg-block col-lg-2"><aside class="sidebar" style="margin-left:-1rem"><div id="toc"><p class="toc-header"><i class="iconfont icon-list"></i> <span>目录</span></p><div class="toc-body" id="toc-body"></div></div></aside></div></div></div><a id="scroll-top-button" aria-label="TOP" href="#" role="button"><i class="iconfont icon-arrowup" aria-hidden="true"></i></a><div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel" aria-hidden="true"><div class="modal-dialog modal-dialog-scrollable modal-lg" role="document"><div class="modal-content"><div class="modal-header text-center"><h4 class="modal-title w-100 font-weight-bold">搜索</h4><button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">&times;</span></button></div><div class="modal-body mx-3"><div class="md-form mb-5"><input type="text" id="local-search-input" class="form-control validate"> <label data-error="x" data-success="v" for="local-search-input">关键词</label></div><div class="list-group" id="local-search-result"></div></div></div></div></div></main><footer><div class="footer-inner"><div class="footer-content"><a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a></div><div class="statistics"><span id="busuanzi_container_site_pv" style="display:none">总访问量 <span id="busuanzi_value_site_pv"></span> 次 </span><span id="busuanzi_container_site_uv" style="display:none">总访客数 <span id="busuanzi_value_site_uv"></span> 人</span></div></div></footer><script src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js"></script><link rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css"><script>NProgress.configure({showSpinner:!1,trickleSpeed:100}),NProgress.start(),window.addEventListener("load",(function(){NProgress.done()}))</script><script src="https://lib.baomitu.com/jquery/3.6.4/jquery.min.js"></script><script src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js"></script><script src="/js/events.js"></script><script src="/js/plugins.js"></script><script src="/js/img-lazyload.js"></script><script>Fluid.utils.createScript("https://lib.baomitu.com/tocbot/4.20.1/tocbot.min.js",(function(){var t=jQuery("#toc");if(0!==t.length&&window.tocbot){var i=jQuery("#board-ctn").offset().top;window.tocbot.init(Object.assign({tocSelector:"#toc-body",contentSelector:".markdown-body",linkClass:"tocbot-link",activeLinkClass:"tocbot-active-link",listClass:"tocbot-list",isCollapsedClass:"tocbot-is-collapsed",collapsibleClass:"tocbot-is-collapsible",scrollSmooth:!0,includeTitleTags:!0,headingsOffset:-i},CONFIG.toc)),t.find(".toc-list-item").length>0&&t.css("visibility","visible"),Fluid.events.registerRefreshCallback((function(){if("tocbot"in window){tocbot.refresh();var t=jQuery("#toc");if(0===t.length||!tocbot)return;t.find(".toc-list-item").length>0&&t.css("visibility","visible")}}))}}))</script><script src="https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js"></script><script>Fluid.plugins.codeWidget()</script><script>Fluid.utils.createScript("https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js",(function(){window.anchors.options={placement:CONFIG.anchorjs.placement,visible:CONFIG.anchorjs.visible},CONFIG.anchorjs.icon&&(window.anchors.options.icon=CONFIG.anchorjs.icon);var n=(CONFIG.anchorjs.element||"h1,h2,h3,h4,h5,h6").split(","),o=[];for(var s of n)o.push(".markdown-body > "+s.trim());"left"===CONFIG.anchorjs.placement&&(window.anchors.options.class="anchorjs-link-left"),window.anchors.add(o.join(", ")),Fluid.events.registerRefreshCallback((function(){if("anchors"in window){anchors.removeAll();var n=(CONFIG.anchorjs.element||"h1,h2,h3,h4,h5,h6").split(","),o=[];for(var s of n)o.push(".markdown-body > "+s.trim());"left"===CONFIG.anchorjs.placement&&(anchors.options.class="anchorjs-link-left"),anchors.add(o.join(", "))}}))}))</script><script>Fluid.utils.createScript("https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js",(function(){Fluid.plugins.fancyBox()}))</script><script>Fluid.plugins.imageCaption()</script><script src="/js/local-search.js"></script><script defer src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="/js/boot.js"></script><noscript><div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div></noscript></body></html>