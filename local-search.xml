<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>JDK7与JDK8-HashMap源码刨析~</title>
    <link href="/2024/03/10/JDK7%E4%B8%8EJDK8-HashMap%E6%BA%90%E7%A0%81%E5%88%A8%E6%9E%90/"/>
    <url>/2024/03/10/JDK7%E4%B8%8EJDK8-HashMap%E6%BA%90%E7%A0%81%E5%88%A8%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<h1 id="JDK8与JDK7的主要区别："><a href="#JDK8与JDK7的主要区别：" class="headerlink" title="JDK8与JDK7的主要区别："></a>JDK8与JDK7的主要区别：</h1><ol><li><strong>延长数组初始化操作。</strong>在jdk8中，当创建实例以后，底层并没有初始化table数组。当首次添加（key，value）时进行判断，如果发现table尚未初始化，则对数组进行初始化。</li><li><strong>底层创建的数组为<code>Node[]</code>。</strong>在jdk8中，HashMap底层定义了<code>Node</code>内部类，替换了jdk7张的<code>Entry</code>内部类，因此创建的数组是<code>Node[]</code>。</li><li><strong>在数组上添加新元素为尾插法。</strong>在jdk8中，如果当前的（key，value）经过一系列判断之后可以添加当前的数组索引<code>i</code>中，如果此时<code>i</code>处有元素，则将旧元素指向新元素。而jdk7中则为新元素指向旧元素，为头插法。“七上八下”。</li><li><strong>底层结构为：数组+单向链表+红黑树。</strong>jdk7中为：数组+单向链表。（数组索引<code>i</code>位置上的元素个数达到8，并且数组长度达到64才会转成红黑树；数组索引<code>i</code>位置上的元素个数低于6的时候，红黑树会退化为单向链表结构）br.</li></ol><br/><h1 id="JDK7中源码"><a href="#JDK7中源码" class="headerlink" title="JDK7中源码"></a>JDK7中源码</h1><blockquote><p>基于jdk1.7.0_07</p></blockquote><h2 id="1-实例化过程"><a href="#1-实例化过程" class="headerlink" title="1.实例化过程"></a>1.实例化过程</h2><p>基本属性与常量：</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">DEFAULT_INITIAL_CAPACITY</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">4</span>; <span class="hljs-comment">// 初始容量，16。</span><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">float</span> <span class="hljs-variable">DEFAULT_LOAD_FACTOR</span> <span class="hljs-operator">=</span> <span class="hljs-number">0.75f</span>;<span class="hljs-comment">//加载因子，默认为0.75</span><span class="hljs-keyword">transient</span> Entry&lt;K,V&gt;[] table; <span class="hljs-comment">//存储数组的数组</span><span class="hljs-type">int</span> threshold; <span class="hljs-comment">// 临界值</span></code></pre></div><p>方法：</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-title function_">HashMap</span><span class="hljs-params">()</span> &#123;    <span class="hljs-built_in">this</span>(DEFAULT_INITIAL_CAPACITY, DEFAULT_LOAD_FACTOR);&#125;<span class="hljs-keyword">public</span> <span class="hljs-title function_">HashMap</span><span class="hljs-params">(<span class="hljs-type">int</span> initialCapacity, <span class="hljs-type">float</span> loadFactor)</span> &#123;    <span class="hljs-comment">//***略***</span>        <span class="hljs-comment">// Find a power of 2 &gt;= initialCapacity</span>    <span class="hljs-comment">//通过此循环得到capacity的最终值，此值决定了Entry数组的长度。此时的capacity一定是2的整数倍</span>    <span class="hljs-type">int</span> <span class="hljs-variable">capacity</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;    <span class="hljs-keyword">while</span> (capacity &lt; initialCapacity)      capacity &lt;&lt;= <span class="hljs-number">1</span>;          <span class="hljs-built_in">this</span>.loadFactor = loadFactor;<span class="hljs-comment">//确定加载因子</span>    threshold = (<span class="hljs-type">int</span>)Math.min(capacity * loadFactor, MAXIMUM_CAPACITY + <span class="hljs-number">1</span>);<span class="hljs-comment">//确定了临界值</span>    table = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Entry</span>[capacity];<span class="hljs-comment">//初始化数组 长度为16</span>        <span class="hljs-comment">//***略***</span>&#125;</code></pre></div><h2 id="2-put-key-value-的过程"><a href="#2-put-key-value-的过程" class="headerlink" title="2.put(key,value)的过程"></a>2.put(key,value)的过程</h2><p>主要方法：</p><div class="code-wrapper"><pre><code class="hljs java"> <span class="hljs-keyword">public</span> V <span class="hljs-title function_">put</span><span class="hljs-params">(K key, V value)</span> &#123;   <span class="hljs-comment">//如果添加的key为null,将此（key，value）放到数组头部。</span>    <span class="hljs-keyword">if</span> (key == <span class="hljs-literal">null</span>)        <span class="hljs-keyword">return</span> putForNullKey(value);    <span class="hljs-comment">//将key传入hash方法，内部使用了key的hash1，此方法返回hash2</span>    <span class="hljs-type">int</span> <span class="hljs-variable">hash</span> <span class="hljs-operator">=</span> hash(key);    <span class="hljs-comment">//通过与运算符确认出在数组存放的位置i</span>    <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> indexFor(hash, table.length);        <span class="hljs-keyword">for</span> (Entry&lt;K,V&gt; e = table[i]; e != <span class="hljs-literal">null</span>; e = e.next) &#123;        Object k;        <span class="hljs-keyword">if</span> (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) &#123;<span class="hljs-comment">//key存在且相等</span>            <span class="hljs-type">V</span> <span class="hljs-variable">oldValue</span> <span class="hljs-operator">=</span> e.value;            e.value = value;            e.recordAccess(<span class="hljs-built_in">this</span>);            <span class="hljs-keyword">return</span> oldValue;<span class="hljs-comment">//修改时，返回旧value</span>        &#125;    &#125;        <span class="hljs-comment">//***略***</span>    addEntry(hash, key, value, i);<span class="hljs-comment">//将（key，value）封装成一个Entry对象，并将此对象保存在索引i的位置</span>    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;&#125;</code></pre></div><p>方法：</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">//hash算法</span><span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-title function_">hash</span><span class="hljs-params">(Object k)</span> &#123;    <span class="hljs-type">int</span> <span class="hljs-variable">h</span> <span class="hljs-operator">=</span> hashSeed;    <span class="hljs-keyword">if</span> (<span class="hljs-number">0</span> != h &amp;&amp; k <span class="hljs-keyword">instanceof</span> String) &#123;        <span class="hljs-keyword">return</span> sun.misc.Hashing.stringHash32((String) k);    &#125;    h ^= k.hashCode();    <span class="hljs-comment">// This function ensures that hashCodes that differ only by</span>    <span class="hljs-comment">// constant multiples at each bit position have a bounded</span>    <span class="hljs-comment">// number of collisions (approximately 8 at default load factor).</span>    h ^= (h &gt;&gt;&gt; <span class="hljs-number">20</span>) ^ (h &gt;&gt;&gt; <span class="hljs-number">12</span>);    <span class="hljs-keyword">return</span> h ^ (h &gt;&gt;&gt; <span class="hljs-number">7</span>) ^ (h &gt;&gt;&gt; <span class="hljs-number">4</span>);&#125;<span class="hljs-comment">//indexFor算法</span><span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">indexFor</span><span class="hljs-params">(<span class="hljs-type">int</span> h, <span class="hljs-type">int</span> length)</span> &#123;    <span class="hljs-comment">// assert Integer.bitCount(length) == 1 : &quot;length must be a non-zero power of 2&quot;;</span>    <span class="hljs-keyword">return</span> h &amp; (length-<span class="hljs-number">1</span>);<span class="hljs-comment">//位运算符与，比%快。</span>&#125;<span class="hljs-comment">//添加（key，value）</span><span class="hljs-keyword">void</span> <span class="hljs-title function_">addEntry</span><span class="hljs-params">(<span class="hljs-type">int</span> hash, K key, V value, <span class="hljs-type">int</span> bucketIndex)</span> &#123;    <span class="hljs-comment">//扩容条件</span>    <span class="hljs-keyword">if</span> ((size &gt;= threshold) &amp;&amp; (<span class="hljs-literal">null</span> != table[bucketIndex])) &#123;        resize(<span class="hljs-number">2</span> * table.length);<span class="hljs-comment">//默认两倍扩容</span>        hash = (<span class="hljs-literal">null</span> != key) ? hash(key) : <span class="hljs-number">0</span>;<span class="hljs-comment">//扩容后会重新计算hash2</span>        bucketIndex = indexFor(hash, table.length);    &#125;    createEntry(hash, key, value, bucketIndex);&#125;<span class="hljs-comment">//</span><span class="hljs-keyword">void</span> <span class="hljs-title function_">createEntry</span><span class="hljs-params">(<span class="hljs-type">int</span> hash, K key, V value, <span class="hljs-type">int</span> bucketIndex)</span> &#123;    Entry&lt;K,V&gt; e = table[bucketIndex];<span class="hljs-comment">//当前元素</span>    table[bucketIndex] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Entry</span>&lt;&gt;(hash, key, value, e);<span class="hljs-comment">//新元素的next指向当前元素，即新元素放首位，其余向后移</span>    size++;&#125;</code></pre></div><h2 id="3-Entry的定义结构"><a href="#3-Entry的定义结构" class="headerlink" title="3.Entry的定义结构"></a>3.Entry的定义结构</h2><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Entry</span>&lt;K,V&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Map</span>.Entry&lt;K,V&gt; &#123;    <span class="hljs-keyword">final</span> K key;    V value;    Entry&lt;K,V&gt; next;    <span class="hljs-type">int</span> hash; <span class="hljs-comment">//此处为key的hash2</span>    <span class="hljs-comment">/**</span><span class="hljs-comment">     * Creates new entry.</span><span class="hljs-comment">     */</span>    Entry(<span class="hljs-type">int</span> h, K k, V v, Entry&lt;K,V&gt; n) &#123;        value = v;        next = n;        key = k;        hash = h;    &#125;&#125;</code></pre></div><br/><h1 id="JDK8中源码"><a href="#JDK8中源码" class="headerlink" title="JDK8中源码"></a>JDK8中源码</h1><h2 id="1-实例化过程-1"><a href="#1-实例化过程-1" class="headerlink" title="1.实例化过程"></a>1.实例化过程</h2><p>基本属性与常量：</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">final</span> <span class="hljs-type">float</span> loadFactor;<span class="hljs-comment">//加载因子</span><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">float</span> <span class="hljs-variable">DEFAULT_LOAD_FACTOR</span> <span class="hljs-operator">=</span> <span class="hljs-number">0.75f</span><span class="hljs-comment">//默认常量，加载因子</span><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">TREEIFY_THRESHOLD</span> <span class="hljs-operator">=</span> <span class="hljs-number">8</span>;<span class="hljs-comment">//默认树化阈值8</span><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">UNTREEIFY_THRESHOLD</span> <span class="hljs-operator">=</span> <span class="hljs-number">6</span>;<span class="hljs-comment">//默认反树化阈值6</span></code></pre></div><p>方法：</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-title function_">HashMap</span><span class="hljs-params">(<span class="hljs-type">int</span> initialCapacity)</span> &#123;    <span class="hljs-built_in">this</span>.loadFactor = DEFAULT_LOAD_FACTOR;<span class="hljs-comment">//构造器只初始化加载因子</span>&#125;</code></pre></div><h2 id="2-put（key，value）过程"><a href="#2-put（key，value）过程" class="headerlink" title="2.put（key，value）过程"></a>2.put（key，value）过程</h2><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> V <span class="hljs-title function_">put</span><span class="hljs-params">(K key, V value)</span> &#123;    <span class="hljs-keyword">return</span> putVal(hash(key), key, value, <span class="hljs-literal">false</span>, <span class="hljs-literal">true</span>);&#125;<span class="hljs-keyword">final</span> V <span class="hljs-title function_">putVal</span><span class="hljs-params">(<span class="hljs-type">int</span> hash, K key, V value, <span class="hljs-type">boolean</span> onlyIfAbsent,<span class="hljs-type">boolean</span> evict)</span> &#123;    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="hljs-type">int</span> n, i;<span class="hljs-comment">//tab = 数组，n = 数组长度，i = 当前元素需要放在数组中的位置， p = 该数组位置下的链表</span>    <span class="hljs-comment">//首次创建时tab为null</span>    <span class="hljs-keyword">if</span> ((tab = table) == <span class="hljs-literal">null</span> || (n = tab.length) == <span class="hljs-number">0</span>)        n = (tab = resize()).length;<span class="hljs-comment">//新数组给tab</span>    <span class="hljs-comment">//判断该数的hash2（jdk7中indexFor()方法），确定存放在数组中的位置且该位置上是否有元素</span>    <span class="hljs-keyword">if</span> ((p = tab[i = (n - <span class="hljs-number">1</span>) &amp; hash]) == <span class="hljs-literal">null</span>)  <span class="hljs-comment">//该数组位置没有元素时 -&gt; 直接添加</span>        tab[i] = newNode(hash, key, value, <span class="hljs-literal">null</span>);    <span class="hljs-keyword">else</span> &#123;  <span class="hljs-comment">//该位置上有元素时</span>        Node&lt;K,V&gt; e; K k;   <span class="hljs-comment">// k = 旧元素的key，e = 临时变量</span>        <span class="hljs-comment">//判断新元素与链表中第一个数的key是否相同</span>        <span class="hljs-keyword">if</span> (p.hash == hash &amp;&amp;             ((k = p.key) == key || (key != <span class="hljs-literal">null</span> &amp;&amp; key.equals(k))))            e = p;          <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (p <span class="hljs-keyword">instanceof</span> TreeNode)  <span class="hljs-comment">//判断是否为树状结构</span>            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="hljs-built_in">this</span>, tab, hash, key, value);        <span class="hljs-keyword">else</span> &#123;   <span class="hljs-comment">//不相同情况</span>            <span class="hljs-comment">//遍历链表 -&gt; 在尾部添加新元素||找到key相同的元素，时结束循环。</span>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">binCount</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; ; ++binCount) &#123;                <span class="hljs-comment">//表尾情况</span>                <span class="hljs-keyword">if</span> ((e = p.next) == <span class="hljs-literal">null</span>) &#123;                    p.next = newNode(hash, key, value, <span class="hljs-literal">null</span>);                    <span class="hljs-comment">//判断是否树化</span>                    <span class="hljs-keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="hljs-number">1</span>) <span class="hljs-comment">// -1 for 1st</span>                        treeifyBin(tab, hash);                    <span class="hljs-keyword">break</span>;                &#125;                <span class="hljs-comment">//判断key是否相同 -&gt;相同则退出循环，目的：将e（与待添加元素的key相同）找出并交给后续处理。</span>                <span class="hljs-keyword">if</span> (e.hash == hash &amp;&amp;                    ((k = e.key) == key || (key != <span class="hljs-literal">null</span> &amp;&amp; key.equals(k))))                    <span class="hljs-keyword">break</span>;                p = e;<span class="hljs-comment">// 相当于指针下移</span>            &#125;        &#125;        <span class="hljs-comment">// 存在相同的key，替换value</span>        <span class="hljs-keyword">if</span> (e != <span class="hljs-literal">null</span>) &#123; <span class="hljs-comment">// existing mapping for key</span>            <span class="hljs-type">V</span> <span class="hljs-variable">oldValue</span> <span class="hljs-operator">=</span> e.value;            <span class="hljs-keyword">if</span> (!onlyIfAbsent || oldValue == <span class="hljs-literal">null</span>)                e.value = value;            afterNodeAccess(e);            <span class="hljs-keyword">return</span> oldValue;        &#125;    &#125;        <span class="hljs-comment">//***略***</span>        <span class="hljs-comment">//判断是否需要扩容</span>    <span class="hljs-keyword">if</span> (++size &gt; threshold)        resize();    afterNodeInsertion(evict);    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;&#125;<span class="hljs-comment">/**</span><span class="hljs-comment"> * 数组的初始化，扩容</span><span class="hljs-comment"> **/</span><span class="hljs-keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;    Node&lt;K,V&gt;[] oldTab = table;    <span class="hljs-type">int</span> <span class="hljs-variable">oldCap</span> <span class="hljs-operator">=</span> (oldTab == <span class="hljs-literal">null</span>) ? <span class="hljs-number">0</span> : oldTab.length;    <span class="hljs-type">int</span> <span class="hljs-variable">oldThr</span> <span class="hljs-operator">=</span> threshold;    <span class="hljs-type">int</span> newCap, newThr = <span class="hljs-number">0</span>;    <span class="hljs-keyword">if</span> (oldCap &gt; <span class="hljs-number">0</span>) &#123;        <span class="hljs-keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;            threshold = Integer.MAX_VALUE;            <span class="hljs-keyword">return</span> oldTab;        &#125;        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="hljs-number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;                 oldCap &gt;= DEFAULT_INITIAL_CAPACITY)            newThr = oldThr &lt;&lt; <span class="hljs-number">1</span>; <span class="hljs-comment">// double threshold</span>    &#125;    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (oldThr &gt; <span class="hljs-number">0</span>) <span class="hljs-comment">// initial capacity was placed in threshold</span>        newCap = oldThr;    <span class="hljs-keyword">else</span> &#123;               <span class="hljs-comment">// 初始化默认长度</span>        newCap = DEFAULT_INITIAL_CAPACITY;  <span class="hljs-comment">//数组初始长度(16)</span>        newThr = (<span class="hljs-type">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY); <span class="hljs-comment">//临界值(12)</span>    &#125;    <span class="hljs-keyword">if</span> (newThr == <span class="hljs-number">0</span>) &#123;        <span class="hljs-type">float</span> <span class="hljs-variable">ft</span> <span class="hljs-operator">=</span> (<span class="hljs-type">float</span>)newCap * loadFactor;        newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="hljs-type">float</span>)MAXIMUM_CAPACITY ?                  (<span class="hljs-type">int</span>)ft : Integer.MAX_VALUE);    &#125;    threshold = newThr; <span class="hljs-comment">//确认临界值</span>    Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>[newCap];<span class="hljs-comment">//确认数组</span>    table = newTab;    <span class="hljs-keyword">if</span> (oldTab != <span class="hljs-literal">null</span>) &#123;        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; oldCap; ++j) &#123;            Node&lt;K,V&gt; e;            <span class="hljs-keyword">if</span> ((e = oldTab[j]) != <span class="hljs-literal">null</span>) &#123;                oldTab[j] = <span class="hljs-literal">null</span>;                <span class="hljs-keyword">if</span> (e.next == <span class="hljs-literal">null</span>)                    newTab[e.hash &amp; (newCap - <span class="hljs-number">1</span>)] = e;                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (e <span class="hljs-keyword">instanceof</span> TreeNode)                    ((TreeNode&lt;K,V&gt;)e).split(<span class="hljs-built_in">this</span>, newTab, j, oldCap);                <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">// preserve order</span>                    Node&lt;K,V&gt; loHead = <span class="hljs-literal">null</span>, loTail = <span class="hljs-literal">null</span>;                    Node&lt;K,V&gt; hiHead = <span class="hljs-literal">null</span>, hiTail = <span class="hljs-literal">null</span>;                    Node&lt;K,V&gt; next;                    <span class="hljs-keyword">do</span> &#123;                        next = e.next;                        <span class="hljs-keyword">if</span> ((e.hash &amp; oldCap) == <span class="hljs-number">0</span>) &#123;                            <span class="hljs-keyword">if</span> (loTail == <span class="hljs-literal">null</span>)                                loHead = e;                            <span class="hljs-keyword">else</span>                                loTail.next = e;                            loTail = e;                        &#125;                        <span class="hljs-keyword">else</span> &#123;                            <span class="hljs-keyword">if</span> (hiTail == <span class="hljs-literal">null</span>)                                hiHead = e;                            <span class="hljs-keyword">else</span>                                hiTail.next = e;                            hiTail = e;                        &#125;                    &#125; <span class="hljs-keyword">while</span> ((e = next) != <span class="hljs-literal">null</span>);                    <span class="hljs-keyword">if</span> (loTail != <span class="hljs-literal">null</span>) &#123;                        loTail.next = <span class="hljs-literal">null</span>;                        newTab[j] = loHead;                    &#125;                    <span class="hljs-keyword">if</span> (hiTail != <span class="hljs-literal">null</span>) &#123;                        hiTail.next = <span class="hljs-literal">null</span>;                        newTab[j + oldCap] = hiHead;                    &#125;                &#125;            &#125;        &#125;    &#125;    <span class="hljs-keyword">return</span> newTab;&#125;<span class="hljs-comment">/**</span><span class="hljs-comment"> * 哈希算法，确认hash1</span><span class="hljs-comment"> **/</span><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-title function_">hash</span><span class="hljs-params">(Object key)</span> &#123;    <span class="hljs-type">int</span> h;    <span class="hljs-keyword">return</span> (key == <span class="hljs-literal">null</span>) ? <span class="hljs-number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="hljs-number">16</span>);<span class="hljs-comment">//null的情况默认放首位</span>&#125;</code></pre></div><br/><br/><h2 id="3-Node的定义结构"><a href="#3-Node的定义结构" class="headerlink" title="3.Node的定义结构"></a>3.Node的定义结构</h2><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Node</span>&lt;K,V&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Map</span>.Entry&lt;K,V&gt; &#123;    <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> hash;    <span class="hljs-keyword">final</span> K key;    V value;    Node&lt;K,V&gt; next;    Node(<span class="hljs-type">int</span> hash, K key, V value, Node&lt;K,V&gt; next) &#123;        <span class="hljs-built_in">this</span>.hash = hash;        <span class="hljs-built_in">this</span>.key = key;        <span class="hljs-built_in">this</span>.value = value;        <span class="hljs-built_in">this</span>.next = next;    &#125;&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>学习</category>
      
      <category>源码</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>多用户即时通讯系统</title>
    <link href="/2024/03/10/%E5%A4%9A%E7%94%A8%E6%88%B7%E5%8D%B3%E6%97%B6%E9%80%9A%E8%AE%AF%E7%B3%BB%E7%BB%9F/"/>
    <url>/2024/03/10/%E5%A4%9A%E7%94%A8%E6%88%B7%E5%8D%B3%E6%97%B6%E9%80%9A%E8%AE%AF%E7%B3%BB%E7%BB%9F/</url>
    
    <content type="html"><![CDATA[<blockquote><p>老项目，待更新or抛弃</p></blockquote><ul><li>利用HashMap模拟数据库，储存用户数据</li><li>涉及io流，多线程，网络编程等技术</li><li>服务端与客户端分离</li><li>项目框架设计</li></ul><br/><h1 id="1-需求分析"><a href="#1-需求分析" class="headerlink" title="1.需求分析"></a>1.需求分析</h1><ol><li>用户登录</li><li>拉取用户在线列表</li><li>无异常推出客户端，服务端</li><li>私聊消息（包括离线）</li><li>群发消息（包括离线）</li></ol><br/><h1 id="2-整体思路与刨析"><a href="#2-整体思路与刨析" class="headerlink" title="2.整体思路与刨析"></a>2.整体思路与刨析</h1><ul><li>客户端与服务端通过Message对象双向传输，其中MessagesType区别业务逻辑</li><li>一个用户单独占有一条独立的线程</li><li>利用集合对多个线程进行管理</li><li>使用对象流作为传输工具</li></ul><br/><p><img src="/../img/%E5%A4%9A%E7%94%A8%E6%88%B7%E5%8D%B3%E6%97%B6%E9%80%9A%E8%AE%AF%E7%B3%BB%E7%BB%9F/b373bc7ba3f99ac4350433709637bc4f.png"></p><br/><h1 id="3-功能实现"><a href="#3-功能实现" class="headerlink" title="3.功能实现"></a>3.功能实现</h1><blockquote><p>在框架设计搭建起来之后，后续很多操作都很容易实现，无非就是根据MessageType的类型作用不同的业务逻辑</p><p>User.java：用户类。除了账号密码，还有一个用于接受来自其他人发的群发消息的Message集合</p><p>Message.java：消息类。拥有发送者，接收者，内容，发送时间，消息类型</p><p>MessageType.java：消息类型类。存放的是变量，用于区别消息的类型，包括登陆，消息内容，退出等</p><p>Thread_XX.java：线程类。是客户端与服务器通讯的线程，掌握有socket，同时对服务器（客户端）发送（接收）消息</p></blockquote><br/><h2 id="3-1用户登录"><a href="#3-1用户登录" class="headerlink" title="3.1用户登录"></a>3.1用户登录</h2><blockquote><p>用户名和密码是已经在服务端写好的死数据</p><p>QQView.java：展示界面的地方，也是用户第一面</p><p>UserClientService.java：客户端处理业务逻辑的地方，包括连接服务器，验证登录，起线程等</p></blockquote><p><strong>客户端</strong></p><ol><li>新建一个user，将用户输入的账号和密码通过socket传入服务端</li><li>根据MessageType判断登录是否成功</li><li>登录成功则单独起一个线程并存入集合，重复循环等待来自服务端的消息</li></ol><p><strong>服务端</strong></p><ol><li>判断从服务端传来的数据，将结果打包成Message返回</li><li>起线程，存入集合，同服务端同步保持通讯</li></ol><br/><h2 id="3-2拉取用户在线列表"><a href="#3-2拉取用户在线列表" class="headerlink" title="3.2拉取用户在线列表"></a>3.2拉取用户在线列表</h2><blockquote><p>在线用户在服务端的线程管理集合中有对应的线程，可以根据这点获取在线用户</p><p>QQQService.java：服务端处理业务逻辑的地方，包括数据的初始化，监听端口起线程等</p></blockquote><p><strong>客户端</strong></p><ol><li>新建Message，设置Type，向服务器请求</li><li>拿到数据后spil（）方法解析字符串得到在线用户列表</li></ol><p><strong>服务端</strong></p><ol><li>用户线程中，收到来自客户端的请求后遍历线程集合取得userId</li><li>将结果拼接得到字符串后new Message，设置type，发送给客户端</li></ol><br/><h2 id="3-3无异常退出"><a href="#3-3无异常退出" class="headerlink" title="3.3无异常退出"></a>3.3无异常退出</h2><blockquote><p>java的主线程结束，并不会结束其他的线程</p><p>安全退出方式有很多种，此处采用的是走完所有线程的方式自然退出</p></blockquote><p><strong>客户端</strong></p><ol><li>new Message，设置type，发送消息，结束循环</li></ol><p><strong>服务端</strong></p><ol><li>收到消息，线程集合中remove本条，结束循环</li></ol><br/><h2 id="3-4私聊"><a href="#3-4私聊" class="headerlink" title="3.4私聊"></a>3.4私聊</h2><blockquote><p>难点在于实现离线消息</p><p>对方离线的情况下只能将数据保存在服务端，同时需要考虑多个用户发送多条留言的情况</p><p>利用<code>ConcurrentHashMap&lt;String, ArrayList&lt;Message&gt;&gt;</code>存放所有的离线消息<code>k = getter</code>, <code>v = Message</code></p><p>在此处因为数组集合是引用变量而不是值传递且数据公共踩很多坑</p><p>用户上线后则展示一遍留言，默认代表用户已读且处理，下次登陆不会展示之前的留言，下群发消息同样如此，暂时没做聊天记录</p></blockquote><p><strong>客户端</strong></p><ol><li><p>发送or收到</p><p>发送：newMes，设置sender，getter，time，type，打包发送给服务端。</p><p>收到：在线的情况下直接在线程中get</p></li></ol><p><strong>服务端</strong></p><ol><li><p>收到来自客户端的mes后判断getter是否在线</p><p>根据线程集合中判断来自客户端中的mes是否含有getter，拥有则在线，服务器直接转发来自客户端的mes</p></li><li><p>getter不在线的情况</p><p>首先在服务端创建<code>ConcurrentHashMap&lt;String, ArrayList&lt;Message&gt;&gt;</code>集合存放所有的离线消息 ，其中<code>k = getter</code> , <code>v = ArrayList&lt;Message&gt;</code>，它是一个static公共变量，因此必须依靠k，来进行增删改查。</p><p>sender这边来讲，可以将消息抛给服务器的集合中暂存。每个getter应该有相同的ArrayList，可以根据集合中是否有getter来选择是new ArrayList还是直接put。不可将所有的mes都存入一个ArrayList。</p><p>getter在上线起线程后，对离线消息进行处理、重发给客户端，处理好之后删除在集合中的记录。</p><br/></li></ol><h2 id="3-5群发"><a href="#3-5群发" class="headerlink" title="3.5群发"></a>3.5群发</h2><blockquote><p>个人认为难点在于在哪储存这个离线的群发讯息。</p><p>一开始想把它放入服务器的公共集合中，根据k&#x3D;“GROUP”来区别于私聊消息，但是后面发现不知用户如何对群发消息的已读做判断</p><p>不同用户对同一个mes有不同的处理方法，不应该吧mes放在同一个公共变量池，或者说不应该因为一个用户对这个公共变量池进行改动从而影响其他用用户</p><p>因此我把群发消息的储存写在了user对象里面，每个user有属于自己的mes，用ArrayList进行保存</p><p>此处同样因为集合的不恰当copy和操作埋了好多坑</p></blockquote><p><strong>客户端</strong></p><ol><li><p>发送or收到</p><p>发送：newMes，设置sender，getter，time，type，打包发送给服务端。</p><p>收到：在线的情况下直接在线程中get</p></li></ol><p><strong>服务端</strong></p><ol><li><p>找出所有在线的用户</p><p>思路类似列出在线客户功能，在线则直接转发</p></li><li><p>对于不在线的用户</p><p>将mes交给user的集合储存，下次登陆查询是否有消息。传递展示后清除</p></li></ol><br/><h1 id="4-源码"><a href="#4-源码" class="headerlink" title="4.源码"></a>4.源码</h1>]]></content>
    
    
    <categories>
      
      <category>学习</category>
      
      <category>项目</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>学习日志</title>
    <link href="/2024/03/04/%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%BF%97/"/>
    <url>/2024/03/04/%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%BF%97/</url>
    
    <content type="html"><![CDATA[<h2 id="2024-3-4-星期一"><a href="#2024-3-4-星期一" class="headerlink" title="2024.3.4-星期一"></a>2024.3.4-星期一</h2><p>落实学习的第一天。</p><br/><p>上午看了看行业内的几篇文章，提升一下学习的动力和兴趣。其中印象深刻的是一篇名为《最新 955 不加班的公司名单，几乎都是。。》的文章。文章讲述了为什么几年前计算机行业工资高以及计算机行业996的原因。以下内容来自原文：</p><hr><p><em>在移动互联网的黄金时代刚刚到来的时候，从事其中的人们坚信，能够用移动互联网将生活中的方方面面全部重建一遍，他们，是影响社会进程的那一拨人。</em></p><br/><p><em>那时候的程序员，工作时长说 996 都保守了，应该是 007，每天工作十二小时，每周七天，他们是怀揣着野心去工作的，回报也很丰厚，一拨人实现了财富自由。机会很多而人手奇缺，于是一个人当两三个人用，也就是这个时候开始，互联网那班人工资高、工作起来不要命，和格子衫、秃头、木讷这些标签一起，996的工作作息开始深入人心，提及程序员，大概率会联想到它。那些年，尽管工作时长多了，但打工人并不会抗拒，因为，他们的薪水涨幅更高，短短几年，大厂就把IT应届生的工资水准从十来万提升到了三四十万，基本上一年一个台阶。但是潮水终有退去时。2022年6月份的统计数据，我国网民规模为10.51亿，普及率高达74.4%，除了一些实在不会使用智能手机的人群，基本上已经做到了人人都接入了互联网。</em></p><br/><p><em>所以，在不起风的时候，再怎么折腾，回报也不会像以往那么丰厚了。<strong>在上行的电梯里，无论是站着、躺着、还是努力往上跳，都影响不大，核心因素，是因为这个电梯在持续上行，直到，它慢慢的停下来。</strong>可做的事情少了，互联网的冗员多了，对于人均工时的需求自然就降下来了，曾经备受青睐的 996 失去市场了，到了退出历史舞台的时候了。现在除了一些极致追求性价比的公司，包括了非常少数的无良大厂和一些还不太规矩的代码小作坊，很少听见哪家公司还在采用 996 的出勤时间。</em></p><br/><p><em>供需供需，无形的手，在背后发挥着作用。随着需求的进一步减少，近年国内外的大小厂步骤一致的降本增效，直到达到新的供需平衡。当需求超过供给，就是打工人的春天，升职加薪稀松平常；而需求低迷时，就得勒紧裤腰带过日子。</em></p><hr><p>下午学习java基础，过年期间看的集合类相关知识重拾过于耗时了，当下目标是快速过完基础学框架做项目，因此从<strong>File类</strong>和<strong>IO流</strong>开始看起。<br><br/></p><p>看视频除了几次要睡着之外，明白了文件或者是文件目录在<code>java</code>中是<code>File</code>对象表示，在<code>java</code>中为了防止\编译（例如<code>\n</code>换行），通常使用<code>\\</code>或者<code>/</code>来代替文件路径中的\。紧接着学了<code>File</code>对象的几个常用方法。其中删除文件目录&#x2F;计算文件目录大小，这两个方法需要通过递归的形式删除&#x2F;计算出每个子目录下的文件。<code>renameTo()</code>方法实际上是对文件的移动+重命名，使用场景例如对一个文件夹内所有的文件按照规律重命名。</p><br/><p>IO流即以程序角度来看，数据输入和输出的过程。这个传输的过程类似于流的形式，分有字节流与字符流两种格式。字节是以计算机基本语言0和1来传输，适合视频、音频、word等复杂格式的传输形式，而字符就是简单的文本传输。这两种格式在<code>java</code>中对应的两种不同的实现类，可以以<code>stream</code>代表字节、<code>read</code>&#x2F;<code>write</code>代表字符来简单区分。再次基础上进行封装产生了更多适用于不同文件类型的包装流，例如缓冲流、转换流、对象流等等。</p><br/><h2 id="2024-3-5-星期二"><a href="#2024-3-5-星期二" class="headerlink" title="2024.3.5-星期二"></a>2024.3.5-星期二</h2><p>继昨天剩下的，今天学习了<strong>各种包装流</strong>。</p><br/><p>例如缓冲流：创建缓冲区来记录写入&#x2F;读取的文件，减少与磁盘的交互次数，在大文件的传输上很有效率；</p><p>转换流：将输入的字节流转换为字符流输入，将输出的字符流转换为字节流输出。说起字符，就得说起字符集也就是编码，不同的编码影响字符的显示效果，转换流的作用就是将字节转换成指定的编码的字符。只有编码与解码使用的字符集一致，才能正确的展示原字符；</p><p>对象流：使<code>java</code>中的对象实现持久化的保存在磁盘&#x2F;硬盘上，也可用于网络流的传输。要想实现序列化必须实现<code>Serializable</code>接口以及设置<code>SerialVersionUID</code>，前者没有任何抽象方法，只是个标识接口，后者为标识<code>Id</code>，用于确定以及唯一性，不手动设置的话系统会自动设置，但是每一次改变该对象的属性时该值会变动。对象流实际使用场景少，重点了解序列化的相关知识；</p><p>打印流：只有输出流，<code>Java</code> 的标准输出流 <code>System.out</code> 就是一个 <code>PrintStream</code>。也可以来向外部设备（例如控制台、文件）发送数据。</p><br/><p>其次学习了<code>Java</code>的<strong>网络编程</strong>。实打实体会到了在<code>Java</code>中何为“万事万物皆对象”的特性。<code>ip地址</code>用于在千万设备中找到目标设备，端口号用于在设备的万千程序中找到需要目标程序，协议用以保障连接的高效和稳定。</p><br/><p>在<code>Java</code>中，<code>InterAddress</code>类的实例代表了一个<code>ip地址</code>。<code>Java</code>程序之间的网络通信通过<code>Socket</code>类来实现，根据<code>TCP</code>协议：三次握手四次挥手的双向连接与<code>UDP</code>协议：无连接，两种不同的协议有不同的实现方法。</p><br/><p><code>URL</code>类是因特网的资源的指针，它可以根据已知的URL下载资源、解析URL，建立连接等。</p><br/><h2 id="2024-3-6-星期三"><a href="#2024-3-6-星期三" class="headerlink" title="2024-3-6-星期三"></a>2024-3-6-星期三</h2><p>今天状态有一点低迷。主要是困 <code>=.=</code> 。原计划是今天学完<strong>反射</strong>的全部内容，但是发现理解上有点难度，过于抽象了。</p><br/><p>物理学中光的反射形象的展示了”反射“一词的意义，在<code>Java</code>中同样如此。以前实例化对象需要依次经过引入包 -&gt; 通过<code>new</code>实例化对象 -&gt; 取得对象的实例，而反射的出现恰好反转了其过程：由实例化的对象 -&gt; <code>getClass()</code>方法 -&gt; 得到完整的包类名称。之前调用对象的方法为<code>对象名.方法名()</code>，在反射中为<code>方法名().invoke(对象名)</code>，实打实的“反”。反射能够在程序运行中获取、操作类，也可以”爆破”无视类中的修饰符限定从外获取私有属性、方法。此过程似乎打破了<code>Java</code>封装的特性，但是此特性出现的初衷并不是用于“破坏”封装性，而是为了提供更多更大的灵活性和通用性。<code>Java</code>提供的这种功能，就如封装特性，并没有在语法层面做要求，他想表达更多的是建议去这样做，而不是不可以不能这样做。正是因为这样的存在，框架也才能得以迅速升起。</p><br/><p>说回反射，它能够在程序运行过程中动态的获取类，以及操作类，主要有<code>Class</code>类，通过它可以获取类的名字，父类、接口、构造器、方法和属性等信息。有三种方法可以得到<code>Class</code>类的实例，对编译好的<code>.class</code>文件进行解释运行加载到内存中的<code>.class</code>文件对应的结构即为<code>Class</code>的一个实例。因为同一个类加载器加载类只会加载一次，所以得到的三个实例为同一个。</p><br/><p>紧接着学习了通过反射获取类的各种信息，包括类的对象、有参空参构造器、私有静态属性以及方法等。</p><br/><p>最后注解部分发现之前学的注解已经忘光了，在通过反射的方式获取注解时完全不知道有何作用。明天把注解重学一遍，然后给反射暂且画上句号。</p><br/><h2 id="2024-3-7-星期四"><a href="#2024-3-7-星期四" class="headerlink" title="2024-3-7-星期四"></a>2024-3-7-星期四</h2><p>今天学习了<strong>注解</strong>，<strong>反射</strong>，还奖励了自己一顿疯狂星期四。</p><br/><p>注解简而言之和注释类似，都是对程序代码的补充、对程序代码的标记，不同的是，注解可以被编译器或者其他程序读取，并且程序可以根据注解的不同，做出相应的处理。与反射结合，那么就可以代替旧版<code>JavaEE</code>中所遗留的繁冗的代码和XML配置。注解在语法上可以用像修饰符一样被使用，根据注解的属性参数值的不同来决定同一个注解的不同功能或作用。同时注解还分为<code>自定义注解</code>，以及解释注解的注解的<code>元注解</code>两种。注解主要使用场景在于配合反射，作于配置文件的地位。</p><br/><p>配合注解的学习，通过反射获取注解这一过程也能有一定的理解。昨天学习的反射相关知识在今天也能够融会贯通。举个场景来证明反射配合注解的重要性：</p><p>在<code>Java</code>程序写好部署后，其中必然有很多不同的对象，不可能让所有的对象都创建保持活性，而是根据所需创建。前后端分离项目中，前端发送数据(包含方法、URL、数据等)给后端，后端分析后可以根据注解来执行不同业务逻辑或是创建临时对象、修改现有对象等，在运行中的代码中这些可以通过反射来调控，注解做靶向。</p><br/><p>为了实践这一过程，榨汁儿机这个案例充分利用了注解与反射的使用。</p><br/><p>为了学反射，不得不提到类的加载过程。长达一小时的“了解”这个过程，十分痛苦。这是<code>JVM</code>的内容，暂时不是我的重点，但是也明白了类的加载三个过程，包括不同类的加载器功能的不同。船到船头自然直，如果真的有到需要学习<code>JVM</code>的那一个境界，到时候也许并不会对这长达一小时的时间作出“浪费”、“低性价比”的评判吧~</p><br/><p>现在可以暂时给反射画上一个句号了。以目前的知识量来说确实很难理解注解与反射实际的作用，希望在后面框架学习中能给出答案。</p><br/><h2 id="2024-3-9-星期六"><a href="#2024-3-9-星期六" class="headerlink" title="2024-3-9-星期六"></a>2024-3-9-星期六</h2><p>昨天去看电影了，没有学习，今天把昨天的补上。 今天学习了<code>Java8</code>新特性：<code>lambda表达式</code>、方法引用、<code>Stream API</code>。</p><br/><p><code>lambda表达式</code>的本质是实现了函数式接口的实例，它以一种简洁的方式简化了代码，看起来不仅更加高大上，写起来也非常爽。以<code>() -&gt; &#123;&#125;</code>方式为主，左边为参数，右边为方法体。使用<code>lambda表达式</code>的前提是需要满足函数式接口——只声明了一个抽象方法的接口。<code>Java</code>也内置了很多函数式接口，他们都有<code>@FunctionInterface</code>注解标记，以<code>Consumer消费型</code>、<code>Supplier供给型</code>、<code>Function函数型</code>、<code>Predicate断定型</code>为核心。</p><br/><p>方法引用则在实现了<code>lambda表达式</code>的基础上，满足一定条件后可以进一步简洁的方式来实现。以<code>类/实例 :: 静态方法/非静态方法</code>的 格式呈现。它极大程度上减少了代码的冗余，但是在理解代码难度上拔高了要求。如果把某个对象的构造器看成方法，那么创建对象也可以使用方法引用的方式创建对象，如<code>BiFunction&lt;String, Float, Employee&gt; biFunction2 = Employee::new;</code>。根据函数式接口的种类以及参数的不同，实现使用不同构造器创建对象。</p><br/><p><code>Stream API</code>是<code>Java</code>对数据处理的一种补充，对集合数据进行操作，其过程类似于使用<code>SQL</code>执行的数据查询。使用它并不会改变原有的数据，它本身也并不会储存数据，而是返回了一个持有结果的全新<code>Stream</code>。使用<code>Stream</code>有三个步骤：创建-中间操作-终止操作。创建<code>Stream</code>流可以通过集合创建顺序流或并行流，前者在于顺序一致，后者优点在于处理大数据上有更高的效率；中间操作包括筛选切片映射排序等，往往与函数式接口配合方法引用实现对于数据的处理。终止操作是对流的终止，只有执行了中止操作，才会执行中间操作链，并且在这之后该<code>Stream</code>不会被再次使用。</p><br/><p>到此为止<code>Java</code>基础可以暂告截至。</p>]]></content>
    
    
    <categories>
      
      <category>学习</category>
      
      <category>笔记</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>梦入故山人未去</title>
    <link href="/2023/08/03/%E6%A2%A6%E5%A2%83/"/>
    <url>/2023/08/03/%E6%A2%A6%E5%A2%83/</url>
    
    <content type="html"><![CDATA[<blockquote><p>这是关于追捕玛卡巴卡的一夜梦，趁还还在便记录下来&#x3D;&#x3D;</p></blockquote><p>这几天感冒了，可能是空调连夜吹导致的，湖北的天气总是如此，夏天和冬天。</p><p>8月2日回到宿舍的时候，舍友H还在图书馆为上岸做准备，轮次换的饮水机纯净水他还没换，两天了都。</p><p>本着不过多消耗体能的目的，我去除了不必要的人体活动，去了床上，宿舍锁门之前，舍友H回来了，给我说起考研自习室的见闻，顺带提起了这两天楼下没有水可以换，但他给我准备了冰红茶在冰箱里云云。</p><p>第一场梦是关于另一位宿舍Y，他有床位但是没在宿舍住，他拎着两个礼盒回来了一趟，说是家里有什么喜事，礼盒里的东西嘛，一瓶奶茶不知道什么牌子，还有一桶柠檬红茶喊很大一桶，我见是他拎回来的，也觉着口渴，便喝了起来，只消一口那桶便见了底，刚尝了点味的我更渴了。</p><p>这时候人是已经醒了的，由于晚上没摄入水分的缘故，嘴里干的难受，想着冰箱里还有一瓶冰红茶，于是迅速下床，直本冰箱而去，看了看时间，凌晨三点多，一边吨吨吨喝一边窝在沙发椅中，再次上床的时候已经四点了。</p><p>第二场梦中，我是在医院，梦里的身体对比现实有缩水的成分在里面，大约是11-14岁的年纪，住院的原因是这副身体的主人感冒了，住院打点滴。在我隔壁床是一个小朋友，七八岁的样子只有，到了中午饭点，小朋友的父母来探望他，并且一起吃午饭病房里，我当时没有很饿就没有吃，直接拉上窗帘午睡。</p><p>我是被我妈喊醒的，在我午睡的时候，来看我的人很多，我爸我妈，兄长两个妹妹以及小学后就多年未见的爷爷奶奶，也给我带了家里做的饭，正好中午也没吃饭，在我吃饭的时候隔壁床的小孩也醒了，眼巴巴的看着我的食物，见状我分了一部分给他，他也就在他床上吃起来。</p><p>这个时候从门外进来查房的护士，看见这么多小孩就问，你家里几个小孩啊？我爸开着玩笑说：喏喏喏这五个都是我家的。</p><p>那个护士听完惊讶的走开了，那之后，我的病房靠走廊那边的玻璃上不时都会倒映出三三两两人影来，毕竟对于群众而言，一个家庭五个孩子在这个时代是极为罕见的。</p><p>在这场围观中，群众的内心都是很满足的，除了我们一家。这时不知谁提议说下午出去逛逛吧，于是就商量了起来。</p><p>我很开心，因为我也在他们的提议中。商讨完毕我爸我妈他们就出去了，去医院外面等我和我哥，我哥在这陪着我待我整理好后和我一块过去。</p><p>不得不说，这个医院是真的很大，我只知道我住的地方是住院部，我从病房出来到住院部的门就要弯弯绕绕好久，住院部的门到医院大门的距离更别说要多远了，百草园到三味书屋那么远吧。</p><p>当我整理好，我和我哥就开始出发，我们弯弯绕绕走到住院部门的时候，我突然想起自己有一个卡片没带，这个卡片是我可以出门的证明。</p><p>没有办法我只好返回去拿卡片，但是我让我哥自己先去医院门口等我，自己一个人回去。</p><p>不得不说，这个年纪的身体就是有活力，我返回是跑着的，一路上看见护士和护工在搬运医疗器械或者桌椅什么的，我当时的想法就是，读护理专业的话如果么有很好的资源就只能在医院里找工作，然后出力出人。</p><p>无心感慨其他，我拿到卡片后继续往医院门口跑去。</p><p>出了住院部，整个医院全貌堪堪一窥。待我到达医院门口的时候，当时已经下午16:00左右，我因为自己耽误大家一个小时余而没有很高的兴致，但是家人没有因为这个有所抱怨。</p><p>再次有意识是在一座高山山顶，这具身体已经和现实中我年龄一样了，我和我的二十余位兄弟来此听讲师讲课。我问她，人这一生最珍贵的是什么？她说，得不到的和已经失去的。</p><p>听完这句话，我疯了，披头散发狂奔在山上，然后跳下山崖。</p><p>我的二十余位兄弟见状，献祭自己，为了让我重活一世。</p><p>当我再次醒来，在医院的病床上，我当时就想，上面的经历是真还是假，或者是是这具身体主人睡觉时的异想罢了。</p><p>床边的医生告诉我，下午我就可以出院了，我看了看时间，过去两天半。</p><p>下午离开的时候，医院的场景和我见到的一模一样。</p><p>在住院部门口，和一个大爷擦肩而过。</p><p>后面的生活里，我好像是失去了什么，一时间也没有印象，便没有在意。</p><p>后来我读完大学，去一个地方工作，又遇到了那个大爷，他在这当门卫，工资待遇非常人可比。</p><p>闲聊时我问他每个月多少米，这时候他却告诉我他有超能力，因为用我和他擦肩而过的方式，把能力传导到了公司老板的儿子，不过是一个从天而降一个拔地而起。</p><p>我第一次见到老板儿子的感觉就是，他是三级阀点觉醒，后提升到了四级。</p><p>门卫大爷是一级阀点，一级异能。</p><p>现在关于我失去的那部分印象，我全记起来了。</p><p>他们的能力来源于我，异能传导方式为相向运动。</p><p>随着记忆回复的，还有我的能力，本着平常心，我仍在这里工作。</p><p>后经人说媒，认识一个女生，在烟草局工作，人美声甜。</p><p>万恶的相亲，唉</p><p>确认关系以后，我也带着她她也见过我父母。</p><p>但是我还没去她家，醒了。</p><p>所以，婚没结成( •̥́ ˍ •̀ू )</p>]]></content>
    
    
    <categories>
      
      <category>生活</category>
      
      <category>梦境</category>
      
    </categories>
    
    
    <tags>
      
      <tag>梦境</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>今朝有酒今朝醉</title>
    <link href="/2023/07/10/%E4%BB%8A%E6%9C%9D%E6%9C%89%E9%85%92%E4%BB%8A%E6%9C%9D%E9%86%89/"/>
    <url>/2023/07/10/%E4%BB%8A%E6%9C%9D%E6%9C%89%E9%85%92%E4%BB%8A%E6%9C%9D%E9%86%89/</url>
    
    <content type="html"><![CDATA[<p>长安三万里，强推给喜欢唐诗宋词，有文艺情怀的人。</p><p>画面美不胜收，有浪漫唯美，有诗情画意，也有悲凉壮阔。</p><p><img src="/img/36035676/p2886577292.jpg"></p><p>当听到熟悉的诗词在相契合的场景被念出的时候，真的很激动。</p><p>前一刻还在感概，少年人的今夕何在，下一刻又沉浸在诗人烂漫的幻想里。</p><p><img src="/img/36035676/p2894008733.jpg"></p><p>肆意才情，山河卫戍，从不夜长安的盛景到国破残楼。</p><p>一个像块坚石，在边塞沙场领将涉命，也在梁园乡野搁置过，国破家亡之时最能明白普通人连守常都无法拥有的那种惊恐失措，更看得清政治斗争之下的暗流。</p><p><img src="/img/36035676/p2895393518.jpg"></p><p>而另一个是潇洒饮者，桀骜也同样天真幼稚，官场入世不得便寻出世山河，最后却还是离不开乱世的抱负，又再惊慌入世，却被政治裹挟，但不管在盛世还是乱世，斗酒纵情只为当下能有片刻就已是生命中最大的欢欣与不易，他的醉意人生更成为了唐、唐诗、诗人都不及的神话，这样一个人，仅存在过就已经是盛唐最好的历史留影。</p><p><img src="/img/36035676/2175717127b8aedcec3b248f8ceebc1.jpg"></p><p>没有像妖猫传一样恢弘的唐宫视觉，它只是在追看两个人的生命，是曾坐在教室背诗的我不曾看过的那一面生命，始终对这个时代满怀热情，一心当为大鹏；始终羁绊朋友念及家人，不舍情义二字；始终把断续的离合都当作最后一次去互勉，你我终会如愿；始终把今朝当作最后一瞬去生活，终其一生，仅此而已。</p><p>再多的科学预测与冷静，也无法完全应对人生所有的冲击，这时神话的语言反而更加贴切，而这两颗星辰以及身边那些同样灼灼的星辰，就是那个时代最浪漫不渝、勇敢不屈的神话。</p><p><img src="/img/36035676/p2895317039.jpg"></p><p><img src="/img/36035676/1ae6e889e15a88fbff53d348d5b135e.jpg"></p><p>可能是到目前为止看过的最浪漫的一部国漫了，至交情谊，一起亲历，是另一种程度的浪漫！电影故事暗含了人的一生，借用少年时的鹏程万里，青年时的上下求索，中年时的事与愿违，老年时的盛极而衰。将中式浪漫展现极致：<strong>无论如何，人生漫漫，总有再会时!</strong></p><p><em><strong>只要黄鹤楼的诗还在，黄鹤楼就在；只要诗在，长安，就会在~</strong></em></p><p><img src="/img/36035676/305a015eec5b2ca4f59c2784283b1ec.jpg"></p>]]></content>
    
    
    <categories>
      
      <category>生活</category>
      
      <category>影评</category>
      
    </categories>
    
    
    <tags>
      
      <tag>影评</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Mysql基础</title>
    <link href="/2023/07/07/Mysql%E5%9F%BA%E7%A1%80/"/>
    <url>/2023/07/07/Mysql%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<h1 id="Mysql数据库基础"><a href="#Mysql数据库基础" class="headerlink" title="Mysql数据库基础"></a>Mysql数据库基础</h1><blockquote><p>很基础的语法知识，真的很基础，等需要学到进阶一点再更新</p></blockquote><br/><h2 id="–建表"><a href="#–建表" class="headerlink" title="–建表"></a>–建表</h2><div class="code-wrapper"><pre><code class="hljs mysql">create table `table_name`(    `fieid` datatype,    `fieid` datatype,)character set collate engine</code></pre></div><p><strong>fieid</strong>：列名</p><p><strong>datatype</strong>：列类型（字段类型）</p><p><strong>character set</strong>：字符集（不指定默认为数据库类型）</p><p><strong>collate</strong>：校对规则（不指定默认为数据库校对规则）</p><p><strong>engine</strong>：引擎</p><br/><br/><br/><h2 id="–char与varchar"><a href="#–char与varchar" class="headerlink" title="–char与varchar"></a>–char与varchar</h2><ul><li>char（n） n是固定字符数，不论是中文或是英文都存放n个固定字符数，就算没有达到n也会占用n个字符空间</li><li>varchar（n） n是可变字符数，根据实际值占用相对应的空间，具体占用多少字节空间取决于编码格式（utf是2n，gdk是3n）</li><li>varchar（n） 本身会占用1-3个字节空间用于记录存放字节的长度，因此实际可使用的字节空间要小于n</li><li>char的查询速度比varchar要快</li></ul><br/><br/><br/><h2 id="–基本函数"><a href="#–基本函数" class="headerlink" title="–基本函数"></a>–基本函数</h2><p>暂略</p><br/><br/><h2 id="–表的操作"><a href="#–表的操作" class="headerlink" title="–表的操作"></a>–表的操作</h2><div class="code-wrapper"><pre><code class="hljs mysql">--新增列alter table `table_name`      add `fieid` varchar(32) not null default ``--设置不允许为空，默认值为null      after `fieid`--显示表结构desc `table_name`--修改列的长度alter table `table_name`      modify `fieid` varchar(60) not null default ``--删除列alter table `table_name`      drop `fieid`--修改表名rename table `table_name` to `newTable_name`--修改表的字符集alter table `table_name` character set utf-8--修改列名alter table `table_name`      change `fieid` `newFieid` varchar(32) not null default ``</code></pre></div><br/><br/><h2 id="–CRUD"><a href="#–CRUD" class="headerlink" title="–CRUD"></a>–CRUD</h2><p><strong>Create</strong></p><div class="code-wrapper"><pre><code class="hljs mysql">insert into `table_name` (fieid , fieid ,fieid)  values(`` , `` , ``),(`` , `` , `` )--此处顺序需要与列字段一致--如果想指定列的某个字段默认值，在创建表的时候设置默认值即可</code></pre></div><p><strong>Update</strong></p><div class="code-wrapper"><pre><code class="hljs mysql">update `table_name`   set `fieid` = xxx ，`fieid` = xxx  where `fieid`= xxx--条件，修改哪一行，不写默认修改全部</code></pre></div><p><strong>Delete</strong></p><div class="code-wrapper"><pre><code class="hljs mysql">delete from `table_name`  where `filed` = xxx</code></pre></div><p><strong>Retrieve</strong></p><div class="code-wrapper"><pre><code class="hljs mysql">select (distinct) `fieid` , `fieid` from `table_name` --（distinct只有每个字段都相同才会去重）  where `条件`                      --使用运算和别名的方式查询select `fieid` , (`fieid` + `fieid`) as `别名` from `table_name`--排序select `fieid` from `table_name`  where `xxx`    order by `fieid`（也可以使用别名） ase  --升序（默认）/ desc 降序--统计和平均值--count()不会统计为NULL的行select sum(`fieid`) , avg(`fieid`) , count(`fieid`) from `table_name`--最值select max(`fieid`) , min(`fieid`) from `table_name`--group by 与 having--group by：对重复的元素转成一组--having：对分组后的数据进行过滤，作用替代whereselect avg(`fieid1`) as `avg_fieid1`, min(`fieid2`) , `fieid3`   from `table_name` --处fieid3列在表中含有多个相同的元素    group by `fieid3` having `avg_fieid1`&lt;2000 --使用别名效率高，避免重复使用计算平均数函数--分页--start：开始的数量，表从start+1开始取--row：显示多少行select... limit(start , row)--每页展示n条数据，显示第m页 ：select... limit(n*(m-1),n)--语法顺序：分组-&gt;过滤-&gt;排序select xxx from xxx  group by xxx    having xxx      order by xxx desx        limit xxx</code></pre></div><br/><p><strong>多表查询</strong></p><blockquote><p>user</p></blockquote><table><thead><tr><th>id</th><th>name</th><th>depId</th></tr></thead><tbody><tr><td>1</td><td>小明</td><td>10</td></tr><tr><td>2</td><td>小张</td><td>20</td></tr></tbody></table><blockquote><p>dep</p></blockquote><table><thead><tr><th>depId</th><th>address</th></tr></thead><tbody><tr><td>10</td><td>NewYork</td></tr><tr><td>20</td><td>China</td></tr></tbody></table><br/><p>两表联立查询</p><div class="code-wrapper"><pre><code class="hljs mysql">select * from user , dep</code></pre></div><blockquote><p>user , dep</p></blockquote><table><thead><tr><th>id</th><th>name</th><th>depId</th><th>depId</th><th>address</th></tr></thead><tbody><tr><td>1</td><td>小明</td><td>10</td><td>10</td><td>NewYork</td></tr><tr><td>1</td><td>小明</td><td>10</td><td>20</td><td>China</td></tr><tr><td>2</td><td>小张</td><td>20</td><td>10</td><td>NewYork</td></tr><tr><td>2</td><td>小张</td><td>20</td><td>20</td><td>China</td></tr></tbody></table><p>可见多表联立查询，是以笛卡尔积的方式组合在一起的，会有很多重复项</p><p>因此我们可以根据where条件限定两表相同的内容（或者包含的内容）从而进行筛选（where限制条件不能少于表-1）</p><div class="code-wrapper"><pre><code class="hljs mysql">select * from user , dep where user.depId = dep.depId</code></pre></div><blockquote><p>user , dep</p></blockquote><table><thead><tr><th>id</th><th>name</th><th>depId</th><th>depId</th><th>address</th></tr></thead><tbody><tr><td>1</td><td>小明</td><td>10</td><td>10</td><td>NewYork</td></tr><tr><td>2</td><td>小张</td><td>20</td><td>20</td><td>China</td></tr></tbody></table><p>因为两表都含有depId列，查询depId字段时需要指定说明查询哪个表的depId，尽管两表相同。</p><div class="code-wrapper"><pre><code class="hljs mysql">select `name` , `user.depId` ,`address` from user , dep where user.depId = dep.depId</code></pre></div><table><thead><tr><th>name</th><th>depId</th><th>address</th></tr></thead><tbody><tr><td>小明</td><td>10</td><td>NewYork</td></tr><tr><td>校长</td><td>20</td><td>China</td></tr></tbody></table><br/><p><strong>自连接</strong></p><blockquote><p>1.把一个表当作两个表来使用</p><p>2.为了易读性，需要给表名取别名，同理列名也可以取别名</p></blockquote><br/><blockquote><p>user</p></blockquote><table><thead><tr><th>id</th><th>name</th><th>bossId</th></tr></thead><tbody><tr><td>1</td><td>jack</td><td>5</td></tr><tr><td>2</td><td>mike</td><td>5</td></tr><tr><td>3</td><td>smith</td><td>2</td></tr><tr><td>4</td><td>roly</td><td>2</td></tr><tr><td>5</td><td>king</td><td>NULL</td></tr></tbody></table><p>需求：列出每个员工的姓名以及上级姓名</p><div class="code-wrapper"><pre><code class="hljs mysql">select work.name as `职工` , boss.name as `老板`  from user work , user boss    where work.bossId = boss.id</code></pre></div><p><strong>外连接</strong></p><blockquote><p>左外连接后依然会保留左边表的全部内容，没有相关联的内容为NULL</p><p>右外连接后依然会保留右边表的全部内容，没有相关联的内容为NULL</p></blockquote><div class="code-wrapper"><pre><code class="hljs mysql">select xxx from  `table1` left join `table2`    on xxx --条件</code></pre></div><p>同理右外连接为</p><div class="code-wrapper"><pre><code class="hljs mysql">select xxx from  `table1` right join `table2`    on xxx --条件</code></pre></div><p><strong>子查询</strong></p><blockquote><p>嵌套使用select语句，包括单行子查询和多行子查询，多行子查询用in</p><p>子查询的结果也可以当作临时表来使用</p></blockquote><br/><blockquote><p>user</p></blockquote><table><thead><tr><th>id</th><th>name</th><th>depId</th><th>sal</th></tr></thead><tbody><tr><td>1</td><td>jack</td><td>2</td><td>100</td></tr><tr><td>2</td><td>mike</td><td>2</td><td>150</td></tr><tr><td>3</td><td>lucy</td><td>1</td><td>400</td></tr><tr><td>4</td><td>smith</td><td>3</td><td>300</td></tr><tr><td>5</td><td>north</td><td>4</td><td>88</td></tr><tr><td>6</td><td>eric</td><td>4</td><td>50</td></tr><tr><td>7</td><td>a</td><td>1</td><td>1000</td></tr><tr><td>8</td><td>b</td><td>2</td><td>99</td></tr><tr><td>9</td><td>c</td><td>3</td><td>299</td></tr><tr><td>10</td><td>d</td><td>4</td><td>10</td></tr></tbody></table><p>需求：列出与jack在同一部门的员工</p><div class="code-wrapper"><pre><code class="hljs mysql">select * from user  where depId = (    select depId     from user    where `name` = `jack`  )</code></pre></div><p>需求：列出比b工资高的同事</p><div class="code-wrapper"><pre><code class="hljs mysql">--方法一select name from user  where sal &gt; all(select sal from user    where depId = 2)    --方法二select name from user  where sal &gt; (select max(sal) from user    where depId = 2)    --可以看出，max操作的对象是列，而all或者any操作的对象是整个表</code></pre></div><p>子查询当作临时表来使用：</p><p>需求：列出每个部门中高于当前部门平均工资的员工</p><div class="code-wrapper"><pre><code class="hljs mysql">select name from user , (    select depId , avg(sal) as avg_sal    from user     group by depId  ) as temp      where user.depId = temp.depId , user.sal &gt; temp.avg_sal</code></pre></div><br/><br/><h2 id="–约束"><a href="#–约束" class="headerlink" title="–约束"></a>–约束</h2><br/><h3 id="主键"><a href="#主键" class="headerlink" title="主键"></a>主键</h3><blockquote><p>约束一个表中的唯一列，该列的关键字不能重复且不能为空</p></blockquote><p><strong>语法：</strong></p><div class="code-wrapper"><pre><code class="hljs mysql">--方式一create table `table1`(  id int primary key,  `name` varchar(32),  email varchar(32),)--方式二create table `table1`(  id int,  `name` varchar(32),  email varchar(32),  primary key(id))</code></pre></div><p><strong>一个表中只能拥有一个主键，但是可以用有复合主键</strong></p><div class="code-wrapper"><pre><code class="hljs mysql">create table `table1`(  id int ,  `name` varchar(32),  email varchar(32),  primary key(id , `name`) --复合主键)</code></pre></div><p>这种情况下，id与name组合成为了一个复合组件，只有当他们俩都相同的时候，才违反了主键不能重复的原则</p><br/><h3 id="unique"><a href="#unique" class="headerlink" title="unique"></a>unique</h3><blockquote><p>约束该列的值唯一，不可以重复</p></blockquote><p><strong>语法：</strong></p><div class="code-wrapper"><pre><code class="hljs mysql">create table `table1`  id int unique,  `name` varchar(32),  email varchar(32),)</code></pre></div><p><strong>如果该列没有指定非空（NOT NULL），则可以允许多个NULL值</strong></p><p><strong>一个表中可以允许多个unique存在</strong></p><br/><h3 id="外键"><a href="#外键" class="headerlink" title="外键"></a>外键</h3><blockquote><p>约束两个表的直接联系，外键所在表和主表相绑定，从此无法轻易添加或删除</p></blockquote><p><strong>语法：</strong></p><div class="code-wrapper"><pre><code class="hljs mysql">--主表create table my_class(  id int primary key,  `name` varchar(32) not null default ` `);--从表create table my_stu( id int primary key, `name` varchar(32) not null default ` `, classId int, foreign key (classId) references my_class(id)--指定外键关系</code></pre></div><p><strong>外键所指向主表的列必须为主键或者有unique约束，且数据类型必须一致</strong></p><p><strong>表的类型必须为innodb才支持外键</strong></p><p><strong>外键的值必须与所指向主表中列的值保持一致，但如果外键允许为空，则该外键也可以添加为NULL的字段。</strong></p><br/><h3 id="check"><a href="#check" class="headerlink" title="check"></a>check</h3><blockquote><p>指定某个字段的范围，在MySQL中只做了语法校验，并没有生效（Mysql8以上除外）</p></blockquote><div class="code-wrapper"><pre><code class="hljs mysql">create table my_class(  id int primary key,  `sex` varchar(6) check(sex in(`man`,`woman`)));--sex只能是man/woman</code></pre></div><br/><h3 id="自增长"><a href="#自增长" class="headerlink" title="自增长"></a>自增长</h3><blockquote><p>指定某一列自动增长，需要配合unique或者主键使用</p></blockquote><p><strong>语法：</strong></p><div class="code-wrapper"><pre><code class="hljs mysql">create table my_class(  id int primary key auto_increment,  `sex` varchar(6) check(sex in(`man`,`woman`)));--sex只能是man/woman--修改自增长开始数alter table my_class auto_increment = 10;</code></pre></div><p><strong>一般情况下，我们在新增数据时，无需顾及到自增长的字段，它会自动增长，无需手动赋值</strong></p><p><strong>但如果我们手动给自增长字段赋值，那么该字段的值不会自增长，成为你赋的值，同时下一个数据自增长从你赋的值开始（类似于走后门，同时不建议这么做）</strong></p><br/><br/><h2 id="–索引"><a href="#–索引" class="headerlink" title="–索引"></a>–索引</h2><blockquote><p>对列（字段）增加索引可以大幅度增加查询速度</p><p>以空间换时间</p></blockquote><p><strong>语法：</strong></p><div class="code-wrapper"><pre><code class="hljs mysql">--关键字：index ... oncreate index `索引名字` on my_table(`字段`)--查询表中的所有索引show index from my_tableshow keys from my_table--删除索引drop index `索引名` on my_table--删除主键索引alter table my_table drop primary key--修改索引：需要先删除，再增加新的索引。</code></pre></div><br/><p><strong>为什么加了索引查询会快很多？</strong></p><ul><li><p>在不加索引的情况下：</p><p>默认会对表中的所有数据进行扫描（遍历），即使查询的数据就在表的第一个也会继续向下查找，判断有没有重复相同的项目。因此不加索引是对表全盘扫描。</p></li><li><p>索引的原理是什么：</p><p>实质是对表进行了一种数据结构的排序，比如二叉树，B+树等，这里以二叉树为例子。</p><p>二叉树在表有顺序的情况下，拿取中间的数作为顶端数头，同时把数据分成两个部分，其余部分依次以二分法的方式拿取值，依次与树头进行比较。</p><p>比数头小的放在左边，大的放在右边，一次堆叠成一棵树。</p><p>这样查询时只需要和每一个树头的大小进行比较就可以快速定位至目标数。</p><p>例如，找到id&#x3D;4只需要先比较5-&gt;2-&gt;3-&gt;4即可。</p><p>因此加了索引，不是对表进行全盘扫描诶个读取，速度自然快很多。<img src="/img/mysql/23b88c3a4f567d045572606e0e6fabdf.png"></p></li></ul><br/><p><strong>使用索引的代价是什么？</strong></p><ol><li>占用更大的储存空间。以800万的数据为例，不创建索引时，文件大小500MB左右，加了一个索引后，文件大小有637MB左右。是以牺牲空间来换取查询时间的。</li><li>对增删改效率有影响。以上述二叉树为例，增删改会重新生成二叉树，对索引进行维护。</li></ol><br/><p><strong>索引的分类：</strong></p><ol><li>主键索引，创建主键的时候即为主键索引。</li><li>唯一索引，创建unique的时候为唯一索引。</li><li>普通索引，手动index创建的，与上面的区别在于允许值重复。</li><li>全文索引，fulltext关键字，mysql自带的不建议使用，一般开发使用全文搜索框架：Solr和ElasticSearch（ES）。</li></ol><br/><br/><h2 id="–事务"><a href="#–事务" class="headerlink" title="–事务"></a>–事务</h2><blockquote><p>保证事务的一致性，要么全部成功，要么全部失败。情景：转账</p></blockquote><p><strong>语法：</strong></p><div class="code-wrapper"><pre><code class="hljs mysql">start transaction --开始一个事务set autocommit --同上，第二种写法savepoint `保存点名`--设置保存点rollback to `保存点名`--回退事务到保存点名rollback --回退所有事务commit --提交事务，所有操作生效，不能回退</code></pre></div><p><strong>当回退到一个保存点后，该表存点之后的所有保存点都将失效。</strong></p><p><strong>InnoDB引擎支持事务，MYISAM不支持事务。</strong></p><br/><p><strong>事务的acid特性</strong></p><ul><li><p><strong>原子性</strong></p><p>指事务是一个不可分割的工作单位，事务中的操作要么全部发生，要么全部不发生。</p></li><li><p><strong>一致性</strong></p><p>事务必须使数据库从一个一致性状态变换到另外一个一致性状态。</p></li><li><p><strong>隔离性</strong></p><p>事务的隔离性是多个用户并发访问数据库时，数据库为每个用户开启的事务，不能被其他事务的操作数据所干扰，多个并发事务之间要相互隔离。</p></li><li><p><strong>持久性</strong></p><p>指一个事务一旦被提交，他对数据库中数据的改变就是永久性的，接下来即使数据库发生故障也不应该对其有任何影响。</p></li></ul><br/><h3 id="事务的隔离"><a href="#事务的隔离" class="headerlink" title="事务的隔离"></a>事务的隔离</h3><blockquote><p>在多链接的情况下，防止多个用户对同一个数据操作产生的差异，类似多线程</p></blockquote><br/><ul><li><p><strong>脏读：</strong></p><p>  可以看到一方在未提交时改变的数据及为脏读。</p></li><li><p><strong>不可重复读：</strong></p><p>  可以看到一方在未提交时对数据所做的更改和删除及为不可重复读。</p></li><li><p><strong>幻读：</strong></p><p>  可以看到一方在未提交时新增的数据及为幻读。</p></li></ul><br/><p><strong>事务的隔离级别：</strong></p><table><thead><tr><th align="center">Mysql隔离级别（4种）</th><th align="center">脏读</th><th align="center">不可重复读</th><th align="center">幻读</th><th align="center">加锁读</th></tr></thead><tbody><tr><td align="center">读未提交（Read uncommitted）</td><td align="center">V</td><td align="center">V</td><td align="center">V</td><td align="center">不加锁</td></tr><tr><td align="center">读已提交（Read committed）</td><td align="center">X</td><td align="center">V</td><td align="center">V</td><td align="center">不加锁</td></tr><tr><td align="center">可重复读（Repeatable read）</td><td align="center">X</td><td align="center">X</td><td align="center">X</td><td align="center">不加锁</td></tr><tr><td align="center">可串行化（Serializable）</td><td align="center">X</td><td align="center">X</td><td align="center">X</td><td align="center">加锁</td></tr></tbody></table><br/><p><strong>语法：</strong></p><div class="code-wrapper"><pre><code class="hljs mysql">set session transaction isolation level --设置隔离级别select @@transaction_isolation;--查看当前隔离级别</code></pre></div><br/><h2 id="–引擎"><a href="#–引擎" class="headerlink" title="–引擎"></a>–引擎</h2><ul><li><p><strong>innodb</strong></p><p>默认的引擎，支持事务，支持外键，支持行级锁</p></li><li><p><strong>myisam</strong></p><p>添加速度快，不支持事务，不支持外键，支持表级锁</p></li><li><p><strong>memory</strong></p><p>数据储存在内存中（关闭Mysql，数据丢失，表结构还存在），执行速度很快（内存中没有io读写），默认支持索引，基于哈希表，不支持事务，不支持外键</p></li></ul><br/><h2 id="–视图"><a href="#–视图" class="headerlink" title="–视图"></a>–视图</h2><blockquote><p>选择一个表&#x2F;视图，可以控制该表展示哪些内容，类似权限控制</p><p>视图是根据基本表来创建的，视图是一个虚拟的表，数据也来源于基表</p><p>视图与基表之间是映射关系</p></blockquote><p><strong>语法</strong></p><div class="code-wrapper"><pre><code class="hljs mysql">create view `视图名` as select `字段` , `字段` , `字段` from `基表`--删除视图drop view `视图名`, `视图名`</code></pre></div><p><strong>多表查询的结果可以用视图保存，方便下一次查询</strong></p>]]></content>
    
    
    <categories>
      
      <category>学习</category>
      
      <category>笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>mysql</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java基础</title>
    <link href="/2023/07/06/Java%E5%9F%BA%E7%A1%80/"/>
    <url>/2023/07/06/Java%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<h1 id="Java基础"><a href="#Java基础" class="headerlink" title="Java基础"></a>Java基础</h1><blockquote><p>基于java8及以上，比较杂乱且不完善，自用笔记</p></blockquote><ul><li><p><strong>JDK</strong></p><p>Java程序开发工具包，包含<code>JRE</code>和开发人员使用的<strong>工具</strong></p></li><li><p><strong>JRE</strong></p><p>Java程序的运行环境，包含<code>JVM</code>和运行时所需要的<strong>核心类库</strong></p></li></ul><br/><h2 id="内存分布"><a href="#内存分布" class="headerlink" title="内存分布"></a>内存分布</h2><ul><li><p><strong>堆</strong></p><p> <code>new</code>出来的结果（对象的实体、数组的实体等）。包括对象中的属性。jdk7以上，字符串常量池也放在了堆中。</p></li><li><p><strong>虚拟机栈</strong></p><p>方法内定义的变量，存储在栈中，先进后出。</p></li><li><p><strong>方法区</strong></p><p>存放类的模板。</p></li></ul><p><img src="/../img/java/01aadc96b225cab571989d6d630c7f1c.png"></p><br/><h2 id="static"><a href="#static" class="headerlink" title="static"></a><strong>static</strong></h2><ul><li>可以直接调用，不需要类名（对象名）。</li><li>static修饰的方法中只能调用static修饰的变量（包括方法），而普通方法中可以调用所有的变量和方法。（遵守修饰符规定）</li><li>static修饰的变量和方法，随着类的加载而加载，因此在对象<strong>未实例化时</strong>也可直接调用。</li><li>static修饰的代码块只会执行一次。</li></ul><br/><h2 id="类加载、构造器、执行顺序"><a href="#类加载、构造器、执行顺序" class="headerlink" title="类加载、构造器、执行顺序"></a><strong>类加载、构造器、执行顺序</strong></h2><br/><p><img src="/../img/java/2b6a7fae7706d956d62fc60bd0932ec2.png"></p><p>静态加载：在编译时就加载相关的类，依赖性强</p><p>动态加载：运行时加载需要的类，不需要时不加载，降低依赖性</p><br/><p><strong>类什么时候加载？</strong></p><ol><li>实例化对象时(new)，静态加载。</li><li>子类被加载时，父类也会加载，静态加载。</li><li>调用类的静态成员时，静态加载。</li><li>通过反射，动态加载。</li></ol><p>构造器的本质作用是为<strong>对象初始化，而不是创建对象</strong></p><br/><p><strong>注意事项：</strong></p><ul><li>类的加载不代表对象的实例，只有对象的实例才会引起类的构造器。</li><li>类只会加载一次。</li><li>static和final一起使用的变量不会引起类的加载。</li></ul><br/><p><strong>实例类的执行顺序：</strong></p><ul><li>同一个类的情况下：</li></ul><ol><li>静态代码块和静态属性（根据定义顺序）</li><li>普通代码块和普通属性（根据定义顺序）</li><li>构造器</li></ol><ul><li>继承的情况下：</li></ul><ol><li>父类的静态代码块和静态属性（根据定义顺序）</li><li>子类的静态代码块和静态属性（根据定义顺序）</li><li>父类的普通代码块和普通属性（根据定义顺序）</li><li>父类的构造器</li><li>子类的普通代码块和普通属性（根据定义顺序）</li><li>子类的构造器</li></ol><br/><h2 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h2><blockquote><p>一种套路：是长期理论之后，总结出来一种解决方案、思考方式。</p></blockquote><p><strong>什么是单例模式？</strong></p><p>采取一定的方法，保证在整个系统中，对某个类<strong>只能存在一个对象实例</strong>，并且该类只提供一个取得其对象的方法。</p><br/><p><strong>单例模式的实现方法：</strong></p><p>如果我们要让类在一个虚拟机中只能产生一个对象，我们首先必须将类的<strong>构造器的访问权限设置为</strong><code>private</code>，这样，就不能用<code>new</code>操作符在类的外部产生类的对象了，但在类内部仍可以产生该类的对象。因为在类的外部开始还无法得到类的对象，<strong>只能调用该类的某个静态方法</strong>以返回类内部创建的对象，静态方法只能访问类中的静态成员变量，所以，指向类内部产生的<strong>该类对象的变量也必须定义成静态的</strong>。</p><br/><p><strong>饿汉式单例模式（在类加载时便创建对象）</strong></p><ol><li>构造器私有化</li><li>在类加载时创建对象</li><li>对外暴露调用对象的静态方法</li></ol><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Cat</span>&#123;  <span class="hljs-keyword">private</span> String name;  <span class="hljs-keyword">private</span> <span class="hljs-title function_">Cat</span><span class="hljs-params">(String name)</span>&#123;   <span class="hljs-comment">//构造器私有化</span>    <span class="hljs-built_in">this</span>.name = name;  &#125;  <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Cat cat=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Cat</span>(<span class="hljs-string">&quot;小白&quot;</span>);   <span class="hljs-comment">//static下不创建对象直接调用</span>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Cat <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span>&#123;    <span class="hljs-comment">//static下不创建对象对外暴露对象接口</span>    <span class="hljs-keyword">return</span> cat;  &#125;&#125;</code></pre></div><br/><p>**懒汉式单例模式（类加载时不创建对象，需要时才创建对象） **</p><ol><li>构造器私有化</li><li>定义一个static的静态对象</li><li>在对外暴露调用对象的静态方法时再创建对象</li></ol><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Cat</span>&#123;  <span class="hljs-keyword">private</span> String name;  <span class="hljs-keyword">private</span> <span class="hljs-title function_">Cat</span><span class="hljs-params">(String name)</span>&#123;   <span class="hljs-comment">//构造器私有化</span>    <span class="hljs-built_in">this</span>.name = name;  &#125;  <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Cat cat;   <span class="hljs-comment">//创建但不实例化</span>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Cat <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span>&#123;    <span class="hljs-keyword">if</span>(cat == <span class="hljs-literal">null</span>)&#123;    <span class="hljs-comment">//判断是否实例化</span>      cat = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Cat</span>(<span class="hljs-string">&quot;小白&quot;</span>);    &#125;    <span class="hljs-keyword">return</span> cat;  &#125;&#125;</code></pre></div><p><strong>对比</strong></p><table><thead><tr><th align="left">单例模式</th><th align="center">特点</th><th align="center">优点</th><th align="center">缺点</th></tr></thead><tbody><tr><td align="left">饿汉式</td><td align="center">立即加载</td><td align="center">使用快、线程安全</td><td align="center">生命周期长（占内存）</td></tr><tr><td align="left">懒汉式</td><td align="center">延迟加载</td><td align="center">节省内存空间</td><td align="center">线程不安全</td></tr></tbody></table><p>线程安全的懒汉模式在多线程展示</p><h2 id="final和abstract"><a href="#final和abstract" class="headerlink" title="final和abstract"></a>final和abstract</h2><p><strong>final</strong></p><blockquote><p>最终的</p></blockquote><p><code>final</code>修饰的类<strong>不能被继承</strong>，修饰的方法<strong>不能被重写</strong>，修饰的变量成为常量<strong>不能被修改</strong></p><p><strong>abstract抽象类、抽象方法</strong></p><blockquote><p>随着继承层次中一个个新子类的定义，类变得越来越具体，而父类则更一般，更通用。类的设计应该保证父类和子类能够共享特征。有时将一个父类设计得非常抽象，以至于它没有具体的实例，这样的类叫做抽象类。</p></blockquote><p>被<code>abstract</code>限定的抽象类，<strong>只有方法签名，没有方法体，无法实例化</strong>，而是应该交给子类各自具体实现。Java语法规定，包含抽象方法的类必须是抽象类。</p><p>抽象类<strong>是包含构造器的</strong>。因为子类对象实例化时，需要直接或间接地调用到父类的构造器。</p><p>抽象方法必须要在子类中实现，否则该子类也为抽象类。</p><h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><blockquote><p>接口的本质是契约、标准、规范，就像我们的法律一样。制定好后大家都要遵守。</p><p>继承是是不是的关系、接口是能不能的关系</p><p>接口是对继承的一种补充</p></blockquote><br/><ul><li>接口中的属性默认修饰为public static final。</li><li>接口中的方法默认修饰为<code>public abstract</code></li><li>接口可以被接口继承，被类实现。</li><li>无法被实例化（没有构造器）。</li></ul><br/><p><strong>接口匿名实现类</strong></p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">USB</span> &#123;    <span class="hljs-keyword">void</span> <span class="hljs-title function_">start</span><span class="hljs-params">()</span>;    <span class="hljs-keyword">void</span> <span class="hljs-title function_">end</span><span class="hljs-params">()</span>;&#125;<span class="hljs-keyword">class</span> <span class="hljs-title class_">computer</span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">transfer</span><span class="hljs-params">(USB usb)</span>&#123;        usb.start();        usb.end();    &#125;&#125;<span class="hljs-comment">//接口匿名实现类</span>computer.transfer(<span class="hljs-keyword">new</span> <span class="hljs-title class_">USB</span>() &#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">start</span><span class="hljs-params">()</span> &#123;            &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">end</span><span class="hljs-params">()</span> &#123;    &#125;&#125;);<span class="hljs-comment">//实际工作中的开发场景：</span><span class="hljs-comment">//提供一个接口的实例</span><span class="hljs-keyword">public</span> Comparable <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span>&#123;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Comparable</span>() &#123;        <span class="hljs-meta">@Override</span>        <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">compareTo</span><span class="hljs-params">(Object o)</span> &#123;            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;        &#125;    &#125;;&#125;</code></pre></div><br/><p><strong>—-&gt;接口冲突</strong></p><p>类实现了两个接口，而两个接口中定义了<strong>同名同参数的默认方法</strong>。则实现类在没有重写此两个接口默认方法的情况下，会报错。</p><p>要求: 此时实现类必须要重与接口中定义的同名同参数的方法。</p><p><strong>—-&gt;类优先原则</strong></p><p>子类(或实现类)继承了父类并实现了接口。父类和接口中声明了同名同参数的方法。 (其中，接口中的方法是默认方法)。</p><p>默认情况下，子类(或实现类)在没有重写此方法的情况下，调用的是父类中的方法。</p><br/><p><code>jdk8</code>以上新特性：</p><p>现在允许存在默认方法<code>default</code>，可以被实现类使用、重写。</p><p>静态方法<code>static</code>修饰，只能被接口本身调用，无法被实现类调用</p><p>抽象类和接口的区别</p><table><thead><tr><th>区别点</th><th>抽象类</th><th>接口</th></tr></thead><tbody><tr><td>定义</td><td>可以包含抽象方法的类</td><td>主要是抽象方法和全局常量的集合</td></tr><tr><td>组成</td><td>构造方法、抽象方法、普通方法、常量、变量</td><td>抽象方法、常量、（默认方法、静态方法）（JDK8）</td></tr><tr><td>使用</td><td>子类继承抽象类<code>extends</code></td><td>子类实现接口<code>implements</code></td></tr><tr><td>关系</td><td>抽象类可以实现多个接口</td><td>接口不能继承抽象类、但允许继承多个接口</td></tr><tr><td>常见设计模式</td><td>模板方法</td><td>简单工厂、工厂方法、代理模式</td></tr><tr><td>对象</td><td>都通过对象的多态性产生实例化对象</td><td>都通过对象的多态性产生实例化对象</td></tr><tr><td>局限</td><td>抽象类有单继承的局限</td><td>接口没有此局限性</td></tr><tr><td>实际</td><td>作为一个模板</td><td>作为一个标准或是表示一种能力</td></tr><tr><td>选择</td><td></td><td>优先使用接口</td></tr></tbody></table><p>只要有基本数据类型和包装类进行比较，比较的是值是否相等，Integer的源码可知，-128~127之间的自动包装不会new一个新的对象。</p><br/><h2 id="比较器-x2F-排序"><a href="#比较器-x2F-排序" class="headerlink" title="比较器&#x2F;排序"></a>比较器&#x2F;排序</h2><blockquote><p>基本数据类型可以直接使用比较运算符比较</p><p>引用数据类型使用自然排序、定制排序</p></blockquote><h3 id="自然排序-实现Comparable接口的方式"><a href="#自然排序-实现Comparable接口的方式" class="headerlink" title="自然排序-实现Comparable接口的方式"></a><strong>自然排序-实现Comparable接口的方式</strong></h3><blockquote><p>适合直接修改代码</p></blockquote><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * 自然排序 - 实现Compareable接口 -&gt; 重写compareTo方法</span><span class="hljs-comment">*/</span><span class="hljs-keyword">class</span> <span class="hljs-title class_">Phone</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Comparable</span> &#123;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 按照价格-&gt;名称 从低到高排序*</span><span class="hljs-comment">     *</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> o</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 0：相同；  大于0：当前对象大；  小于0：当前对象小；</span><span class="hljs-comment">     */</span>    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">compareTo</span><span class="hljs-params">(Object o)</span> &#123;        <span class="hljs-keyword">if</span> (o == <span class="hljs-built_in">this</span>) &#123;            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;        &#125;        <span class="hljs-keyword">if</span> (o <span class="hljs-keyword">instanceof</span> Phone phone) &#123;            <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.price - phone.price == <span class="hljs-number">0</span> ? <span class="hljs-built_in">this</span>.name.compareTo(phone.name) : <span class="hljs-built_in">this</span>.price - phone.price;        &#125;        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<span class="hljs-string">&quot;类型不匹配&quot;</span>);    &#125;    <span class="hljs-keyword">private</span> String name;    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> price;    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Phone</span><span class="hljs-params">(String name, <span class="hljs-type">int</span> price)</span> &#123;        <span class="hljs-built_in">this</span>.name = name;        <span class="hljs-built_in">this</span>.price = price;    &#125;&#125;</code></pre></div><br/><h3 id="定制排序-实现Comparator类的方式"><a href="#定制排序-实现Comparator类的方式" class="headerlink" title="定制排序-实现Comparator类的方式"></a>定制排序-实现Comparator类的方式</h3><blockquote><p>适合没有实现comparable接口并且，无法修改源代码的时候使用</p><p>适合实现了comparable接口，但是并不想按照预定的比较方式去比较的情况</p></blockquote><p>Comparator类实现了Comparable接口。多数场景中使用 <em>匿名实现类</em> 的方式来创建，用完即。</p><div class="code-wrapper"><pre><code class="hljs java">Phone[] arr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Phone</span>[<span class="hljs-number">3</span>];arr[<span class="hljs-number">0</span>] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Phone</span>(<span class="hljs-string">&quot;小米14&quot;</span>, <span class="hljs-number">5999</span>);arr[<span class="hljs-number">1</span>] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Phone</span>(<span class="hljs-string">&quot;苹果15&quot;</span>, <span class="hljs-number">6999</span>);arr[<span class="hljs-number">2</span>] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Phone</span>(<span class="hljs-string">&quot;华为mate60&quot;</span>, <span class="hljs-number">6499</span>);Arrays.sort(arr, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Comparator</span>&lt;Phone&gt;() &#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">compare</span><span class="hljs-params">(Phone o1, Phone o2)</span> &#123;        <span class="hljs-keyword">return</span> o1.getPrice() - o2.getPrice();    &#125;&#125;);</code></pre></div><h2 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h2><blockquote><p>防止因为外部因素程序出错导致的程序终止。</p></blockquote><p>运行时异常：程序运行时发生的异常。RutimeException</p><p>编译时异常：程序编译时发生的异常。如果不处理则编译器无法生成字节码文件</p><p><strong>异常体系结构：</strong></p><p><img src="/../img/java/1596f5280a4724552da3f5de92c0c5bd.png"></p><p><strong>异常处理机制：</strong></p><p>主动抛异常：<code>throw new 异常类</code>;</p><p>交给调用者处理异常：<code>throws</code></p><p><strong><code>throws</code>和<code>throw</code>的区别</strong></p><p><code>throws</code>是用来处理异常，<code>throw</code>是用来新增异常的</p><p>经典面试题目：</p><div class="code-wrapper"><pre><code class="hljs java">main()&#123;  <span class="hljs-type">int</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> test(<span class="hljs-number">10</span>);  sout(result);&#125;function <span class="hljs-title function_">test</span><span class="hljs-params">(<span class="hljs-type">int</span> num)</span>&#123;  <span class="hljs-keyword">try</span> &#123;    <span class="hljs-keyword">return</span> num;  &#125; <span class="hljs-keyword">catch</span> (Exception e)&#123;    <span class="hljs-keyword">return</span> num--;  &#125; <span class="hljs-keyword">finally</span> &#123;    ++num;<span class="hljs-comment">//在num改变之前，原先num = 10的值已经存入栈帧，尽管后续num被改变，依旧return10</span>  &#125;&#125;<span class="hljs-comment">//考点：</span><span class="hljs-comment">//return的数会临时放在操作数栈里面。</span><span class="hljs-comment">//虽然数据已经入栈，但因为finally的原因，并不会立马执行return，但此时栈中数据已经存在</span><span class="hljs-comment">//后续改动不会影响已经入栈的值</span></code></pre></div><br/><h2 id="String体系"><a href="#String体系" class="headerlink" title="String体系"></a>String体系</h2><br/><h3 id="String"><a href="#String" class="headerlink" title="String"></a><strong>String</strong></h3><blockquote><p>jdk8.0之前底层使用char[]，jdk9.0之后使用byte[]</p></blockquote><p>String保存的是字符串常量，里面的值不能更改，每次更新String类，并不是在原先的值上做改动，而是在池中<strong>新增</strong>或者<strong>匹配</strong>已经存在改动后的值，由value指向它。<strong>实际上String类的更新，是更新它所指向的地址。</strong></p><p><strong>常量相加，看的是池，变量相加，看的是堆。</strong></p><p>涉及到变量加减，底层源码实际上使用了<code>StringBuilder</code>来进行拼接，最后调用了<code>StringBuilder</code>的<code>toString()</code>方法，而该方法会<code>new  String()</code>，新建了一个对象。</p><p>如果该变量加了<code>final</code>修饰，则该<strong>变量变成了常量</strong>。</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;abc&quot;</span>;<span class="hljs-type">String</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;123&quot;</span>;<span class="hljs-type">String</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> a + b;<span class="hljs-comment">//源码分析：在c这一步中：</span>StringBuilder sb=<span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();sb.apend(a);sb.apend(b);<span class="hljs-type">String</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> sb.toString();<span class="hljs-comment">//toString()方法会在池中创建一个新的对象</span><span class="hljs-comment">//在堆中新建了一个value[]对象，由c指向它。</span><span class="hljs-comment">//在池中新建了一个对象，用于存放拼接好的字符串，由value[]对象指向它。</span></code></pre></div><p><img src="/../img/java/719d7e0c5ac64eb1cd5833aa4322d5ce.png"></p><br/><h3 id="StringBuffer与StringBuilder"><a href="#StringBuffer与StringBuilder" class="headerlink" title="StringBuffer与StringBuilder"></a><strong>StringBuffer与StringBuilder</strong></h3><blockquote><p>jdk8.0之前底层使用char[]，jdk9.0之后使用byte[]</p><p>都继承于AbstractStringBuilder</p></blockquote><br/><p>**StringBuffer:**线程安全</p><p>**StringBuilder:**线程不安全</p><br/><p>以<code>StringBuilder</code>为例：</p><p><strong>内部属性：</strong></p><p><code>char[] value</code> -&gt; 储存字符序列，能存储多大的空间。</p><p><code>int count</code> -&gt; 实际存储字符的个数，类似<code>Sting</code>中的<code>length()</code>。</p><p><strong>构造器：</strong></p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">//空参，默认创造16大小的数组，</span><span class="hljs-keyword">public</span> <span class="hljs-title function_">StringBuilder</span><span class="hljs-params">()</span> &#123;    <span class="hljs-built_in">super</span>(<span class="hljs-number">16</span>); <span class="hljs-comment">// value = new byte[16]</span>&#125;<span class="hljs-comment">//带参数，初始化数组的大小</span><span class="hljs-keyword">public</span> <span class="hljs-title function_">StringBuilder</span><span class="hljs-params">(<span class="hljs-type">int</span> capacity)</span> &#123;    <span class="hljs-built_in">super</span>(capacity);<span class="hljs-comment">// value = new byte[capacity]</span>&#125;<span class="hljs-keyword">public</span> <span class="hljs-title function_">StringBuilder</span><span class="hljs-params">(String str)</span> &#123;    <span class="hljs-built_in">super</span>(str);<span class="hljs-comment">// value = new byte[str.length() + 16]</span>&#125;</code></pre></div><p><strong>如何体现可变性？</strong></p><p><code>char[] value</code>没有<code>final</code>修饰，因此在创建<code>StringBuilder</code>对象后，只需要<strong>改变<code>value</code>指向新的数组</strong>即可（<code>value = new char[capacity]</code>），不需要像<code>String</code>那样新建一个对象。</p><p>一旦<code>count</code>即将超过<code>value.length()</code>时，扩容。</p><p><code>ensureCapacityInternal()</code>方法中判断以及扩容</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">ensureCapacityInternal</span><span class="hljs-params">(<span class="hljs-type">int</span> minimumCapacity)</span> &#123;    <span class="hljs-comment">// overflow-conscious code</span>    <span class="hljs-type">int</span> <span class="hljs-variable">oldCapacity</span> <span class="hljs-operator">=</span> value.length &gt;&gt; coder;    <span class="hljs-keyword">if</span> (minimumCapacity - oldCapacity &gt; <span class="hljs-number">0</span>) &#123;        value = Arrays.copyOf(value,                newCapacity(minimumCapacity) &lt;&lt; coder);    &#125;&#125;</code></pre></div><p><strong>一些常用方法：</strong></p><p>-&gt;增：<code>append(&#39;xxx&#39;);</code></p><p>-&gt;删：<code>delete(int start , int ned);</code></p><p>​<code>deleteCharAt(int index);</code></p><p>-&gt;改：<code>replace(int start , int end);</code></p><p>​<code>setChartAt(int index , char c);</code></p><p>-&gt;查：<code>charAt(int index);</code></p><p>-&gt;插：<code>insert(int index ,xx);</code></p><p>-&gt;长度：<code>length();</code></p><p>-&gt;反转：<code>reverse();</code></p><br/><p><code>StringBuilder</code>默认为16字符串数组的容器，与<code>String</code>不同的是，他指向的地址可以保持不变，改变其中的值，而不改变地址。在超出容量之后，才会改变地址指向新增的扩容后的地址，他们都在堆中。</p><br/><p><code>String</code>与<code>StringBuilder</code>相互转换中，<code>append</code>方法与<code>StringBuilder</code>构造器方法的区别：</p><ul><li>apped方法添加空指针的字符串会<strong>手动拼接长度为4的null的字符数组</strong>。</li><li>利用构造器会<strong>判断传入字符串的长度</strong>，调用.length方法，会报空指针异常。</li></ul><table><thead><tr><th align="center"></th><th align="center">效率</th><th align="center">线程安全</th><th align="center">区别</th></tr></thead><tbody><tr><td align="center"><strong>String</strong></td><td align="center">低</td><td align="center">-</td><td align="center">改变的是地址而非值，复用性最高</td></tr><tr><td align="center"><strong>StringBuffer</strong></td><td align="center">中</td><td align="center">多线程安全</td><td align="center">改变值，在不超出容量的前提下不改变地址</td></tr><tr><td align="center"><strong>StringBuilder</strong></td><td align="center">高</td><td align="center">多线程不安全，适合单线程</td><td align="center">改变值，在不超出容量的前提下不改变地址</td></tr></tbody></table><br/><h2 id="集合体系"><a href="#集合体系" class="headerlink" title="集合体系"></a>集合体系</h2><blockquote><p>看到list想到动态数组，并且需要用<code>equals</code>来进行比较</p><p>看到set想到去重，并且需要<code>hashCode</code>和<code>equals</code>进行比较</p></blockquote><p><strong>java.util.Collection</strong>：存储一个个的数据</p><ul><li>子接口1：<code>List</code>存储有序、可重复的数据（动态数组）<ul><li>实现类：<code>ArrayList</code>、<code>LinkedList</code>、<code>Vector</code></li></ul></li><li>子接口2：<code>Set</code>存储无序、不可重复的数据<ul><li>实现类：<code>HashSet</code>、<code>LinkedHashSet</code>、<code>TreeSet</code></li></ul></li></ul><p><strong>java.util.Map</strong>：存储键值对</p><ul><li>实现类：<code>HashMap</code>、<code>LinkedHashMap</code>、<code>TreeMap</code>、<code>Hashtable</code>、<code>Properties</code></li></ul><br/><p><strong>只能存放引用数据类型，基本数据类型会自动装箱</strong></p><br/><h3 id="List接口"><a href="#List接口" class="headerlink" title="List接口"></a>List接口</h3><blockquote><p>底层为数组，会动态扩容。因为list有序，进而就有索引（从0开始）。因此在原collection包下拥有的15个方法外额外新增了属于list接口的方法</p></blockquote><p><strong>常用方法：</strong></p><ul><li>增：</li></ul><p><code>add(Object obj)</code>：此时默认在末尾添加。</p><p><code>add(Integer index, Object obj)</code>：在指定索引<code>index</code>位置处增加<code>obj</code>。</p><p><code>addAll(Collection coll)</code>：添加集合，将整个集合中的元素逐个添加</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">//注意：add和addAll的区别：</span><span class="hljs-type">ArrayList</span> <span class="hljs-variable">list</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>();list.add(<span class="hljs-string">&quot;a&quot;</span>);<span class="hljs-type">ArrayList</span> <span class="hljs-variable">list2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>();list2.add(<span class="hljs-number">1</span>);list2.add(<span class="hljs-number">2</span>);list2.add(<span class="hljs-number">3</span>);lsit.add(list2)<span class="hljs-comment">//list:[&quot;a&quot;,[1,2,3]] size = 2</span>list.addAll(list2)<span class="hljs-comment">//list:[&quot;a&quot;,1,2,3] size = 4</span></code></pre></div><ul><li>删：</li></ul><p><code>remove(Object obj)</code>：删除具体的对象，底层调用<code>contains</code>判断是否存在</p><p><code>remove(int index)</code>：删除指定索引的数，并返回此元素</p><p><code>clear()</code>：清空集合。将集合中指向依次指向null，再将size设置为0。</p><p><code>removeAll(Collection coll)</code>：从当前集合中删除所有与coll集合中相同的元素，即移除共同有的，为叉积</p><p><code>retainAll(Collection coll)</code>：从当前集合中删除两个集合中不同的元素，即交集</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">//删除索引为2的元素</span>remove(<span class="hljs-number">2</span>);<span class="hljs-comment">//删除数据为2的元素</span>remove(Integer.valueOf(<span class="hljs-number">2</span>));</code></pre></div><ul><li>改：</li></ul><p><code>set(int index,Object obj)</code>：根据索引来更改</p><ul><li>查：</li></ul><p><code>get(int index)</code>：根据索引来查</p><p><code>contains()</code>：是否包含该元素，注意此处比较的是<code>equals</code>，而非<code>hashcode</code>，根据add的顺序逐个进行<code>equals</code>比较</p><p><code>indexOf(Object obj)</code>：返回<code>obj</code>在集合中首次出现的位置</p><p><code>subList(int fromIndex, int toIndex)</code>：返回从<code>fromIndex</code>到<code>toIndex</code>位置的子集合（左闭右开）</p><ul><li>长度：</li></ul><p><code>size()</code></p><ul><li>遍历：</li></ul><p><code>iterator()</code>：迭代器</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">//迭代器说明</span><span class="hljs-type">List</span> <span class="hljs-variable">list</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>();list.add(<span class="hljs-string">&quot;1&quot;</span>);list.add(<span class="hljs-string">&quot;2&quot;</span>);list.add(<span class="hljs-string">&quot;3&quot;</span>);<span class="hljs-type">Iterator</span> <span class="hljs-variable">iterator</span> <span class="hljs-operator">=</span> list.iterator();<span class="hljs-keyword">while</span>(iterator.hasNext())&#123;<span class="hljs-comment">//iterator.hasNext()判断下一个数是否存在，是返回true，否则false</span>  iterator.next();<span class="hljs-comment">//返回当前指针所指向的数，并将指针指向下一个数。</span>&#125;</code></pre></div><ul><li>比较：</li></ul><p><code>contains(Object obj)</code>：是否包含该数值内容。按照list的添加顺序依次比较，是<code>equals</code>比较，而非比较地址。</p><ul><li>与数组的互相转换：</li></ul><p>数组转集合：<code>Arrays.asList(Object... obj)</code></p><p>集合转数组：<code>toArray()</code></p><p>经典面试题：</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-type">int</span>[] arr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>&#125; <span class="hljs-comment">//基本数据类型</span><span class="hljs-type">List</span> <span class="hljs-variable">list</span> <span class="hljs-operator">=</span> Arrays.asList(arr)list.size()<span class="hljs-comment">//1</span>sout.list<span class="hljs-comment">//打印出来是对象的地址</span>Integer[] arr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Integer</span>[]&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>&#125; <span class="hljs-comment">//引用数据类型</span><span class="hljs-type">List</span> <span class="hljs-variable">list</span> <span class="hljs-operator">=</span> Arrays.asList(arr)list.size()<span class="hljs-comment">//3</span>sout.list<span class="hljs-comment">//[1,2,3]</span></code></pre></div><br/><p><strong>ArrayList、LinkedList、Vector的区别</strong></p><p>-&gt;<code>ArrayList</code>：list接口的主要实现类，效率高，线程不安全，底层使用<code>Object[]</code>数组存储。在添加数据、查找数据时效率高，在插入、删除数据时，效率较低。</p><p>-&gt;<code>LinkedList</code>：底层使用双向链表的方式存储，在插入、删除数据是效率高，在添加、查找时效率较低，适合需要对数据频繁改动时使用。</p><p>-&gt;<code>Vector</code>：线程安全的，效率低，底层使用<code>Object[]</code>数组存储，不建议使用</p><br/><h3 id="Set接口"><a href="#Set接口" class="headerlink" title="Set接口"></a>Set接口</h3><blockquote><p>大多数使用场景为去重…</p></blockquote><p>方法与<code>list</code>接口中的方法相同。</p><br/><p>特点：</p><ul><li><strong>什么是无序性？</strong></li></ul><p>不等于随机性，与元素添加进来的位置有关，该元素所在的位置并非依次紧密排列的，而是根据元素的哈希值来确定位置。此为无序性。</p><ul><li><strong>什么是不可重复性？</strong></li></ul><p>添加到<code>set</code>中的元素是不可以相同的。</p><p><img src="/../img/java/fc5d88bc104e9822e57e6334f41f439b.png"></p><p><em>图注：</em></p><p><em>此处table就是set存储中hash表。</em></p><p><em>Hash为通过<code>hashCode()</code>得到的hash值</em></p><br/><h4 id="HashSet"><a href="#HashSet" class="headerlink" title="HashSet"></a>HashSet</h4><blockquote><p>底层使用的是HashMap，key为该数据，value指向统一的对象(new Object)。即数组+单向链表+红黑树的结构进行存储</p></blockquote><p>本质是一个数组链表（相邻表）。<strong>不可添加相同的数据</strong>，并且数据在表中排序与数据添加<strong>先后顺序无关</strong>，与该数据的Hash值有关，且输出顺序固定。</p><br/><p><strong>添加过程是什么？以及添加新元素时，如何验证该元素是否存在的？</strong></p><ul><li>将(key1,value1)添加到map中。</li></ul><ol><li>首先需要调用<code>key1</code>所在类的<code>hashCode()</code>得到<code>key1</code>的hash值<code>hash1</code>。</li><li>再将得到的<code>hash1</code>经过<code>hash()</code>算法得到<code>hash2</code>。</li><li>再将得到的<code>hash2</code>经过<code>indexFor()</code>算法，就可以得到(key1,value1)在数组table中索引<code>i</code>的位置。</li><li>判断此时数组索引<code>i</code>位置上是否有元素？<ol><li>如果此索引<code>i</code>上没有元素，则（key1，value1）添加成功。</li><li>如果此索引<code>i</code>上有元素（key2，value2）。     ——-&gt;<strong>哈希冲突</strong><ol><li>如果<code>key1</code>的<code>hash2</code>与<code>key2</code>的<code>hash2</code>值不相同，则（key1，value1）添加成功。与旧元素形成单向链表表（头插法，新元素放在首位，其余元素后移）</li><li>如果<code>key1</code>的<code>hash2</code>与<code>key2</code>的<code>hash2</code>值相同，则继续比较<code>equals()</code>。<ol><li>调用<code>key1</code>所在类的<code>equals()</code>方法，将<code>key2</code>作为参数传入，如果结果返回为false，则（key1，value1）添加成功。同上。</li><li>否则，<code>key1</code>与<code>key2</code>为相同，默认情况下，<code>value2</code>替换为<code>value1</code>。</li></ol></li></ol></li></ol></li></ol><p><img src="/../img/java/fc5d88bc104e9822e57e6334f41f439b.png"></p><ol><li>如上图Dog添加到表中，优先将Dog对象的值根据hashCode算法算出Hash值。</li><li>再根据Hash值匹配table序列，如果匹配到的序列中没有存放值，则直接添加到首位，否则继续一次匹配该序列中该对象和链表中的每一个值（此处调用equals）是否相同。</li></ol><br/><br/><p><strong>注意事项：</strong></p><ol><li>新增值时，可以手动重写该对象的HashCode方法和Equals方法，人为控制哪些元素是否是相同的</li><li>HashSet的table表默认长度为16，但并不会等填满16个元素 之后才扩容，而是在总长度*0.75个长度单位时就会以2倍总长度扩容，并在下次达到临界值（x0.75）时继续扩容，例如：16（12）-&gt;32（24）-&gt;64（48）-&gt;…</li><li>如果一条链表的元素个数超过8，并且table的总长度&gt;&#x3D;64，才会进行树化（红黑树）</li><li>对于添加<code>null</code>时，由于<code>HashMap</code>允许key为<code>null</code>，因此HashSet也允许元素为<code>null</code>。</li><li>对于添加多个<code>null</code>时，因为<code>null</code>不是一个对象，因此它没有对应的<code>hashCode()</code>或<code>equals()</code>方法，无法按照上述检测重复。当添加一个<code>null</code>元素时，HashMap会将这个<code>null</code>键映射到一个特定的桶（<code>bucket</code>）。当后续你试图再添加<code>null</code>时，HashMap会根据它的实现，检测到这个<code>null</code>键已经映射到了特定的桶，因此不接受重复的键，也就是不接受重复的<code>null</code>。</li></ol><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">//面试题</span><span class="hljs-comment">//Phone 类</span><span class="hljs-keyword">class</span> <span class="hljs-title class_">Phone</span>&#123;    <span class="hljs-keyword">private</span> String name;    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> price;    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Phone</span><span class="hljs-params">(String name, <span class="hljs-type">int</span> price)</span> &#123;        <span class="hljs-built_in">this</span>.name = name;        <span class="hljs-built_in">this</span>.price = price;    &#125;    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getName</span><span class="hljs-params">()</span> &#123;        <span class="hljs-keyword">return</span> name;    &#125;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setName</span><span class="hljs-params">(String name)</span> &#123;        <span class="hljs-built_in">this</span>.name = name;    &#125;    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getPrice</span><span class="hljs-params">()</span> &#123;        <span class="hljs-keyword">return</span> price;    &#125;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setPrice</span><span class="hljs-params">(<span class="hljs-type">int</span> price)</span> &#123;        <span class="hljs-built_in">this</span>.price = price;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span> &#123;        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Phone&#123;&quot;</span> +                <span class="hljs-string">&quot;name=&#x27;&quot;</span> + name + <span class="hljs-string">&#x27;\&#x27;&#x27;</span> +                <span class="hljs-string">&quot;, price=&quot;</span> + price +                <span class="hljs-string">&#x27;&#125;&#x27;</span>;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">equals</span><span class="hljs-params">(Object o)</span> &#123;        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span> == o) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;        <span class="hljs-keyword">if</span> (o == <span class="hljs-literal">null</span> || getClass() != o.getClass()) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;        <span class="hljs-type">Phone</span> <span class="hljs-variable">phone</span> <span class="hljs-operator">=</span> (Phone) o;        <span class="hljs-keyword">return</span> price == phone.price &amp;&amp; Objects.equals(name, phone.name);    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">hashCode</span><span class="hljs-params">()</span> &#123;        <span class="hljs-keyword">return</span> Objects.hash(name, price);    &#125;&#125;HashSet&lt;Phone&gt; set = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;();<span class="hljs-type">Phone</span> <span class="hljs-variable">p1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Phone</span>(<span class="hljs-string">&quot;小米14&quot;</span>, <span class="hljs-number">5999</span>);<span class="hljs-type">Phone</span> <span class="hljs-variable">p2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Phone</span>(<span class="hljs-string">&quot;苹果15&quot;</span>, <span class="hljs-number">6999</span>);set.add(p1);set.add(p2);p1.setPrice(<span class="hljs-number">6499</span>);set.remove(p1);<span class="hljs-comment">//remove操作之前，会先调用contains()判断是否存在。set中存放的p1是没有更改属性时计算得到的hash值</span>              <span class="hljs-comment">//而后续p1更改了属性值，此时计算p1时得到的hash值与set中存放p1的hash值不一致</span>              <span class="hljs-comment">//因此没有找到更改值后的p1，即没有成功删除。</span>              set.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Phone</span>(<span class="hljs-string">&quot;小米14&quot;</span>, <span class="hljs-number">6499</span>));<span class="hljs-comment">//此处成功添加进去。add同样也会先调用contains()判断是否存在</span>                                  <span class="hljs-comment">//此处添加的hash值与p1的hash值不一样！尽管p1的属性后续被更改，但是hash值在</span>                                  <span class="hljs-comment">//p1第一次添加时已经确定。即可以添加进去</span>        set.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Phone</span>(<span class="hljs-string">&quot;小米14&quot;</span>, <span class="hljs-number">5999</span>));<span class="hljs-comment">//此处成功添加。add同样也会先调用contains()判断是否存在</span>                                  <span class="hljs-comment">//此处添加的hash值与p1的hash值一样！但是equals()比较得到的值不一样！</span>                                  <span class="hljs-comment">//因为p1的属性(价格)已经被改动。即可以添加进去</span></code></pre></div><br/><h4 id="LinkedHashSet"><a href="#LinkedHashSet" class="headerlink" title="LinkedHashSet"></a>LinkedHashSet</h4><blockquote><p>是HashSet的子类，即在现有的数组+单向链表+红黑树结构的基础上，又添加了一组双向链表，用于记录添加元素的先后顺序。可以按照添加元素的先后顺序进行遍历，便于频繁的查询操作</p></blockquote><p>与HashSet添加方式相同，区别在于多了一组双向链表，用来记录加入的顺序。因此遍历时可以按照添加顺序依次遍历。</p><table><thead><tr><th></th><th>HashSet</th><th>LinkedHashSet</th></tr></thead><tbody><tr><td>特点</td><td>根据hash值进行遍历</td><td>根据添加顺序进行遍历（依旧体现无序性）</td></tr></tbody></table><br/><h4 id="TreeSet"><a href="#TreeSet" class="headerlink" title="TreeSet"></a>TreeSet</h4><blockquote><p>底层使用红黑树存储。必须实现了comparable接口或者给予比较器。可以按照添加元素指定的顺序进行遍历</p></blockquote><p>特点：</p><ol><li>可以按照添加元素的<strong>指定属性大小</strong>进行顺序遍历。</li><li><strong>添加的元素必须是同一类元素</strong>。在添加一个新的元素后，会拿新添加的元素和之前的存放的值进行比较，<strong>添加的谁，就拿谁的比较器去和前面的比较</strong>。</li><li>不能存在相同的元素，是否相同<strong>取决于比较器的比较方法</strong>，只会保留第一次遇到的元素，后面遇到的相同的元素都不会存入。</li><li><code>contain()</code>与<code>remove()</code>方法同样取决于比较<strong>两个元素的比较器</strong>返回值是否为0。</li></ol><br/><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * 使用自然排序</span><span class="hljs-comment"> **/</span><span class="hljs-keyword">class</span> <span class="hljs-title class_">Phone</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Comparable</span> &#123;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 按照价格-&gt;名称 从低到高排序*</span><span class="hljs-comment">     *</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> o</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 0：相同l  大于0：当前对象大  小于0：当前对象小</span><span class="hljs-comment">     */</span>    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">compareTo</span><span class="hljs-params">(Object o)</span> &#123;        <span class="hljs-keyword">if</span> (o == <span class="hljs-built_in">this</span>) &#123;            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;        &#125;        <span class="hljs-keyword">if</span> (o <span class="hljs-keyword">instanceof</span> Phone phone) &#123;            <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.price - phone.price == <span class="hljs-number">0</span> ? <span class="hljs-built_in">this</span>.name.compareTo(phone.name) : <span class="hljs-built_in">this</span>.price - phone.price;        &#125;        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<span class="hljs-string">&quot;类型不匹配&quot;</span>);    &#125;    <span class="hljs-keyword">private</span> String name;    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> price;    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Phone</span><span class="hljs-params">(String name, <span class="hljs-type">int</span> price)</span> &#123;        <span class="hljs-built_in">this</span>.name = name;        <span class="hljs-built_in">this</span>.price = price;    &#125;&#125;<span class="hljs-type">TreeSet</span> <span class="hljs-variable">treeSet</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeSet</span>();treeSet.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Phone</span>(<span class="hljs-string">&quot;小米14&quot;</span>, <span class="hljs-number">5999</span>));treeSet.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Phone</span>(<span class="hljs-string">&quot;苹果15&quot;</span>, <span class="hljs-number">6999</span>));treeSet.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Phone</span>(<span class="hljs-string">&quot;华为mate60&quot;</span>, <span class="hljs-number">6499</span>));<span class="hljs-comment">/**</span><span class="hljs-comment"> * 使用定制排序 </span><span class="hljs-comment"> **/</span><span class="hljs-type">TreeSet</span> <span class="hljs-variable">treeSet</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeSet</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Comparator</span>() &#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">compare</span><span class="hljs-params">(Object o1, Object o2)</span> &#123;        <span class="hljs-keyword">if</span> (o1 <span class="hljs-keyword">instanceof</span> Phone &amp;&amp; o2 <span class="hljs-keyword">instanceof</span> Phone) &#123;            <span class="hljs-type">Phone</span> <span class="hljs-variable">p1</span> <span class="hljs-operator">=</span> (Phone) o1;            <span class="hljs-type">Phone</span> <span class="hljs-variable">p2</span> <span class="hljs-operator">=</span> (Phone) o2;            <span class="hljs-keyword">return</span> p1.getPrice() - p2.getPrice() == <span class="hljs-number">0</span> ?              p1.getName().compareTo(p2.getName()) : p1.getPrice() - p2.getPrice();        &#125;        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<span class="hljs-string">&quot;类型不匹配&quot;</span>);    &#125;&#125;);treeSet.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Phone</span>(<span class="hljs-string">&quot;小米14&quot;</span>, <span class="hljs-number">5999</span>));treeSet.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Phone</span>(<span class="hljs-string">&quot;苹果15&quot;</span>, <span class="hljs-number">6999</span>));treeSet.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Phone</span>(<span class="hljs-string">&quot;华为mate60&quot;</span>, <span class="hljs-number">6499</span>));</code></pre></div><br/><h3 id="Map接口"><a href="#Map接口" class="headerlink" title="Map接口"></a>Map接口</h3><blockquote><p>由key - value 构成的键值对存储格式</p></blockquote><p>以HashMap为例</p><p><code>key</code>：不可以重复，无序性，所有的<code>key</code>构成一个<code>Set</code>集合，所在类需要重<code>hashcode()</code>和<code>equals()</code>方法；</p><p><code>value</code>：可重复，无序性，所有的<code>value</code>构成一个<code>Collection</code>集合，所在类需要重写<code>equals()</code>方法；</p><p>在Map中，存放的数据实际上是一个个数据，并非直观上的一对对数据。这里的<code>key</code>和<code>value</code>实际上是<code>Map.Entry</code>(<code>jdk8</code>以上为<code>Map.Node</code>)的两个属性。Map存放的是一个个<code>Map.Entry</code>。</p><p><code>key</code>和<code>value</code>构成一个<code>entry</code>。所有的<code>entry</code>彼此之间也是无序的，不可重复的，及也为<code>Set</code>。</p><br/><p>HashMap的源码刨析：<a href="/2024/03/10/JDK7%E4%B8%8EJDK8-HashMap%E6%BA%90%E7%A0%81%E5%88%A8%E6%9E%90">HashMap的源码刨析</a></p><p><br/><strong>常用方法：</strong></p><ul><li>增：</li></ul><p><code>put(Object key ,Object value)</code>：</p><p><code>putAll(Map m)</code>：将m中所有的<code>key-value</code>存放到当前map中；</p><ul><li>删：</li></ul><p><code>remove(Object key)</code>：返回被删除的value；</p><ul><li>改：</li></ul><p><code>put(Object key ,Object value)</code>：返回更改之前的value；</p><p><code>putAll(Map m)</code>：</p><ul><li>查：</li></ul><p><code>get(Object key)</code>：返回value；</p><p><code>containsKey(Object key)</code>：查找是否包含指定的<code>key</code>，返回<code>boolean</code>；</p><p><code>containsValue(Object value)</code>：查找是否包含指定的<code>value</code>，返回<code>boolean</code>；</p><ul><li>长度：</li></ul><p><code>size()</code>:</p><ul><li>遍历：</li></ul><p><code>keySet()</code>：返回<code>key</code>集，数据类型为<code>Set</code>；</p><p><code>values()</code>：返回<code>value</code>集，数据类型为<code>Collection</code>；</p><p><code>entrySet()</code>：返回<code>entry</code>集，数据类型为<code>Set</code>；</p><br/><h4 id="HashMap、Hashtable与LinkedHashMap"><a href="#HashMap、Hashtable与LinkedHashMap" class="headerlink" title="HashMap、Hashtable与LinkedHashMap"></a>HashMap、Hashtable与LinkedHashMap</h4><blockquote><p>HashMap常用，Hashtable线程安全且古老，LinkedHashMap基于HashMap，可以保留添加顺序</p></blockquote><p>参考HashSet</p><p><strong>LinkedHashMap:</strong></p><p>是HashMao的子类；在HashMap使用的数据结构基础上，增加了一对双向链表，用于记录添加元素的先后顺序，即遍历时可以根据添加顺序遍历，适合频繁的遍历操作时使用。</p><br/><p><strong>HashMap与Hashtable的区别</strong></p><table><thead><tr><th align="center"></th><th align="center">版本</th><th align="center">线程同步</th><th align="center">效率</th><th align="center">允许null键和值</th><th align="center">扩容</th><th align="center">初始容量</th></tr></thead><tbody><tr><td align="center"><strong>HashMap</strong></td><td align="center">1.2</td><td align="center">不同步</td><td align="center">高</td><td align="center">是</td><td align="center">2倍</td><td align="center">16（12）</td></tr><tr><td align="center"><strong>HashTable</strong></td><td align="center">1.0</td><td align="center">同步</td><td align="center">低</td><td align="center">否</td><td align="center">2倍+1</td><td align="center">11（8）</td></tr></tbody></table><br/><h4 id="TreeMap"><a href="#TreeMap" class="headerlink" title="TreeMap"></a>TreeMap</h4><blockquote><p>底层使用红黑树存储，可以按照添加的key的属性的大小顺序进行遍历</p></blockquote><br/><br/><h4 id="Properties"><a href="#Properties" class="headerlink" title="Properties"></a>Properties</h4><blockquote><p>是Hashtable的子类，key 和 value都为string类型，常用于配置文件</p></blockquote><p><code>load(File file)</code>：加载流中的文件中的数据；</p><p><code>getProperty(String str)</code>：类似于Map中的<code>get()</code>，根据<code>key</code>读取<code>value</code>；</p><br/><h3 id="Collections集合工具类"><a href="#Collections集合工具类" class="headerlink" title="Collections集合工具类"></a>Collections集合工具类</h3><blockquote><p>collection是储存一个个元素的接口，又分为list，set子接口</p><p>collections是一个操作list，set，map的集合工具类，类似Arrays数组工具类</p></blockquote><ul><li><strong>排序：</strong></li></ul><p><code>reverse(Lisy)</code>：反转List中元素的顺序；</p><p><code>suffle(List)</code>：对List集合元素进行随机排序；</p><p><code>sort(List ,Comparator)</code>：指定排序顺序、不填比较器时默认自然排序；</p><p><code>swap(List,i,j)</code>：将指定List集合中i处元素与j处元素进行交换；</p><ul><li><strong>查找：</strong></li></ul><p><code>max(Collection)</code>：根据自然排序（一般默认为从小到大），取排序后最后一个数（最右边）；</p><p><code>max(Collection,Comparator)</code>：根据定制排序，取排序后最后一个数（最右边）；</p><p><code>min(Collection)</code>：根据自然排序（一般默认为从小到大），取排序后第一个数（最左边）；</p><p><code>min(Collection,Comparator)</code>：根据定制排序，取排序后第一个数（最左边）；</p><p><code>frequency(Collection,Object)</code>：返回集合中指定元素出现的次数；</p><ul><li><strong>复制与只读：</strong></li></ul><p><code>copy(List dest,List src)</code>：将src的集合复制到dest中。<strong>注意：此处的dest的size必须要大于等于src的size</strong>；</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-type">List</span> <span class="hljs-variable">src</span> <span class="hljs-operator">=</span> Arrays.asList(<span class="hljs-number">45</span>,<span class="hljs-number">43</span>,<span class="hljs-number">65</span>,<span class="hljs-number">6</span>,<span class="hljs-number">43</span>,<span class="hljs-number">2</span>,<span class="hljs-number">32</span>,<span class="hljs-number">45</span>,<span class="hljs-number">56</span>,<span class="hljs-number">34</span>,<span class="hljs-number">23</span>);<span class="hljs-comment">//错误写法：</span><span class="hljs-type">List</span> <span class="hljs-variable">dest</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>();Collections.copy(dest,src);<span class="hljs-comment">//IndexOutOfBoundsException</span><span class="hljs-comment">//正确写法：</span><span class="hljs-type">List</span> <span class="hljs-variable">dest</span> <span class="hljs-operator">=</span> Arrays.asList(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[src.size()]);Collections.copy(dest,src);</code></pre></div><p><code>unmodifiableList(List)</code>：该方法返回指定的List不可修改的视图，即无法添加新的元素以及删除元素，只读。</p><ul><li><strong>同步：</strong></li></ul><p><code>synchronizedList(List)</code>：该方法返回指定的List线程同步的集合。</p><br/><h2 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h2><p><strong>进程（process）</strong>：程序的一次执行过程，例如运行中的App。</p><ul><li>每一个进程都有一个<strong>独立的内存空间</strong>，系统运行一个程序即是一个进程从创建、运行到消亡的过程（生命周期）。</li><li>进程为<strong>操作系统调度和分配资源的最小单位</strong>(亦是系统运行的基本单位)</li></ul><p><strong>线程（thread）</strong>：是程序内部的一条执行路径，一个进程中至少包含一个线程。</p><ul><li>当一个进程同一时间并行执行多个线程，那么这个进程就是多线程的。</li><li>线程作为<strong>CPU调度和执行的最小单位</strong>。</li><li>一个进程中的多个线程<strong>共享内存单元</strong>，他们从同一个堆中分配对象，可以访问相同的变量和对象。这使得线程通讯更加简便高效，但也带来安全隐患。</li></ul><p><img src="/../img/java/925dc771ef10f61d983cc683a11e0c5a.png"></p><p>上图中红色框框即可代表一个进程（也可以代表jvm实例），不同的线程在该进程中共享方法区、堆。</p><p><strong>不同的进程之间是不共享内存的，它们之间的数据交换和通信成本很高</strong>。</p><br/><h3 id="线程创建方式"><a href="#线程创建方式" class="headerlink" title="线程创建方式"></a>线程创建方式</h3><p><strong>1、继承方式（继承Thread类）</strong></p><ol><li>创建一个继承于<code>Thread</code>类的子类。</li><li>重写<code>Thread</code>类的<code>run()</code>方法，方法内写需要执行的操作。</li><li>创建该子类的对象，通过对象调用<code>start()</code>方法。</li></ol><p>注：<code>start()</code>方法会开启线程，并且调用线程的<code>run()</code>方法，直接执行<code>run()</code>方法并不会开启多线程。 </p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">//方式2: 创建Thread类的匿名子类的匿名对象。</span><span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>()&#123;  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;  &#125;.start();</code></pre></div><p><strong>2、接口方式（实现Runnable接口）</strong></p><ol><li>创建一个实现<code>runnable</code>接口的类。</li><li>重写接口中的<code>run()</code>方法。</li><li>创建该实现类的对象。</li><li>将此对象作为参数传递到Thread类的构造器中，创建<code>Thread</code>类的实例。</li><li><code>Thread</code>类的实例调用<code>start()</code>方法。</li></ol><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">//方式2：使用Runnable接口的匿名实现类的匿名对象</span><span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Runnable</span>()&#123;  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span>&#123;      &#125;&#125;).start();</code></pre></div><p><strong>两种方式对比：</strong></p><p>推荐使用<code>runnable</code>接口的方式，有利于数据的共享。（只需要创建一个实现<code>runnable</code>接口的对象）、</p><p><strong>二者联系：</strong></p><p>第一种继承Thread方法，本质上Thread类实现了Runnable接口</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Thread</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span> (代理模式)</code></pre></div><p><strong>3、实现callable接口</strong></p><ol><li>创建一个实现<code>callable</code>接口并重写了<code>run</code>方法的对象。</li><li>将此对象作为参数传递到<code>FutureTask</code>类中，并创建该类的对象。</li><li>将此对象作为参数传递到<code>Thread</code>类中，并创建该类的对象。</li><li><code>Thread</code>类的实例调用<code>start()</code>方法。</li><li>如需得到返回值，需要调用<code>FutureTask</code>对象的<code>get()</code>方法，得到返回值。</li></ol><p><code>callable</code>特别之处：有返回值、可以通过<code>throws</code>抛出异常；比起第二种多了创建<code>FutureTask</code>对象；<code>FutureTask</code>的<code>get()</code>方法在那个线程被调用，哪个线程会进入阻塞。</p><br/><p><strong>4、线程池的方式</strong></p><p><strong>现有问题：</strong></p><p>如果并发的线程数量很多，并且每个线程都是执行一个时间很短的任务就结束了，这样频繁创建线程就会大大降低系统的效率，因为频繁创建线程和销毁线程需要时间。那么有没有一种办法使得线程可以复用，即执行完一个任务，并不被销毁，而是可以继续执行其他的任务?</p><p><strong>思路：</strong></p><p>提前创建好多个线程，放入线程池中，使用时直接获取，使用完放回池中。可以避免频繁创建销毁、实现重复利用。类似生活中的公共交通工具。</p><p><strong>优点：</strong></p><ol><li>提高了程序执行效率（线程已经提前创建好了）</li><li>提高了资源的复用率（执行完毕的线程并未销毁，而是归还，后续可以继续使用）</li><li>可以设置相关参数，维护性好，对线程池中的线程使用进行管理</li></ol><br/><br/><p><img src="/../img/java/e007eb0d0e01fdc572f5f02d0b2aeb5b.png"></p><h3 id="线程的常用方法"><a href="#线程的常用方法" class="headerlink" title="线程的常用方法"></a>线程的常用方法</h3><p>**<code>yield()</code>**：主动释放cpu的执行权。</p><p>**<code>join()</code>**：进入阻塞状态。a线程中调用<code>b线程.join()</code>，则a线程进入阻塞，等待b线程完成后再走a线程。</p><p>**<code>isAlive()</code>**：判断该线程是否存活，返回boolean值。</p><p>**<code>getPriority()/setPriority()</code>**：获取&#x2F;设置线程优先级。正常优先级为5，范围为（1~10）;</p><p><strong><code>wait()</code><strong>：线程进入等待状态，同时</strong>释放同步监视器</strong>；调用者必须是同步监视器</p><p><strong><code>sleep()</code><strong>：线程进入等待状态，但</strong>不会释放同步监视器</strong>;</p><p>**<code>notify()</code>**：随机唤醒监视器里一个等待的线程；调用者必须是同步监视器</p><br/><br/><h3 id="线程的生命周期"><a href="#线程的生命周期" class="headerlink" title="线程的生命周期"></a>线程的生命周期</h3><p><img src="/../img/java/efbc03de006e41ace09f7f3d078e5774.png"></p><br/><br/><h3 id="如何解决线程安全问题？"><a href="#如何解决线程安全问题？" class="headerlink" title="如何解决线程安全问题？"></a>如何解决线程安全问题？</h3><blockquote><p>使用线程的同步机制</p></blockquote><ol><li><p><strong>同步代码块</strong></p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">synchronized</span>(同步监视器)&#123;  <span class="hljs-comment">//需要被同步的代码</span>&#125;</code></pre></div><p>说明：</p><p>需要被同步的代码，即为操作共享数据的代码。</p><p>共享数据：即多个线程都需要操作的数据，比如票数量。</p><p>需要被同步的代码，在被<code>synchronized</code>包裹后，就使得一个线程在操作这些代码的过程中，其他线程必须等待。</p><p>同步监视器：俗称锁，哪个线程获得了锁，哪个线程就能执行需要被同步的代码。它可以是任意一个类的对象充当，但是多个线程必须共用同一个同步监视器。通过接口实现的线程可以用<code>this</code>，通过继承实现的线程可以用<code>类名.class</code></p></li><li><p><strong>同步方法</strong></p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">show</span><span class="hljs-params">()</span>&#123; <span class="hljs-comment">//此时的默认监视器为this</span>  <span class="hljs-comment">//需要被同步的代码</span>&#125;</code></pre></div><p>说明：</p><p>无论是哪种方式创建的多线程，用此方法时，**默认监视器都为<code>this</code>**。</p><p>如果为接口方式创建的线程，此时<code>this</code>是唯一的，但如果是继承方式创建的线程，此时<code>this</code>不一定唯一。可以考虑的方式为：<strong>将该方法提升为静态方法</strong>，具体问题还得看逻辑适不适合。</p><p>使用继承方式创建的线程不建议使用该方式达成同步目的。</p></li><li><p><strong>使用<code>lock</code></strong></p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">//1.创建Lock的实例，需确保多个线程共用一个Lock实例</span><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReentrantLock</span>();<span class="hljs-comment">//2.执行lock()方法，锁定</span><span class="hljs-keyword">try</span>&#123;  lock.lock();  &#125;<span class="hljs-keyword">finally</span>()&#123;<span class="hljs-comment">//确保释放一定被执行</span>    <span class="hljs-comment">//3.unlock()调用，释放</span>    lock.unlock();  &#125;</code></pre></div><p>lock模式提供了更多更广泛的锁，适用更复杂的场景，并且效率高。</p></li></ol><br/><p>在一个线程start（）方法中，真正开启线程的并不是start（）方法里面的run（）方法，而是start0（），它是一个native本地方法，由JVM调用，底层是C&#x2F;C++实现的。</p><p><img src="/5542f47236383d1b2f3524fa9427bff4.png" alt="线程.png"></p><br/><br/><h2 id="File类与IO流"><a href="#File类与IO流" class="headerlink" title="File类与IO流"></a>File类与IO流</h2><h3 id="File类"><a href="#File类" class="headerlink" title="File类"></a>File类</h3><blockquote><p>File类的一个对象，对应操作系统下的一个文件或一个文件目录（文件夹）</p></blockquote><p>java中为了防止\编译（例如\n换行），通常使用<code>\\</code>或者<code>/</code>来代替路径中的\</p><p><strong>构造器</strong></p><p>1.以pathname为路径创建File对象，可以是绝对路径&#x2F;相对路径。</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-title function_">File</span><span class="hljs-params">(String pathname)</span>File file1=<span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(<span class="hljs-string">&quot;d:/io\\hello.txt&quot;</span>);<span class="hljs-comment">// 此为文件</span>File file2=<span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(<span class="hljs-string">&quot;abc&quot;</span>);<span class="hljs-comment">// 此为目录，且使用相对路径</span></code></pre></div><p>绝对路径：以windows操作系统为例，包括盘符在内的文件或文件目录的完整路径。</p><p>相对路径：以IDEA编译器为例，如果使用单元测试方法：相当于当前的moudle下。如果使用main()方法：相当于当前的project下。</p><p>如果分不清可以通过<code>File.getAbsolutePath()</code>方法来获取当前对象的绝对路径。</p><br/><p>2.以parent为父路径，此parent一定为文件目录，child为子路径创建File对象</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-title function_">File</span><span class="hljs-params">(string parent, String child)</span>File file1=<span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(<span class="hljs-string">&quot;d:/io\\abc&quot;</span>, <span class="hljs-string">&quot;cc&quot;</span>);<span class="hljs-comment">// 此为d:\io\abc目录下的cc目录</span></code></pre></div><br/><p>3.因为file对象还可以代表文件目录，根据一个父File对象和子文件路径创建File对象</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-title function_">File</span><span class="hljs-params">(File parent,String child)</span>File file1=<span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(<span class="hljs-string">&quot;abc&quot;</span>);<span class="hljs-comment">// 此为目录，且使用相对路径</span>File file2=<span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(file1, <span class="hljs-string">&quot;cc.txt&quot;</span>);</code></pre></div><p><strong>常用方法</strong></p><ul><li>获取文件和目录基本信息：</li></ul><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> String <span class="hljs-title function_">getName</span><span class="hljs-params">()</span>：获取名称。<span class="hljs-keyword">public</span> String <span class="hljs-title function_">getPath</span><span class="hljs-params">()</span>：获取路径。<span class="hljs-keyword">public</span> String <span class="hljs-title function_">getAbsolutePath</span><span class="hljs-params">()</span>：获取绝对路径。<span class="hljs-keyword">public</span> File <span class="hljs-title function_">getAbsoluteFile</span><span class="hljs-params">()</span>：获取绝对路径表示的文件。<span class="hljs-keyword">public</span> String <span class="hljs-title function_">getParent</span><span class="hljs-params">()</span>：获取上层文件目录路径。若无，返回<span class="hljs-literal">null</span>。<span class="hljs-keyword">public</span> Long <span class="hljs-title function_">Length</span><span class="hljs-params">()</span>：获取文件长度（即：字节数）。不能获取目录的长度。<span class="hljs-keyword">public</span> Long <span class="hljs-title function_">LastModified</span><span class="hljs-params">()</span>：获取最后一次的修改时间，毫秒值。</code></pre></div><ul><li>列出自录的下一级：</li></ul><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> String[] list()：返回一个String数组，表示该File目录中的所有子文件或目录。<span class="hljs-keyword">public</span> File[] listFiles()：返回一个File数组，表示该File目录中的所有的子文件或目录。</code></pre></div><ul><li>判断功能的方法：</li></ul><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">exists</span><span class="hljs-params">()</span>：此File表示的文件或目录是否实际存在。<span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isDirectory</span><span class="hljs-params">()</span>：此File表示的是否为目录。<span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isFile</span><span class="hljs-params">()</span>：此File表示的是否为文件。<span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">canRead</span><span class="hljs-params">()</span>：判断是否可读。<span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">canWrite</span><span class="hljs-params">()</span>：判断是否可写。<span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isHidden</span><span class="hljs-params">()</span>：判断是否隐藏。</code></pre></div><ul><li>移动以及重命名：</li></ul><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">renameTo</span><span class="hljs-params">(File dest)</span>：将文件重命名到指定的文件路径。注：此处的dest对象文件必须不存在，    且dest对象文件的上级目录必须存在才会移动并重命名成功。</code></pre></div><ul><li>创建、删除功能：</li></ul><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">createNewFile</span><span class="hljs-params">()</span>：创建文件。若文件存在，则不创建，返回<span class="hljs-literal">false</span>。<span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">mkdir</span><span class="hljs-params">()</span>：创建文件目录。如果此文件目录的上层目录不存在也无法创建<span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">mkdirs</span><span class="hljs-params">()</span>：创建文件目录。如果上层文件目录不存在，一并创建。<span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">delete</span><span class="hljs-params">()</span>：删除文件或者文件夹删除注意事项：①Java中的删除不走回收站。              ②要删除一个文件目录，请注意该文件目录内不能包含文件或者文件目录。</code></pre></div><h3 id="IO流"><a href="#IO流" class="headerlink" title="IO流"></a>IO流</h3><blockquote><p>大部分数据传输通过流的形式完成</p></blockquote><table><thead><tr><th align="center"></th><th align="center">字节流</th><th align="center">字符流</th></tr></thead><tbody><tr><td align="center"><strong>输入流</strong></td><td align="center">InputStream</td><td align="center">Reader</td></tr><tr><td align="center"><strong>输出流</strong></td><td align="center">OutputStream</td><td align="center">Writer</td></tr></tbody></table><ul><li><p><strong>由这四个类派生出来的子类名称都是以其父类名作为子类名后缀。</strong></p><p><img src="/../img/java/12029432cd49fb1359cb1d9cdc562f35.png"></p></li></ul><p>字节流与字符流：</p><ul><li>字节流（8bit）二进制文件，通常保存声音，视频，图片，pdf，word等。</li><li>字符流，按照字符形式读取，适合读取文本信息。</li></ul><p>缓冲流：</p><p>在内存中建立缓存区，减少与磁盘的交互，提升文件的读写效率。在处理大型文件时建议使用</p><br/><p>节点流和处理流（包装流）：</p><ul><li>节点流是底层流，直接和数据源相连。</li><li>处理流，对节点流的一种包装，可以实现各种节点流，消除不同节点流的实现差异，采用了<strong>修饰器设计模式</strong>，体现了多态的特点。</li></ul><p><strong>案例：复制已知文件到目标文件</strong></p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-type">FileReader</span> <span class="hljs-variable">fr</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<span class="hljs-type">FileWriter</span> <span class="hljs-variable">fw</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<span class="hljs-keyword">try</span> &#123;    <span class="hljs-comment">//1.创建File对象</span>    <span class="hljs-type">File</span> <span class="hljs-variable">src</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(<span class="hljs-string">&quot;Hello.txt&quot;</span>);    <span class="hljs-type">File</span> <span class="hljs-variable">dest</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(<span class="hljs-string">&quot;Hello_copy.txt&quot;</span>);        <span class="hljs-comment">//2.创建输入输出流</span>    fr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileReader</span>(src);    fw = <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileWriter</span>(dest);        <span class="hljs-comment">//3.数据的读写</span>    <span class="hljs-type">char</span>[] cbuffer = <span class="hljs-keyword">new</span> <span class="hljs-title class_">char</span>[<span class="hljs-number">5</span>]; <span class="hljs-comment">//创建小车，用以减少与磁盘的交互次数。容量越大越占内存。</span>    <span class="hljs-type">int</span> len; <span class="hljs-comment">//记录每次读取到cbuffer中字符的个数。</span>    <span class="hljs-keyword">while</span> ((len = fr.read(cbuffer)) != -<span class="hljs-number">1</span>) &#123;        fw.write(cbuffer, <span class="hljs-number">0</span>, len); <span class="hljs-comment">//取目标从0开始到len长度的数据。</span>    &#125;&#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;    e.printStackTrace();&#125; <span class="hljs-keyword">finally</span> &#123;    <span class="hljs-comment">//4.流的关闭</span>    <span class="hljs-keyword">try</span> &#123;        <span class="hljs-keyword">if</span> (fr != <span class="hljs-literal">null</span>)            fr.close();    &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;        e.printStackTrace();    &#125;    <span class="hljs-keyword">try</span> &#123;        <span class="hljs-keyword">if</span> (fw != <span class="hljs-literal">null</span>)            fw.close();    &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;        e.printStackTrace();    &#125;&#125;</code></pre></div><p>注：写入操作必须要在close（）或者flush（）方法之后才会写入数据，否则只会将数据保存在内存中。</p><br/><p>序列化和反序列化：</p><ul><li>序列化：在保存数据时，保存数据的<strong>数据类型</strong>与值；</li><li>反序列化：在恢复数据时，恢复数据的<strong>数据类型</strong>与值；</li></ul><p>要实现序列化机制，必须实现以下两个接口之一：</p><ul><li>Serializable（标记接口，里面没有任何方法）</li><li>Externalizable</li></ul><br/><p>ObjectXXX在序列化和反序列化时的使用注意事项：</p><ol><li>读写顺序要一致。</li><li>要求序列化和反序列化，需要实现Serializable接口，其对象的引用属性也需要实现该接口。</li><li>序列化时候需要添加上SerialVersionUID属性。如果不声明，系统会自动为当前类生成一个SerialVersionUID，并且每次更新该类时SerialVersionUID会改变，无法做到作为唯一标识符的效果。（SerialVersionUID作用类似于hash值确定是否为同一个对象）</li><li>序列化对象时，默认将所有属性都进行序列化，有static和transient修饰的除外。因为static修饰的属性不属于某一个对象。</li><li>具备继承性。其子类也默认继承实现了Serialization接口。</li></ol><p>对象流有什么用？</p><p>-&gt;实际开发中很少使用对象进行传输，实际使用JSON字符串格式进行传输。需要掌握的是序列化和反序列化这个知识点。</p><br/><p>其他的一些流：</p><p>案例：记录日志文件</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/*</span><span class="hljs-comment">记录日志的方法。</span><span class="hljs-comment">*/</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">log</span><span class="hljs-params">(String msg)</span>&#123;  <span class="hljs-keyword">try</span>&#123;    <span class="hljs-comment">//指向一个日志文件</span>    <span class="hljs-type">PrintStream</span> <span class="hljs-variable">out</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">PrintStream</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileoutputStream</span>(<span class="hljs-string">&quot;log.txt&quot;</span>, <span class="hljs-literal">true</span>);    <span class="hljs-comment">//改变输出方向</span>    System.setout(out);    <span class="hljs-comment">//日期当前时间</span>    <span class="hljs-type">Date</span> <span class="hljs-variable">nowTime</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>();    <span class="hljs-type">SimpleDateFormat</span> <span class="hljs-variable">sdf</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SimpleDateFormat</span>( pattern:<span class="hljs-string">&quot;yyyy-MM-dd HH:mm:ss SSS&quot;</span>);    <span class="hljs-type">String</span> <span class="hljs-variable">strTime</span> <span class="hljs-operator">=</span> sdf.format(nowTime);    System.out.println(strTime +<span class="hljs-string">&quot;:&quot;</span>+ msg);  &#125;<span class="hljs-keyword">catch</span> （FileNotFoundException e）&#123;    e.printStackTrace();  &#125;&#125;<span class="hljs-comment">//测试工具类是否好用</span>Logger.log(<span class="hljs-string">&quot;调用了System类的gc()方法，建议启动垃圾回收&quot;</span>)；Logger.log(<span class="hljs-string">&quot;调用了TeamView的addMember()方法&quot;</span>);Logger.log(<span class="hljs-string">&quot;用户尝试进行登录，验证失败&quot;</span>)；</code></pre></div><h2 id="网络编程API"><a href="#网络编程API" class="headerlink" title="网络编程API"></a>网络编程API</h2><blockquote><p>抛出三个问题：</p><p>1.如何准确定位网络上的一台或多态主机？（ip地址）</p><p>2.如何定位主机上的特定的应用？（端口号）</p><p>3.找到主机后，如何高效可靠的进行数据传输？（规范网络通信协议）</p></blockquote><h3 id="InterAddress类"><a href="#InterAddress类" class="headerlink" title="InterAddress类"></a>InterAddress类</h3><blockquote><p>该对象的实例即代表一个具体的ip地址</p></blockquote><p><strong>实例化方式：</strong></p><p>官方不对外公开构造器，因此只能通过该类的静态方法来返回实例。</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">static</span> InetAddress <span class="hljs-title function_">getByName</span><span class="hljs-params">(String host)</span>：获取指定ip对应的InetAddress的实例<span class="hljs-keyword">static</span> InetAddress <span class="hljs-title function_">getLocaLHost</span><span class="hljs-params">()</span>：获取本地ip对应的InetAddress的实例</code></pre></div><p><strong>两个常用方法：</strong></p><div class="code-wrapper"><pre><code class="hljs java">getHostName();<span class="hljs-comment">//获取域名</span>getHostAddresss();<span class="hljs-comment">//获取ip地址</span></code></pre></div><h3 id="Socket类"><a href="#Socket类" class="headerlink" title="Socket类"></a>Socket类</h3><blockquote><p>套接字，由网络上具有唯一标识的IP地址和端口号组合在一起构成。</p><p>允许程序把网络连接当成一个流，数据在Socket间通过IO传输。</p></blockquote><p><strong>流套接字：</strong>使用TCP协议的Socket。</p><ul><li><p>客户端</p><p>构造器：<code>Socket(InetAddress address,int port)</code>：指定连接到目标的ip和端口号。</p><p>方法：<code>shutdownOutput()</code>：停止传输，并不会关闭<code>Socket</code>连接。</p></li></ul><p>​<code>InputStream getlnputStream()</code>：获取<code>Socket</code>输入流。</p><p>​<code>OutputStream getOutputStream()</code>：向<code>Socket</code>输出流。</p><ul><li><p>服务端</p><p>构造器：<code>ServerSocket(int port)</code>：监听的端口号。</p><p>方法：<code>Socket accept()</code>：接受请求并处理，返回一个双方连接的<code>Socket</code>。没有收到时会进入阻塞状态。</p></li></ul><br/><p>项目：<a href="/2024/03/10/%E5%A4%9A%E7%94%A8%E6%88%B7%E5%8D%B3%E6%97%B6%E9%80%9A%E8%AE%AF%E7%B3%BB%E7%BB%9F">多用户即时通讯系统</a></p><br/><p><strong>数据报套接字：</strong>使用UDP协议的Socket</p><p>案例：</p><p>客户端：</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">//1.创建DdtdgramSocket的实例</span><span class="hljs-type">DatagramSocket</span> <span class="hljs-variable">ds</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DatagramSocket</span>();<span class="hljs-comment">//2.将数据、目的地的ip，目的地的端口号都封装在DatagramPacket数据报中</span><span class="hljs-type">InetAddress</span> <span class="hljs-variable">inetAddress</span> <span class="hljs-operator">=</span> InetAddress.getByName(host:<span class="hljs-string">&quot;127.0.0.1&quot;</span>);<span class="hljs-type">int</span> <span class="hljs-variable">port</span> <span class="hljs-operator">=</span> <span class="hljs-number">9090</span>;<span class="hljs-type">byte</span>[] bytes=<span class="hljs-string">&quot;我是发送端&quot;</span>.getBytes(<span class="hljs-string">&quot;utf-8&quot;</span>);<span class="hljs-type">DatagramPacket</span> <span class="hljs-variable">packet</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DatagramPacket</span>(bytes,θ,bytes.length,inetAddress,port);<span class="hljs-comment">//发送数据</span>ds.send(packet);ds.close();</code></pre></div><p>服务端：</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">//1.创建DatagramSocket的实例</span><span class="hljs-type">int</span> <span class="hljs-variable">port</span> <span class="hljs-operator">=</span> <span class="hljs-number">9090</span>;<span class="hljs-type">DatagramSocket</span> <span class="hljs-variable">ds</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DatagramSocket</span>(port);<span class="hljs-comment">//2.创建数据报的对象，用于接收发送端发送过来的数据</span><span class="hljs-type">byte</span>[] buffer = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[<span class="hljs-number">1024</span> * <span class="hljs-number">64</span>];DatagramPacket packet=<span class="hljs-keyword">new</span> <span class="hljs-title class_">DatagramPacket</span>(buffer,<span class="hljs-number">0</span>,buffer.length);<span class="hljs-comment">//3.接收数据</span>ds.receive(packet);<span class="hljs-comment">//4.获取数据，并打印到控制台上</span>String str=<span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(packet.getData(),<span class="hljs-number">0</span>,packet.getLength());System.out.println(str);ds.close();</code></pre></div><h3 id="URL类"><a href="#URL类" class="headerlink" title="URL类"></a>URL类</h3><blockquote><p>一个url对应着互联网上某一资源的网址。实际用途在于提供接口给前端调用</p></blockquote><p><strong>格式</strong>： <code>http://127.0.0.1:8080/examples/abcd.jpg?name=Tom</code></p><p>解释：<code>应用层协议 / ip地址 :端口号 / 资源地址 ? 参数列表</code></p><p><strong>实例化以及常见方法</strong>：</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">//实例化：</span><span class="hljs-keyword">new</span> <span class="hljs-title class_">URL</span>(String url);<span class="hljs-comment">//常见方法：</span><span class="hljs-keyword">public</span> String <span class="hljs-title function_">getProtocol</span><span class="hljs-params">()</span>:获取该URL的协议名<span class="hljs-keyword">public</span> String <span class="hljs-title function_">getHost</span><span class="hljs-params">()</span>:获取该URL的主机名<span class="hljs-keyword">public</span> String <span class="hljs-title function_">getPort</span><span class="hljs-params">()</span>:获取该URL的端口号<span class="hljs-keyword">public</span> String <span class="hljs-title function_">getPath</span><span class="hljs-params">()</span>:获取该URL的文件路径<span class="hljs-keyword">public</span> String <span class="hljs-title function_">getFile</span><span class="hljs-params">()</span>:获取该URL的文件名<span class="hljs-keyword">public</span> String <span class="hljs-title function_">getQuery</span><span class="hljs-params">()</span>:获取该URL的查询名</code></pre></div><p><strong>案例：下载指定URL上的资源</strong></p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-type">HttpURLConnection</span> <span class="hljs-variable">urlConnection</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<span class="hljs-type">InputStream</span> <span class="hljs-variable">is</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<span class="hljs-type">FileOutputStream</span> <span class="hljs-variable">fos</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<span class="hljs-keyword">try</span>&#123;  <span class="hljs-comment">//1.获取URL实例</span>  <span class="hljs-type">URL</span> <span class="hljs-variable">url</span> <span class="hljs-operator">=</span><span class="hljs-keyword">new</span> <span class="hljs-title class_">URL</span>(spec:<span class="hljs-string">&quot;http://127.0.0.1:8080/examples/abcd.jpg&quot;</span>);  <span class="hljs-comment">//2.建立与服务器端的连接</span>  urlConnection =(HttpURLConnection) url.openConnection();  <span class="hljs-comment">//3.获取输入流、创建输出流</span>  is = urlconnection.getInputStream(）;  <span class="hljs-type">File</span> <span class="hljs-variable">file</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(<span class="hljs-string">&quot;dest.jpg&quot;</span>);  fos = <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputStream</span>(file);  <span class="hljs-comment">//4.读写数据</span>  <span class="hljs-type">byte</span>[] buffer = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[<span class="hljs-number">1024</span>];  <span class="hljs-type">int</span> len;  <span class="hljs-keyword">while</span> ((len =is.read（buffer))!=-<span class="hljs-number">1</span>)&#123;    fos.write(buffer,θ,len);  &#125;  System.out.println(<span class="hljs-string">&quot;文件下载完成&quot;</span>);&#125;<span class="hljs-keyword">catch</span>(I0Exception e)&#123;  e.printStackTrace();&#125;<span class="hljs-keyword">finally</span>&#123;  <span class="hljs-comment">//5.关闭资源</span>  <span class="hljs-keyword">try</span>&#123;    <span class="hljs-keyword">if</span>(fos != <span class="hljs-literal">null</span>)      fos.close();  &#125;<span class="hljs-keyword">catch</span>(IoExceptione)&#123;    e.printStackTrace();  &#125;  <span class="hljs-keyword">try</span>&#123;    <span class="hljs-keyword">if</span>(is != <span class="hljs-literal">null</span>)      is.close();  &#125;<span class="hljs-keyword">catch</span>(IoExceptione]&#123;    e.printStackTrace();  &#125;  <span class="hljs-keyword">if</span>(urlConnection != <span class="hljs-literal">null</span>）    urlConnection.disconnect();&#125;</code></pre></div><h2 id="注解-Annotation"><a href="#注解-Annotation" class="headerlink" title="注解(Annotation)"></a>注解(Annotation)</h2><blockquote><p>和注释类似，都是对程序代码进行的补充，但是注解是可以被编译器或者其他程序读取的。</p><p>程序可以根据注解的不同，做出相应的处理。 </p><p>替代旧版JavaEE中所遗留的<code>繁冗的代码</code>和<code>XML配置</code></p></blockquote><p>注解（Annotation）是从JDK5.0开始引l入，以”@注解名”在代码中存在。</p><p>Annotation可以像修饰符一样被使用，可用于修饰包、类、构造器、方法、成员变量、参数、局部变量的声明。还可以添加一些参数值，这些信息被保存在Annotation的”name&#x3D;value”对中。</p><p>注解可以在类编译、运行时进行加载，体现不同的功能。</p><h3 id="注解的应用场景"><a href="#注解的应用场景" class="headerlink" title="注解的应用场景"></a>注解的应用场景</h3><ol><li>生成文档相关的注解</li><li>在编译时进行格式检查（JDK内置的三个基本注解）<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">//Java基础涉及到的三个常用注解</span>@0verride：限定重写父类方法，该注解只能用于方法<span class="hljs-meta">@Deprecated</span>：用于表示所修饰的元素（类，方法等）已过时。通常是因为所修饰的结构危险或存在更好的选择<span class="hljs-meta">@SuppressWarnings</span>：抑制编译器警告</code></pre></div></li><li>跟踪代码依赖性，实现替代配置文件的功能</li></ol><h3 id="自定义注解"><a href="#自定义注解" class="headerlink" title="自定义注解"></a>自定义注解</h3><blockquote><p>参考@SuppressWarnings注解怎么写</p></blockquote><p>以<code>@SuppressWarnings</code>为例</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Target(&#123;TYPE,FIELD,METHOD,PARAMETER,CONSTRUCTOR,LOCAL_VARIABLE,MODULE&#125;)</span><span class="hljs-meta">@Retention(RetentionPolicy.SOURCE)</span><span class="hljs-comment">//上面两个为元注解</span><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> SuppressWarnings&#123;  String[] value(); <span class="hljs-comment">//注解的属性</span>&#125;</code></pre></div><p>自定义注解：</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> myAnnotation&#123;  String <span class="hljs-title function_">value</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> <span class="hljs-string">&quot;hello&quot;</span>;  <span class="hljs-comment">//属性并且默认赋值为hello</span>&#125;</code></pre></div><p>使用自定义注解：</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@myAnnotation(value = &quot;class&quot;)</span> <span class="hljs-comment">//赋值为class</span><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span>&#123;  <span class="hljs-meta">@myAnnotation()</span> <span class="hljs-comment">//不赋值则使用默认值hello</span>  String name;&#125;</code></pre></div><h3 id="元注解"><a href="#元注解" class="headerlink" title="元注解"></a>元注解</h3><blockquote><p>修饰注解的注解</p></blockquote><ol><li><p><strong><code>@Target</code></strong>:</p><p>用于描述注解的使用范围<br>可以通过枚举类型ElementType的10个常量对象来指定<br>TYPE，METHOD，CONSTRUCTOR，PACKAGE</p></li><li><p>**<code>@Retention</code>**：</p><p>用于描述注解的生命周期<br>可以通过枚举类型RetentionPolicy的3个常量对象来指定<br>SOURCE（源代码）、CLASS（字节码）、RUNTIME(运行时)<br>唯有RUNTIME阶段才能被反射读取到</p></li><li><p>**<code>@Documented</code>**：</p><p>表明这个注解应该被javadoc工具记录</p></li><li><p><strong><code>@lnherited</code></strong>:</p><p>允许子类继承父类中的注解</p></li></ol><br/><h2 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h2><blockquote><p>不更改类的前提下控制程序</p><p>在框架方面会大量运用</p><p>jdk11以上</p></blockquote><p>Java中反射图示：</p><p><img src="/../img/java/717f97a564fe825c9d1cd0f9c8a05373.png"></p><h3 id="类的加载过程"><a href="#类的加载过程" class="headerlink" title="类的加载过程"></a>类的加载过程</h3><div class="code-wrapper"><pre><code class="hljs coq">过程<span class="hljs-number">1</span>：类的装载（loading）-&gt;将类的class文件读入内存，并为之创建一个java.lang.<span class="hljs-keyword">Class</span>对象。此过程由类加载器完成过程<span class="hljs-number">2</span>：链接（linking）-&gt;验证（Verify）：确保加载的类信息符合JVM规范，例如：以cafebabe开头，没有安全方面的问题。-&gt;准备（Prepare）：正式为类变量（static）分配内存并设置类变量默认初始值的阶段，这些内存都将在方法区中进行分配。-&gt;解析（<span class="hljs-keyword">Resolve</span>）：虚拟机常量池内的符号引用（常量名）替换为直接引用（地址）的过程。过程<span class="hljs-number">3</span>：初始化（initialization）-&gt;执行类构造器&lt;clinit&gt;()方法的过程。-&gt;类构造器&lt;clinit&gt;()方法是由编译期自动收集类中所有类变量的赋值动作和静态代码块中的语句合并产生的。</code></pre></div><p><strong>对于<code>Class</code>的理解：</strong></p><p><img src="/../img/java/62b20f5dcf086431466ab2073b7d0ad0.png"></p><p>针对于编写好的<code>.java</code>源文件进行编译（使用<code>javac.exe</code>），会生成一个或多个<code>.class</code>字节码文件。接着，我们使用<code>java.exe</code>命令对指定的<code>.class</code>文件进行解释运行。这个解释运行的过程中，我们需要将<code>.class</code>字节码文件加载（使用类的加载器）到内存中（存放在方法区）。加载到内存中的<code>.class</code>文件对应的结构即为<code>Class</code>的一个实例。</p><p><code>Class</code>为描述类的类，他的实例往往是各种类。</p><p><strong><code>Class</code>的实例都可以指向哪些结构呢？</strong></p><p>简言之，所有Java类型！</p><ol><li><code>class</code>：外部类，成员（成员内部类，静态内部类），局部内部类，匿名内部类</li><li><code>interface</code>：接口</li><li><code>[]</code>：数组</li><li><code>enum</code>：枚举</li><li><code>annotation</code>:注解@interface</li><li><code>primitivetype</code>：基本数据类型</li><li><code>void</code></li></ol><p><strong>获取Class类的实例的三种方式：</strong></p><p>是获取，并不是创建。同一个类加载器加载类只会加载一次，因此三种方式获取的实例为同一个。</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">//1.调用运行时类的静态属性：class</span><span class="hljs-type">Class</span> <span class="hljs-variable">clazz1</span> <span class="hljs-operator">=</span> dog.class;System.out.println(clazz1);<span class="hljs-comment">//2.调用运行时类的对象的getClass()</span><span class="hljs-type">dog</span> <span class="hljs-variable">u1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">dog</span>();<span class="hljs-type">Class</span> <span class="hljs-variable">clazz2</span> <span class="hljs-operator">=</span> u1.getClass();<span class="hljs-comment">//3.调用class的静态方法forName（String className)</span><span class="hljs-type">String</span> <span class="hljs-variable">className</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;com.atguigu02._class.dog&quot;</span>;<span class="hljs-comment">//全类名</span><span class="hljs-type">Class</span> <span class="hljs-variable">clazz3</span> <span class="hljs-operator">=</span> Class.forName(className);System.out.println(clazz1 == clazz2);<span class="hljs-comment">//true</span>System.out.println(clazz1 == clazz3);<span class="hljs-comment">//true</span></code></pre></div><p>注：通过反射得到的对象判断是否相等的条件为：元素类型+维度。</p><p><strong>通过反射获取类，该类的构造器、变量、方法等：</strong></p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">//目标类</span><span class="hljs-keyword">class</span> <span class="hljs-title class_">dog</span>&#123;    <span class="hljs-keyword">public</span> String name;    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> num;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> age;    <span class="hljs-keyword">public</span> <span class="hljs-title function_">dog</span><span class="hljs-params">()</span>&#123;        System.out.println(<span class="hljs-string">&quot;无参构造器被调用&quot;</span>);    &#125;    <span class="hljs-keyword">public</span> <span class="hljs-title function_">dog</span><span class="hljs-params">(String name, <span class="hljs-type">int</span> num)</span> &#123;        <span class="hljs-built_in">this</span>.name = name;        <span class="hljs-built_in">this</span>.num = num;    &#125;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">hi</span><span class="hljs-params">()</span>&#123;        System.out.println(<span class="hljs-string">&quot;hi~&quot;</span>);    &#125;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">hi</span><span class="hljs-params">(<span class="hljs-type">int</span> num)</span>&#123;        <span class="hljs-built_in">this</span>.num=num;    &#125;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">eat</span><span class="hljs-params">()</span>&#123;        System.out.println(<span class="hljs-string">&quot;i want eat&quot;</span>);    &#125;    <span class="hljs-keyword">private</span> String <span class="hljs-title function_">play</span><span class="hljs-params">(String name,Integer age)</span>&#123;        <span class="hljs-keyword">return</span> name+<span class="hljs-string">&quot; &quot;</span>+age;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span> &#123;        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;dog&#123;&quot;</span> +                <span class="hljs-string">&quot;name=&#x27;&quot;</span> + name + <span class="hljs-string">&#x27;\&#x27;&#x27;</span> +                <span class="hljs-string">&quot;age=&#x27;&quot;</span> + age + <span class="hljs-string">&#x27;\&#x27;&#x27;</span> +                <span class="hljs-string">&quot;, num=&quot;</span> + num +                <span class="hljs-string">&#x27;&#125;&#x27;</span>;    &#125;&#125;<span class="hljs-comment">//获取该类的Class对象</span>Class&lt;?&gt; dogCls = Class.forName(<span class="hljs-string">&quot;Reflection.dog&quot;</span>);<span class="hljs-comment">//通过无参构造器创建实例</span><span class="hljs-type">Object</span> <span class="hljs-variable">dog</span> <span class="hljs-operator">=</span> dogCls.getDeclaredConstructor().newInstance();<span class="hljs-comment">//通过有参构造器创建实例</span><span class="hljs-type">Object</span> <span class="hljs-variable">dog1</span> <span class="hljs-operator">=</span> dogCls.getDeclaredConstructor(String.class, <span class="hljs-type">int</span>.class).newInstance(<span class="hljs-string">&quot;hello&quot;</span>, <span class="hljs-number">1</span>);System.out.println(dog.getClass());<span class="hljs-comment">//运行类型</span>System.out.println(dog1==dog);<span class="hljs-comment">//实例化的两个类不是同一个</span><span class="hljs-comment">//获取该类的属性   （属性名.对象名）</span><span class="hljs-type">Field</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> dogCls.getField(<span class="hljs-string">&quot;name&quot;</span>);<span class="hljs-comment">//获取该类的public属性</span>name.set(dog,<span class="hljs-string">&quot;mike&quot;</span>);<span class="hljs-comment">//设置属性</span>System.out.println(name.get(dog));<span class="hljs-comment">//获取属性</span><span class="hljs-type">Field</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span> dogCls.getDeclaredField(<span class="hljs-string">&quot;num&quot;</span>);<span class="hljs-comment">//获取该类的非public属性</span>num.setAccessible(<span class="hljs-literal">true</span>);<span class="hljs-comment">//爆破，允许对非public进行操作</span>num.set(dog,<span class="hljs-number">10</span>);System.out.println(num.get(dog));<span class="hljs-type">Field</span> <span class="hljs-variable">age</span> <span class="hljs-operator">=</span> dogCls.getDeclaredField(<span class="hljs-string">&quot;age&quot;</span>);age.setAccessible(<span class="hljs-literal">true</span>);age.set(<span class="hljs-literal">null</span>,<span class="hljs-number">20</span>);<span class="hljs-comment">//当该属性为static时，可以在对象形参写空，因为静态变量与类相绑定，而不是该类的对象</span>System.out.println(age.get(<span class="hljs-literal">null</span>));<span class="hljs-comment">//获取该类的方法    （方法名.invoke(对象名)）</span><span class="hljs-type">Method</span> <span class="hljs-variable">hi</span> <span class="hljs-operator">=</span> dogCls.getMethod(<span class="hljs-string">&quot;hi&quot;</span>);hi.invoke(dog);<span class="hljs-type">Method</span> <span class="hljs-variable">eat</span> <span class="hljs-operator">=</span> dogCls.getDeclaredMethod(<span class="hljs-string">&quot;eat&quot;</span>);eat.setAccessible(<span class="hljs-literal">true</span>);eat.invoke(<span class="hljs-literal">null</span>);<span class="hljs-type">Method</span> <span class="hljs-variable">play</span> <span class="hljs-operator">=</span> dogCls.getDeclaredMethod(<span class="hljs-string">&quot;play&quot;</span>, String.class, Integer.class);play.setAccessible(<span class="hljs-literal">true</span>);<span class="hljs-type">Object</span> <span class="hljs-variable">john</span> <span class="hljs-operator">=</span> play.invoke(dog, <span class="hljs-string">&quot;John&quot;</span>, <span class="hljs-number">100</span>);System.out.println(john);<span class="hljs-comment">//获取运行时类的父类的泛型</span><span class="hljs-type">Class</span> <span class="hljs-variable">clazz</span> <span class="hljs-operator">=</span> Class.forName(<span class="hljs-string">&quot;com.atguigu03.reflectapply.data.Person&quot;</span>);<span class="hljs-comment">//获取带泛型的父类（Type是一个接口，CLass实现了此接口</span><span class="hljs-type">Type</span> <span class="hljs-variable">superclass</span> <span class="hljs-operator">=</span> clazz.getGenericSuperclass();<span class="hljs-comment">//如果父类是带泛型的，则可以强转为ParameterizedType</span><span class="hljs-type">ParameterizedType</span> <span class="hljs-variable">paramType</span> <span class="hljs-operator">=</span> (ParameterizedType) superclass;<span class="hljs-comment">//调用getActuaLTypeArguments（）获取泛型的参数，结果是一个数组，因为可能有多个泛型参数。</span>Type[] arguments = paramType.getActualTypeArguments();<span class="hljs-comment">//获取泛型参数的名称</span>System.out.println(((class)arguments[o]).getName());</code></pre></div><p><strong>通过反射获取注解</strong></p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">//获取类声明上的注解(@Table)</span><span class="hljs-type">Classs</span> <span class="hljs-variable">clazz</span> <span class="hljs-operator">=</span> Customer.class;<span class="hljs-type">Table</span> <span class="hljs-variable">annotation</span> <span class="hljs-operator">=</span> (Table)clazz.getDeclaredAnnotation(Table.class);System.out.println(annotation.value());<span class="hljs-comment">//获取属性声明上的注解(@Column)</span><span class="hljs-type">Classs</span> <span class="hljs-variable">clazz</span> <span class="hljs-operator">=</span> Customer.class;<span class="hljs-type">Field</span> <span class="hljs-variable">nameField</span> <span class="hljs-operator">=</span> clazz.getDeclaredField（name:<span class="hljs-string">&quot;name&quot;</span>);<span class="hljs-comment">//获取属性</span><span class="hljs-type">Column</span> <span class="hljs-variable">nameColumn</span> <span class="hljs-operator">=</span> nameField.getDeclaredAnnotation(Column.class);System.out.println(nameColumn.columnName();<span class="hljs-comment">//cust_name</span>System.out.println(nameColumn.columnType();<span class="hljs-comment">//varchar（15）</span></code></pre></div><br/><p><strong>Java反射机制可以完成：</strong></p><ol><li>在程序运行时判断任意一个对象所属的类.</li><li>在程序运行时构造任意一个类的对象.</li><li>在程序运行时得到任意一个类所具有的成员变量和方法.</li><li>在程序运行时调用任意一个对象的成员变量和方法.</li><li>生成动态代理.</li></ol><br/><h3 id="反射机制的动态性"><a href="#反射机制的动态性" class="headerlink" title="反射机制的动态性"></a><strong>反射机制的动态性</strong></h3><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">//利用反射机制动态获取需要的实例</span><span class="hljs-keyword">public</span> &lt;T&gt; T <span class="hljs-title function_">getInstance</span><span class="hljs-params">(String className)</span> <span class="hljs-keyword">throws</span> Exception&#123;  <span class="hljs-type">Class</span> <span class="hljs-variable">clazz</span> <span class="hljs-operator">=</span> Class.forName(className);  <span class="hljs-type">Constructor</span> <span class="hljs-variable">con</span> <span class="hljs-operator">=</span> clazz.getDeclaredconstructor();<span class="hljs-comment">//获取空参构造器</span>  con.setAccessible(<span class="hljs-literal">true</span>);<span class="hljs-comment">//允许访问私有的</span>  <span class="hljs-keyword">return</span> (T) con.newInstance();&#125;<span class="hljs-comment">//利用反射机制动态获取需要对象实例的方法</span><span class="hljs-keyword">public</span> Object <span class="hljs-title function_">invoke</span><span class="hljs-params">(String className,String methodName)</span>throwsException&#123;  <span class="hljs-comment">//1.创建全类名对应的运行时类的对象</span>  <span class="hljs-type">Class</span> <span class="hljs-variable">clazz</span> <span class="hljs-operator">=</span> Class.forName(className);  <span class="hljs-type">Constructor</span> <span class="hljs-variable">con</span> <span class="hljs-operator">=</span> clazz.getDeclaredConstructor();  con.setAccessible(<span class="hljs-literal">true</span>);  <span class="hljs-type">Object</span> <span class="hljs-variable">obj</span> <span class="hljs-operator">=</span> con.newInstance();  <span class="hljs-comment">//2.获取运行时类中指定的方法，并调用</span>  <span class="hljs-type">Method</span> <span class="hljs-variable">method</span> <span class="hljs-operator">=</span>clazz.getDeclaredMethod(methodName);  method.setAccessible(<span class="hljs-literal">true</span>);  <span class="hljs-keyword">return</span> method.invoke(obj); <span class="hljs-comment">//return method.invoke(getInstance(className))</span>&#125;</code></pre></div><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">className</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;java.util.Date&quot;</span>;<span class="hljs-type">Date</span> <span class="hljs-variable">date</span> <span class="hljs-operator">=</span> getInstance(className);System.out.println(date);<span class="hljs-comment">//得到了实例化对象</span>System.out.println(invoke(<span class="hljs-string">&quot;java.util.Date&quot;</span>,<span class="hljs-string">&quot;方法名&quot;</span>));<span class="hljs-comment">//调用方法</span></code></pre></div><h3 id="根据反射机制实现榨汁机的案例"><a href="#根据反射机制实现榨汁机的案例" class="headerlink" title="根据反射机制实现榨汁机的案例"></a><strong>根据反射机制实现榨汁机的案例</strong></h3><p>榨汁机榨水果汁，水果分别有苹果（AppLe）、香蕉（Banana）、桔子（Orange）等。</p><p>步骤：</p><ol><li>声明(Fruit)水果接口，包含榨汁抽象方法：<code>void squeeze()</code>。</li><li>声明榨汁机（<code>Juicer</code>)，包含运行方法：<code>public void run(Fruit f)</code>，方法体中，调用f的榨汁方法<code>squeeze()</code></li><li>声明各种水果类，实现水果接口，并重写<code>squeeze()</code>;</li><li>在src下，建立配置文件：<code>config.properties</code>，并在配置文件中配上<code>fruitName=xxx</code>（其中xx为某种水果的全类名）</li><li>在<code>FruitTest</code>测试类中，<ol><li>读取配置文件，获取水果类名，并用反射创建水果对象，</li><li>创建榨汁机对象，并调用<code>run()</code>方法</li></ol></li></ol><p>实现：</p><ul><li>水果接口以及各种水果类<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Fruit</span> &#123;    <span class="hljs-keyword">void</span> <span class="hljs-title function_">squeeze</span><span class="hljs-params">()</span>;&#125;</code></pre></div><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Apple</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Fruit</span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">squeeze</span><span class="hljs-params">()</span> &#123;        System.out.println(<span class="hljs-string">&quot;榨一杯儿苹果汁&quot;</span>);    &#125;&#125;</code></pre></div><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Banana</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Fruit</span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">squeeze</span><span class="hljs-params">()</span> &#123;        System.out.println(<span class="hljs-string">&quot;榨一杯儿香蕉汁&quot;</span>);    &#125;&#125;</code></pre></div><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Orange</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Fruit</span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">squeeze</span><span class="hljs-params">()</span> &#123;        System.out.println(<span class="hljs-string">&quot;榨一杯儿橙汁&quot;</span>);    &#125;&#125;</code></pre></div></li><li>榨汁机<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Juicer</span> &#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">(Fruit f)</span>&#123;        f.squeeze();    &#125;&#125;</code></pre></div></li><li><code>FruitTest</code>测试类<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">try</span> (<span class="hljs-type">InputStream</span> <span class="hljs-variable">input</span> <span class="hljs-operator">=</span> FruitTest.class.getClassLoader().getResourceAsStream(<span class="hljs-string">&quot;config.properties&quot;</span>)) &#123;    <span class="hljs-comment">//1.读取配置文件中的信息，获取全类名。（使用类的加载器方法读取配置文件）</span>    <span class="hljs-type">Properties</span> <span class="hljs-variable">prop</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Properties</span>();    <span class="hljs-keyword">if</span> (input == <span class="hljs-literal">null</span>) &#123;        System.out.println(<span class="hljs-string">&quot;unable to find config.properties&quot;</span>);        <span class="hljs-keyword">return</span>;    &#125;    prop.load(input);    <span class="hljs-type">String</span> <span class="hljs-variable">fruitName</span> <span class="hljs-operator">=</span> prop.getProperty(<span class="hljs-string">&quot;fruitName&quot;</span>);    <span class="hljs-comment">//2.通过反射创建全类名对应的实例。</span>    <span class="hljs-type">Class</span> <span class="hljs-variable">aClass</span> <span class="hljs-operator">=</span> Class.forName(fruitName);    <span class="hljs-type">Constructor</span> <span class="hljs-variable">con</span> <span class="hljs-operator">=</span> aClass.getDeclaredConstructor();    con.setAccessible(<span class="hljs-literal">true</span>);    <span class="hljs-type">Fruit</span> <span class="hljs-variable">fruit</span> <span class="hljs-operator">=</span> (Fruit) con.newInstance();    <span class="hljs-comment">//3.通过榨汁机调用对象的榨汁方法。</span>    <span class="hljs-type">Juicer</span> <span class="hljs-variable">juicer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Juicer</span>();    juicer.run(fruit);&#125; <span class="hljs-keyword">catch</span> (Exception ex) &#123;    ex.printStackTrace();&#125;</code></pre></div></li></ul><h2 id="JDBC"><a href="#JDBC" class="headerlink" title="JDBC"></a>JDBC</h2><blockquote><p>JDBC为访问不同的数据库提供了统一的接口，为使用者屏蔽了细节问题。</p></blockquote><br/><h3 id="JDBC的原理示意图"><a href="#JDBC的原理示意图" class="headerlink" title="JDBC的原理示意图"></a>JDBC的原理示意图</h3><p><img src="/../img/java/c38ab5aa61256011e6c0473b01a13928.png"></p><br/><h3 id="JDBC程序编写步骤"><a href="#JDBC程序编写步骤" class="headerlink" title="JDBC程序编写步骤"></a>JDBC程序编写步骤</h3><ol><li>注册驱动-加载Driver类</li><li>获取链接-得到Connection</li><li>执行增删改查-发送SQL给数据库</li><li>释放资源-关闭相关链接</li></ol><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">//前置工作：需要将jar包导入到项目工程（add as library）</span><span class="hljs-comment">//1.注册驱动</span><span class="hljs-type">Driver</span> <span class="hljs-variable">driver</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Driver</span>();<span class="hljs-comment">//2.得到连接-底层是socket</span><span class="hljs-comment">//创建连接字符串</span>String url=<span class="hljs-string">&quot;jdbc:mysql://localhost:3306/数据库名字&quot;</span><span class="hljs-comment">//将用户名和密码放入一个Properties对象中</span><span class="hljs-type">Properties</span> <span class="hljs-variable">properties</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Properties</span>();properties.setProperty(<span class="hljs-string">&quot;user&quot;</span>,<span class="hljs-string">&quot;root&quot;</span>)<span class="hljs-comment">//properties的key是规定好的</span>properties.setProperty(<span class="hljs-string">&quot;password&quot;</span>,<span class="hljs-string">&quot;123456&quot;</span>);<span class="hljs-comment">//获取连接</span><span class="hljs-type">Connection</span> <span class="hljs-variable">connect</span> <span class="hljs-operator">=</span> dirver.connect(url,properties);<span class="hljs-comment">//3.执行sql</span>String sql=<span class="hljs-string">&quot;xxx&quot;</span><span class="hljs-comment">//statement用于执行静态SQL语句并返回其生成结果的对象</span><span class="hljs-type">Statement</span> <span class="hljs-variable">statement</span> <span class="hljs-operator">=</span> connect.creatStatement();<span class="hljs-type">int</span> rows - statement.executeUpdate(sql);<span class="hljs-comment">//返回受影响的行数</span><span class="hljs-comment">//4.关闭连接资源</span>statement.close();connect.close();</code></pre></div><br/><p><strong>连接的五种方式</strong></p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">//1.直接创建</span><span class="hljs-type">Driver</span> <span class="hljs-variable">driver</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Driver</span>();<span class="hljs-comment">//2.通过反射动态加载，更加灵活，减少依赖性</span>Class&lt;?&gt; aClass = Class.forName(<span class="hljs-string">&quot;com.mysql.jdbc.Driver&quot;</span>);<span class="hljs-type">Driver</span> <span class="hljs-variable">driver</span> <span class="hljs-operator">=</span> (Driver)aClass.newInstance();<span class="hljs-comment">//3.通过DriverManager来统一管理</span>Class&lt;?&gt; aClass = Class.forName(<span class="hljs-string">&quot;com.mysql.jdbc.Driver&quot;</span>);<span class="hljs-type">Driver</span> <span class="hljs-variable">driver</span> <span class="hljs-operator">=</span> (Driver)aClass.newInstance();String url=<span class="hljs-string">&quot;jdbc:mysql://localhost:3306/xxx&quot;</span>；String user=<span class="hljs-string">&quot;root&quot;</span>;String password=<span class="hljs-string">&quot;123456&quot;</span>;DriverManager.registerDriver(driver);<span class="hljs-comment">//注册Driver驱动</span><span class="hljs-type">Connection</span> <span class="hljs-variable">connection</span> <span class="hljs-operator">=</span> DriverManager.getConnection(url,user,password);<span class="hljs-comment">//4.使用Class.forName自动完成注册驱动，简化代码</span>Class.forName(<span class="hljs-string">&quot;com.mysql.jdbc.Driver&quot;</span>);String url=<span class="hljs-string">&quot;jdbc:mysql://localhost:3306/xxx&quot;</span>；String user=<span class="hljs-string">&quot;root&quot;</span>;String password=<span class="hljs-string">&quot;123456&quot;</span>;<span class="hljs-type">Connection</span> <span class="hljs-variable">connection</span> <span class="hljs-operator">=</span> DriverManager.getConnection(url,user,password);<span class="hljs-comment">//1.mysqL驱动5.1.6可以无需CLass .forName(“com.mysqljdbc.Driver”);</span><span class="hljs-comment">//2.从jdk1.5以后使用了jdbc4,不再需要显示调用class.forName()</span><span class="hljs-comment">//注册驱动而是自动调用驱动jar包下META-IN\services\java.sql.Driver文本中的类名称去注册</span><span class="hljs-comment">//3.建议还是写上 CLass .forName(“com.mysql.jdbc.Driver”),更加明确</span><span class="hljs-comment">//5.将url，user，password写入properties文件中动态调用</span>Properties properties=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Properties</span>();Properties.load(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(<span class="hljs-string">&quot;src\\xxx.properties&quot;</span>));<span class="hljs-comment">//获取相关值</span><span class="hljs-type">String</span> <span class="hljs-variable">url</span> <span class="hljs-operator">=</span> properties.getProperty(<span class="hljs-string">&quot;url&quot;</span>);<span class="hljs-type">String</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> properties.getProperty(<span class="hljs-string">&quot;user&quot;</span>);<span class="hljs-type">String</span> <span class="hljs-variable">password</span> <span class="hljs-operator">=</span> properties.getProperty(<span class="hljs-string">&quot;password&quot;</span>);<span class="hljs-type">String</span> <span class="hljs-variable">driver</span> <span class="hljs-operator">=</span> properties.getProperty(<span class="hljs-string">&quot;driver&quot;</span>);Class.forName(driver);<span class="hljs-type">Connection</span> <span class="hljs-variable">connection</span> <span class="hljs-operator">=</span> DriverManager.getConnection(url,user,password);</code></pre></div><br/><h3 id="部分API"><a href="#部分API" class="headerlink" title="部分API"></a>部分API</h3><br/><p><img src="/../img/java/77e5d258add9dbd3530994aac680206b.png"></p><br/><ul><li><p><strong>ResultSet</strong></p><p>在执行查询语句后，返回的结果以ResultSet结果集保存，本身也是模拟的一张表。它拥有一个光标，默认指向第一行，通过next方法，它会向下一行移动，如果没有下一行，则会返回flase（-1）。</p><p>resultSet包含了很多数据，其中结果数据存放位置在rowData的rows中。rows是一个ArrayList链表，其中的size代表查询返回多少行数据，真正储存的数据在rows的elementData中。  elementData是一个对象数组，长度取决查询得到的行数，即上面的size，他代表着每行的数据。  elementData数组中又包含internalRowData，他是一个字节数组，代表着每列的数据，长度取决于当前行中列的数量，其中每一个位置该行该列的数据。</p><p>rows：ArrayList链表</p><p>elemetData：Object数组</p><p>internalRowData：byte数组</p><p>因此数据储存的范围：</p><p>rowData -&gt; rows -&gt; elemetData（每行） -&gt; internalRowData（每列）</p></li></ul><p><img src="/../img/java/b9c45d5fb0fe8d4a6869b578cc1aa651.png"></p><br/><ul><li><p><strong>Statement和PreparedStatement</strong> </p><p>我们在建立连接之后，需要对数据库进行访问，执行命令或者是sql语句，可以通过statement用于执行静态sql语句，并返回结果对象。</p><p>statement存在sql注入，不要使用！preparedStatement经过预处理后不会存在sql注入问题。</p><p>preparedStatement可以对需要执行的sql语句中的参数用 “ ？”来占位，调用setXXX（）方法来设置这些参数。setXXX（）有两个参数，第一个为占位符所在的索引（下标从1开始），第二个为需要赋的值。</p><p><strong>PreparedStatement的好处：</strong></p><p>1.利于拼接sql语句，减少语法错误。</p><p>2.有效解决了sql注入问题。</p><p>3.大大减少了编译次数，效率更高。</p></li></ul><br/><h3 id="JDBC中事务与批处理"><a href="#JDBC中事务与批处理" class="headerlink" title="JDBC中事务与批处理"></a>JDBC中事务与批处理</h3><p><strong>事务的操作：</strong></p><p>默认情况下，commition是默认自动提交的，要想将很多sql语句作为一个整体，需要手动关掉connection的setAutoCommit为flase，这样需要手动connection.commit（）提交如果捕获到异常，可以在异常处理中手动回滚rollback()，默认回滚到事务开启的地方。</p><br/><p><strong>批处理：</strong></p><p>当需要成批插入或者更新记录时，可以采用java的批量处理机制，这一机制允许多条语句一次性成批提交给数据库处理，通常情况下比单独处f理更加有效。批处理往往和PreparedStatement一起使用，既可以减少编译次数，又可以减少运行次数，效率大大提高。</p><p><strong>要使用批处理，需要对url中添加rewriteBatchedStatements&#x3D;true,否则不会生效</strong></p><p>JDBC批处理的方法：</p><div class="code-wrapper"><pre><code class="hljs java">String url=<span class="hljs-string">&quot;jdbc:mysql://localhost:3306/xxx?rewriteBatchedStatements=true&quot;</span>；preparedStatement.addBatch();<span class="hljs-comment">//添加需要批处理的sql语句或参数；</span>preparedStatement.executeBatch();<span class="hljs-comment">//执行批量处理语句；</span>preparedStatement.clearBatch();<span class="hljs-comment">//清空批处理包的语句；</span></code></pre></div><p>preparedStatement.addBatch()后，sql语句储存在preparedStatement中的batchedArgs的elementData对象数组中。并且elementData对象数组默认为10的大小，以1.5倍扩容。其中每一个sql对象中的问号占位符参数存放在parameterStrings字节数组中。</p><p>preparedStatement：预处理对象。</p><p>batchedArgs：属于preparedStatement对象中。是一个ArrayList数组，存放批处理的sql语句的主要位置。</p><p>elementData：属于batchedArgs中，是一个对象数组，存放每个sql对象。</p><p>parameterStrings：存放占位符的参数。</p><p>因此批量处理的sql储存的范围为：</p><p>preparedStatement -&gt; batchedArgs -&gt; elementData</p><p><img src="/../img/java/6923c6bd8b5ca60dff00076776647d31.png"></p><p><img src="/../img/java/d67d3e9c5ca7c15a0b7e655cc4b80e61.png"></p><br/><h3 id="JavaBean"><a href="#JavaBean" class="headerlink" title="JavaBean"></a>JavaBean</h3><blockquote><p>通过数据集拿到的数据，不方便分类管理和拿取，且需要和connection相关联，因此此时JavaBean出现了</p><p>将得到的数据当成一个对象，其中每个列名即为该对象的一个字段，很多条数据就很多个对象，用集合来储存。这便是JavaBean，一种处理方式&#x2F;逻辑，体现了java面向对象和多态的特点，方便管理和规划 。同时它也叫做PoJO，domain，实体类</p></blockquote><p>JavaBean中数据类型与Mysql数据库中数据类型的对应关系：</p><table><thead><tr><th align="center">Mysql中</th><th align="center">JavaBean中</th></tr></thead><tbody><tr><td align="center">int</td><td align="center">Integer</td></tr><tr><td align="center">char、varchar</td><td align="center">String</td></tr><tr><td align="center">double</td><td align="center">Double</td></tr><tr><td align="center">date</td><td align="center">date&#x2F;String</td></tr></tbody></table><p>注：int,double 等在 Java 中都用包装类，因为 mysql 中的所有类型都可能是NULL，而 Java 只有引用数据类型才有NULL值。</p><br/><h3 id="数据库连接池"><a href="#数据库连接池" class="headerlink" title="数据库连接池"></a>数据库连接池</h3><blockquote><p>传统的JDBC数据库连接使用 DriverManager来获取，每次向数据库建立连接的时候都要将 Connection 加载到内存中再验证IP地址，用户名和密码(0.05s~1s时间)。需要数据库连接的时候就向数据库要求一个，频繁的进行数据库连接操作将占用很多的系统资源，容易造成服务器崩溃。</p><p>每一次数据库连接，使用完后都得断开，如果程序出现异常而未能关闭，将导致数据库内存泄漏，最终将导致重启数据库。</p><p>传统获取连接的方式，不能控制创建的连接数量，如连接过多，也可能导致内存泄漏，MySQL崩溃。</p><p>简而言之，传统JDBC方法对connection没有任何优化，用户持有connection过多会影响其他用户的连接等待。这里需要做的就是对connection进行代理优化和控制。</p></blockquote><p><strong>特点：</strong></p><ol><li>预先在缓冲池中放入一定数量的连接，当需要建立数据库连接时，只需从“缓冲池”中取出一个，使用完毕之后再放回去。</li><li>数据库连接池负责分配、管理和释放数据库连接，它允许应用程序重复使用一个现有的数据库连接，而不是重新建立一个。</li><li>当应用程序向连接池请求的连接数超过最大连接数量时，这些请求将被加入到等待队列中。</li></ol><p><img src="/../img/java/aca234ed3f28f8bc2977e6de9bda6c16.png"></p><p>Java官方为数据库连接池提供了接口：DataSource，第三方去实现。</p><p><strong>几种常用数据库连接池：</strong></p><ol><li>C3PO数据库连接池，速度相对较慢，稳定性不错 （hibernate, spring）；</li><li>Druid(德鲁伊) 是阿里提供的数据库连接池，集DBCP 、C3PO 、Proxool优点于一身的数据库连接池 （推荐使用）</li></ol><br/><p><strong>C3P0</strong></p><p>需要在libs下手动加入jar包 -&gt; 引入项目（add as liarbry）</p><p>配置文件拷贝到项目的src目录</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">//获取相关信息（driver，url，user，psw）</span><span class="hljs-comment">//创建一个数据源对象</span><span class="hljs-type">ComboPooledDataSource</span> <span class="hljs-variable">comboPooledDataSource</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ComboPooledDataSource</span>();<span class="hljs-comment">//设置相关参数</span>comboPooledDataSource.setDriverClass(driver);comboPooledDataSource.setJdbcUrl(url);comboPooledDataSource.setUser(user);comboPooledDataSource.setPassword(password);<span class="hljs-comment">//初始化连接数</span>comboPooledDataSource.setInitialPoorSize(<span class="hljs-number">10</span>);<span class="hljs-comment">//设置最大连接</span>comboPooledDataSource.setMaxPoorSize(<span class="hljs-number">50</span>);<span class="hljs-comment">//connection</span><span class="hljs-type">Connection</span> <span class="hljs-variable">connection</span> <span class="hljs-operator">=</span> comboPooledDataSource.getConnection();<span class="hljs-comment">//方法二：通过配置文件直接更改。</span><span class="hljs-type">ComboPooledDataSource</span> <span class="hljs-variable">comboPooledDataSource</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ComboPooledDataSource</span>(<span class="hljs-string">&quot;配置文件名字&quot;</span>);<span class="hljs-type">Connection</span> <span class="hljs-variable">connection</span> <span class="hljs-operator">=</span> comboPooledDataSource.getConnection();</code></pre></div><br/><p><strong>Druid</strong></p><p>需要在libs下手动加入jar包 -&gt; 引入项目（add as liarbry）</p><p>配置文件拷贝到项目的src目录</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">//获取配置文件</span><span class="hljs-type">Properties</span> <span class="hljs-variable">properties</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Properties</span>();properties.load(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(<span class="hljs-string">&quot;src\\druid.properties&quot;</span>));<span class="hljs-comment">//创建一个指定参数的数据库连接池</span><span class="hljs-type">DataSource</span> <span class="hljs-variable">dataSource</span> <span class="hljs-operator">=</span> DruidDataSourceFactory.createDataSource(properties);<span class="hljs-type">Connection</span> <span class="hljs-variable">connection</span> <span class="hljs-operator">=</span> dataSource.getConnection();</code></pre></div><br/><h3 id="结果集工具类"><a href="#结果集工具类" class="headerlink" title="结果集工具类"></a>结果集工具类</h3><blockquote><p>有很多时候查询出来的结果需要多次使用，查询返回的ResultSet结果集是与connection相关的，一旦连接关闭，则结果集就无法使用。</p><p>用户也不能一直持有connection，因此需要对查询得到的结果进行转存。</p></blockquote><p><img src="/../img/java/a0c5c6aaf4bfe683afc0874250ec1984.png"></p><p><strong>核心思路：</strong>将得到的结果集中每行以一个对象的形式储存，最后将每行数据（对象）存在集合中，这样脱离出来了ResultSet，也脱离了connection。</p><br/><p><strong>Apache-DBUtils</strong></p><ol><li>commons-dbutils 是 Apache 组织提供的一个开源 JDBC工具类库，它是对JDBC的封装，使用dbutils能极大简化jdbc编码的工作量。</li><li>QueryRunner类: 该类封装了SQL的执行，是线程安全的。可以实现增、删、改、查、批处理</li></ol><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">//大致方法：</span>ArrayHandler: <span class="hljs-comment">//把结果集中的第一行数据转成对象数组</span>ArrayListHandler: <span class="hljs-comment">//把结果集中的每一行数据都转成一个数组，再存放到List中</span>BeanHandler: <span class="hljs-comment">//将结果集中的第一行数据封装到一个对应的JavaBean实例中</span>BeanListHandler: <span class="hljs-comment">//将结果集中的每一行数据都封装到一个对应的JavaBean实例中，存放到List里</span>ColumnListHandler: <span class="hljs-comment">//将结果集中某一列的数据存放到List中</span>KeyedHandler(name): <span class="hljs-comment">//将结果集中的每行数据都封装到Map里，再把这些map再存到一个map里，其key为指定的key</span>MapHandler: <span class="hljs-comment">//将结果集中的第一行数据封装到一个Map里，key是列名，value就是对应的值</span>MapListHandler: <span class="hljs-comment">//将结果集中的每一行数据都封装到一个Map里，然后再存放到List</span>ScalarHandler();<span class="hljs-comment">//返回单行单列</span>BeanHandler();<span class="hljs-comment">//返回单行多列</span>BeanListHandler<span class="hljs-comment">//返回多行多列</span><span class="hljs-comment">//举例：</span><span class="hljs-type">Connection</span> <span class="hljs-variable">connection</span> <span class="hljs-operator">=</span> JDBCUtilsByRruid.getConnection();<span class="hljs-comment">//获取连接</span><span class="hljs-type">QueryRunner</span> <span class="hljs-variable">queryRunner</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">QueryRunner</span>();<span class="hljs-comment">//创建QueryRunner类</span><span class="hljs-type">String</span> <span class="hljs-variable">sql</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;select * from xxx where id = ?&quot;</span>;<span class="hljs-comment">/**</span><span class="hljs-comment">* 1.query方法是执行sql语句，得到 resultSet -&gt; 封装到 ArrayList 集合中</span><span class="hljs-comment">* 2.new BeanListHandler&lt;&gt;(Actor.class):在 resultSet -&gt; Actor对象 -&gt; 封装到 ArrayList中</span><span class="hljs-comment">* 3.这个“1”是可变参数，是sql语句中“？”占位符的赋值，此处是查找id = 1的数据</span><span class="hljs-comment">* 4.底层得到的resultSet、preparedStatement，会在query这个方法中关闭，无需手动关闭</span><span class="hljs-comment">*/</span>List&lt;Actor&gt; list =    queryRunner.query(connection , sql , <span class="hljs-keyword">new</span> <span class="hljs-title class_">BeanListHandler</span>&lt;&gt;(Actor.class) , <span class="hljs-number">1</span>);<span class="hljs-comment">//dml的操作：</span><span class="hljs-type">int</span> <span class="hljs-variable">affectedRow</span> <span class="hljs-operator">=</span> queryRunner.upDate(connection , sql , <span class="hljs-string">&quot;&quot;</span> ,<span class="hljs-string">&quot;&quot;</span>);<span class="hljs-comment">//返回受影响的行数</span></code></pre></div><br/><h3 id="DAO的引出"><a href="#DAO的引出" class="headerlink" title="DAO的引出"></a>DAO的引出</h3><blockquote><p>DAO &#x3D; data access object ，数据访问对象，内部封装了操作数据库相关表的增删改查操作。</p></blockquote><p>上述用apache-dbutil（结果集） + Druid（连接池）简化了JDBC的开发，但是还是有很多不足：</p><ol><li>sql语句固定，不能通过参数传入，通用性不佳。</li><li>对于查询操作，返回值不能固定，需要使用泛型。</li><li>只能对单一表进行操作，无法实现业务需求复杂的情况。</li></ol><br/><p>因此，我们可以对上述进行优化，将写sql的地方单独拿出来，如下图：</p><p><img src="/../img/java/401b85c552f4f1c10f96a39387f0dd27.png"></p><br/><h2 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h2><blockquote><p>处理文本的利器。一个正则表达式，就是用某种模式去匹配字符串的一个公式</p></blockquote><p><strong>语法与分析：</strong></p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">//1.创建模式对象，即正则表达式</span><span class="hljs-type">Pattern</span> <span class="hljs-variable">pattern</span> <span class="hljs-operator">=</span> Pattern .compile(<span class="hljs-string">&quot;\\d&quot;</span>) <span class="hljs-string">&quot;\d&quot;</span>表示任意一个数字。第一个<span class="hljs-string">&quot;\&quot;表示转义字符</span><span class="hljs-string">//2.创建匹配器</span><span class="hljs-string">Matcher matcher = pattern .matcher(&quot;</span>str<span class="hljs-string">&quot;):</span><span class="hljs-string">//3.开始匹配</span><span class="hljs-string">while (matcher.find())&#123;</span><span class="hljs-string">  System.out.println(matcher.group(0));</span><span class="hljs-string">&#125;</span><span class="hljs-string"></span><span class="hljs-string">//源码分析：</span><span class="hljs-string">matcher.find():</span><span class="hljs-string">  1.根据指定的规则，匹配到子字符串。</span><span class="hljs-string">  2.将找到的子字符串的索引记录到matcher对象的属性int []groups中。</span><span class="hljs-string">    groups[0] = 子字符串的首位索引  groups[1] = 子字符串的末尾索引+1；（左开右闭原则）</span><span class="hljs-string">  3.同时记录oldLast的值为 子字符串的末尾索引+1，用于下次find时的定位。</span><span class="hljs-string">  4.清空groups数组（清空原因在于后续分组的情况）。</span><span class="hljs-string">  </span><span class="hljs-string">matcher.group(0):  //注意这里的group和上面的groups不是一个东西！</span><span class="hljs-string">  1.源码可以看出，调用group(*)方法时，retrun的是与groups(*2)和groups(*2+1)。</span><span class="hljs-string">  </span><span class="hljs-string">  </span><span class="hljs-string">分组的情况：（即在模式对象中的匹配字符串用“（）”分组）</span><span class="hljs-string"></span><span class="hljs-string">matcher.find():</span><span class="hljs-string">  1.根据指定的规则，匹配到子字符串。</span><span class="hljs-string">  2.将找到的子字符串的索引记录到matcher对象的属性int []groups中。</span><span class="hljs-string">    groups[0] = 子字符串的首位索引  groups[1] = 子字符串的末尾索引+1；（左开右闭原则）</span><span class="hljs-string">    groups[1] = 第一组的首位索引    groups[2] = 第一组的末尾索引+1;</span><span class="hljs-string">    groups[3] = 第二组的首位索引    groups[4] = 第二组的末尾索引+1</span><span class="hljs-string">  3.同时记录oldLast的值为 子字符串的末尾索引+1，用于下次find时的定位。</span><span class="hljs-string">  4.清空groups数组。</span><span class="hljs-string">  </span><span class="hljs-string">matcher.group(*):</span><span class="hljs-string">  1.源码可以看出，调用group(*)方法时，return的是与groups(*2)和groups(*2+1)。</span><span class="hljs-string">  2.因此在matcher.group(0)时，return的是groups[0]和groups[1]，这是返回所有的匹配值;</span><span class="hljs-string">    而matcher.group(1)时，return的是groups[1*2=2]和groups[1*2+1=3]，可知返回的是第一组的值</span><span class="hljs-string">    matcher.group(2)时，return的是groups[2*2=4]和groups[2*2+1=5]，可知返回的是第二组的值</span><span class="hljs-string">    后续以此类推</span></code></pre></div><h3 id="限定符"><a href="#限定符" class="headerlink" title="限定符"></a><strong>限定符</strong></h3><blockquote><p>限定字符出现的次数</p></blockquote><table><thead><tr><th align="center">符号</th><th align="center">解释</th><th align="center">实例</th><th align="center">解释</th></tr></thead><tbody><tr><td align="center">*</td><td align="center">重复0-n次（默认贪婪匹配，尽可能匹配多的）</td><td align="center">(ab)*</td><td align="center">仅包含ab的字符（ab、ababab）</td></tr><tr><td align="center">+</td><td align="center">重复1-n次</td><td align="center">a+b*</td><td align="center">至少一个a与任意b的字符（aaab、abb、abbbbb）</td></tr><tr><td align="center">?</td><td align="center">可有可无</td><td align="center">m+abc?</td><td align="center">至少一个m与ab或abc字符（mab、mmabc、mmab）</td></tr><tr><td align="center">?</td><td align="center">当此字符紧随任何其他限定符 (*、+、?、{n}、{n,}、{n,m})之后时，匹配模式是”非贪心的”。</td><td align="center">o+?</td><td align="center">在字符串”oooo”中，”o+?”只匹配单个”o”，而”o+”匹配所有”o”</td></tr><tr><td align="center">{n}</td><td align="center">只能出现n次</td><td align="center">[abcd]{2}</td><td align="center">由abcd任意组成长度为2的字符串(（ab、ad、ac）</td></tr><tr><td align="center">{n,}</td><td align="center">至少出现n次</td><td align="center">[abcd]{2,}</td><td align="center">由abcd任意组成长度大于2的字符串(（ab、ad、abcd）</td></tr><tr><td align="center">{n,m}</td><td align="center">至少n次最多m次（默认贪婪匹配，尽可能匹配多的）</td><td align="center">{abcd}{1，3}</td><td align="center">由abcd任意组成长度大于1小于3的字符串(（a、ad、abc）</td></tr></tbody></table><h3 id="匹配符"><a href="#匹配符" class="headerlink" title="匹配符"></a><strong>匹配符</strong></h3><blockquote><p>选择字符出现的范围</p></blockquote><table><thead><tr><th align="center">符号</th><th align="center">含义</th><th align="center">示例</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">[ ]</td><td align="center">可接收的字符列表</td><td align="center">[edfg]</td><td align="center">匹配edfg中的任意一个字符</td></tr><tr><td align="center">[^]</td><td align="center">不可接受的字符列表</td><td align="center">[^edfg]</td><td align="center">匹配除了edfg中的任意一个字符</td></tr><tr><td align="center">-</td><td align="center">连字符</td><td align="center">A-Z</td><td align="center">任意一个大写字母（A-Z之间）</td></tr><tr><td align="center">.</td><td align="center">除\n（换行）以外的任何字符</td><td align="center">a..b</td><td align="center">以a开头，b结尾，中间两个任意字符（aXXb）</td></tr><tr><td align="center">\d</td><td align="center">单个数字字符 &#x3D;&#x3D;[0-9]</td><td align="center">\d{2}(\d)?</td><td align="center">包含2个或3个数字的字符串（123、1234）</td></tr><tr><td align="center">\D</td><td align="center">单个非数字字符 &#x3D;&#x3D;[^0-9]</td><td align="center">\D(\d)*</td><td align="center">以非数字开头的，后面任意数字（a、D3245）</td></tr><tr><td align="center">\w</td><td align="center">单个数字，大小写字母字符&#x3D;&#x3D;[0-9a-zA-Z]</td><td align="center">\d{3}\w{4}</td><td align="center">三个数字开头+四个数字、大小写字母字符（123pasd、1234567）</td></tr><tr><td align="center">\W</td><td align="center">单个非数字大小写字母字符&#x3D;&#x3D;[^0-9a-zA-Z]</td><td align="center">\W+\d{2}</td><td align="center">以至少一个非数字字母字符开头，2个数字字符结尾的字符串（#29、#?@10）</td></tr><tr><td align="center">\s</td><td align="center">单个任意空字符（空格，制表符等）</td><td align="center"></td><td align="center"></td></tr><tr><td align="center">\S</td><td align="center">单个非任意空字符</td><td align="center"></td><td align="center"></td></tr><tr><td align="center">(?i)</td><td align="center">不区分大小写</td><td align="center">a((?i)b)c</td><td align="center">只有b不区分大小写</td></tr><tr><td align="center">|</td><td align="center">选择匹配</td><td align="center">a|b</td><td align="center">a或b</td></tr></tbody></table><h3 id="定位符"><a href="#定位符" class="headerlink" title="定位符"></a><strong>定位符</strong></h3><blockquote><p>规定要匹配的字符串出现的位置，比如在字符串的开始还是结束</p></blockquote><table><thead><tr><th>符号</th><th>含义</th><th>示例</th><th>说明</th><th>匹配输入</th></tr></thead><tbody><tr><td>^</td><td>指定起始字符</td><td>^[0-9]+[a-z]*</td><td>至少以1个数字开头，后面任意的小写字母的字符串</td><td>123、6aa、555edf</td></tr><tr><td>$</td><td>指定结束字符</td><td>^[0-9]\-[a-z]$</td><td>至少以1个数字开头，后面连接”-“并以小写字母结尾的字符串</td><td>1-a</td></tr><tr><td>\b</td><td>匹配目标字符串的边界</td><td>han\b</td><td>边界是指之间有空格，或者是结束位置</td><td>123&#x3D;&#x3D;han&#x3D;&#x3D; nn&#x3D;&#x3D;han&#x3D;&#x3D;</td></tr><tr><td>\B</td><td>匹配目标字符串的非边界</td><td>han\B</td><td>与\b相反</td><td>&#x3D;&#x3D;han&#x3D;&#x3D;shunping</td></tr></tbody></table><p><strong>整体匹配(matches)</strong></p><blockquote><p>用于验证输入的字符串是否满足条件</p><p>返回值：boolean</p></blockquote><div class="code-wrapper"><pre><code class="hljs java">String str=<span class="hljs-string">&quot;nihaode_wtbu123.cc2&amp;SJ&quot;</span>;String regStr=<span class="hljs-string">&quot;.*wtbu.*&quot;</span>;<span class="hljs-type">boolean</span> <span class="hljs-variable">matches</span> <span class="hljs-operator">=</span> Pattern.matches(regStr, str);<span class="hljs-comment">//或者boolean matches = str.matches(regStr);</span>System.out.println(matches);</code></pre></div><p><strong>分组、捕获、反向引用</strong></p><blockquote><p>分组即用括号包起来的一种复杂的匹配模式</p><p>捕获即把分组的内容保存在内存中并以命名或数字编号的形式，方便引用</p><p>反向引用即获取捕获中的内容，并且可以当作新的匹配模式去使用。内部反向引用用\，外部则用$</p></blockquote><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-number">1</span>、匹配五个连续相同的数字(\\d)\\<span class="hljs-number">1</span>&#123;<span class="hljs-number">4</span>&#125;<span class="hljs-number">2</span>、匹配千位数与个位数相同，百位数与十位数相同（<span class="hljs-number">5225</span>、<span class="hljs-number">1551</span>）(\\d)(\\d)\\<span class="hljs-number">2</span>\\<span class="hljs-number">1</span></code></pre></div><p><strong>案例</strong></p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// 去重</span>String content=<span class="hljs-string">&quot;我我要要要学Javaa&quot;</span>content = Pattern.compile(<span class="hljs-string">&quot;(.)\\1+&quot;</span>).matcher(content).replaceAll(<span class="hljs-string">&quot;$1&quot;</span>)<span class="hljs-comment">//验证邮箱合法</span>String content=<span class="hljs-string">&quot;z118_4490022@qq.com&quot;</span>content.matches(<span class="hljs-string">&quot;[\\w]+@([a-zA-Z]+\\.)+[a-zA-Z]&quot;</span>)<span class="hljs-comment">//验证是否是数字</span>String content=<span class="hljs-string">&quot;-0.89&quot;</span>content.matches(<span class="hljs-string">&quot;[-+]?\\d+(\\.\\d+)?&quot;</span>)</code></pre></div><h2 id="Java8特性"><a href="#Java8特性" class="headerlink" title="Java8特性"></a>Java8特性</h2><h3 id="lambda表达式"><a href="#lambda表达式" class="headerlink" title="lambda表达式"></a>lambda表达式</h3><blockquote><p>使用更简洁的方式</p><p>使用前提：满足函数式接口：（接口中只声明了一个抽象方法）</p></blockquote><p><strong>语法：</strong></p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">//标准形式：</span><span class="hljs-type">Runnable</span> <span class="hljs-variable">r1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Runnable</span>()&#123;  <span class="hljs-meta">@Override</span>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;    System.out.printIn(<span class="hljs-string">&quot;我爱北京天安门&quot;</span>);&#125;r1.run();<span class="hljs-comment">//lambda形式</span><span class="hljs-type">Runnable</span> <span class="hljs-variable">r2</span> <span class="hljs-operator">=</span> () -&gt; System.out.println(<span class="hljs-string">&quot;我爱北京天安门&quot;</span>);r2.run();  ()：方法参数  -&gt;：lambda操作符\箭头函数  &#123;&#125;：方法体</code></pre></div><p><strong>本质：</strong></p><p>作为函数式接口的实例（接口实现类的对象）</p><p><strong>使用情况：</strong></p><p><code>-&gt;</code>左边：当<code>()</code>中没有参数时，只需要写<code>()</code>；如果只有一个参数时，其<code>()</code>可以省略，例如<code>e -&gt; &#123;sout(e)&#125;</code>；有一个以上参数时<code>()</code>不可以省略。</p><p><code>-&gt;</code>右边：当<code>&#123;&#125;</code>中只有一条语句时（包括<code>return</code>语句），其<code>&#123;&#125;</code>和<code>return</code>关键字都可以省略。例如<code>e -&gt; e + 1</code>;</p><br/><h3 id="Java内置核心函数式接口"><a href="#Java内置核心函数式接口" class="headerlink" title="Java内置核心函数式接口"></a>Java内置核心函数式接口</h3><p><strong>什么是函数式接口?</strong></p><p>如果接口中只声明有一个抽象方法，则此接口就称为函数式接口。</p><p>只有给函数式接口提供实现类的对象时，我们才可以使用lambda表达式。</p><p>函数式接口会有<code>@FunctionInterface</code>注解标记。</p><table><thead><tr><th align="left">函数式接口</th><th align="center">参数类型</th><th align="center">返回类型</th><th align="left">用途</th></tr></thead><tbody><tr><td align="left"><code>Consumer&lt;T&gt;</code> 消费型接口</td><td align="center">T</td><td align="center">void</td><td align="left">对类型为T的对象应用操作，包含方法：<code>void accept(T t)</code></td></tr><tr><td align="left"><code>Supplier&lt;T&gt;</code>供给型接口</td><td align="center">无</td><td align="center">T</td><td align="left">返回类型为T的对象，包含方法：<code>T get()</code></td></tr><tr><td align="left"><code>Function&lt;T,R&gt;</code>函数型接口</td><td align="center">T</td><td align="center">R</td><td align="left">对类型为T的对象应用操作，并返回结果。结果是R类型的对象。包含方法：<code>R apply(T t)</code></td></tr><tr><td align="left"><code>Predicate&lt;T&gt;</code>断定型接口</td><td align="center">T</td><td align="center">boolean</td><td align="left">确定类型为T的对象是否满足某约束，并返回boolean值。包含方法：<code>boolean test(T t)</code></td></tr></tbody></table><p>更多的在<code>java.util.function</code>包下</p><p><strong>案例</strong></p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">//Consumer&lt;T&gt; 消费型接口</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">text</span><span class="hljs-params">()</span>&#123;    <span class="hljs-comment">//原写法</span>    happyTime(<span class="hljs-number">500</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Consumer</span>&lt;Double&gt;() &#123;        <span class="hljs-meta">@Override</span>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">accept</span><span class="hljs-params">(Double aDouble)</span> &#123;            System.out.println(<span class="hljs-string">&quot;学习太累，去天上人间买了瓶矿泉水，价格为&quot;</span>+aDouble);        &#125;    &#125;);    <span class="hljs-comment">//lambda写法</span>    happyTime(<span class="hljs-number">400</span>,money -&gt; System.out.println(<span class="hljs-string">&quot;学习太累，去白马会所喝了口水，价格为&quot;</span>+money));&#125;<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">happyTime</span><span class="hljs-params">(<span class="hljs-type">double</span> money, Consumer&lt;Double&gt; con)</span>&#123;    con.accept(money);&#125;<span class="hljs-comment">//Predicate&lt;T&gt; 断定型接口</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">text2</span><span class="hljs-params">()</span>&#123;    List&lt;String&gt; list= Arrays.asList(<span class="hljs-string">&quot;北京&quot;</span>,<span class="hljs-string">&quot;南京&quot;</span>,<span class="hljs-string">&quot;东京&quot;</span>,<span class="hljs-string">&quot;吴京&quot;</span>,<span class="hljs-string">&quot;天津&quot;</span>);    <span class="hljs-comment">//原写法</span>    List&lt;String&gt; newString = filterString(list, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Predicate</span>&lt;String&gt;() &#123;        <span class="hljs-meta">@Override</span>        <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">test</span><span class="hljs-params">(String s)</span> &#123;            <span class="hljs-keyword">return</span> s.contains(<span class="hljs-string">&quot;京&quot;</span>);        &#125;    &#125;);    System.out.println(newString);    <span class="hljs-comment">//lambda写法</span>    List&lt;String&gt; newString2 = filterString(list, s -&gt; s.contains(<span class="hljs-string">&quot;京&quot;</span>));    System.out.println(newString2);&#125;<span class="hljs-keyword">public</span> List&lt;String&gt; <span class="hljs-title function_">filterString</span><span class="hljs-params">(List&lt;String&gt; list, Predicate&lt;String&gt; pre)</span>&#123;    ArrayList&lt;String &gt; arrayList=<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();    <span class="hljs-keyword">for</span> (String s : list) &#123;        <span class="hljs-keyword">if</span> (pre.test(s))&#123;            arrayList.add(s);        &#125;    &#125;    <span class="hljs-keyword">return</span> arrayList;&#125;</code></pre></div><h3 id="方法引用"><a href="#方法引用" class="headerlink" title="方法引用"></a>方法引用</h3><blockquote><p>可以看作是基于lambda表达式的进一步刻画。</p></blockquote><p>当需要提供一个函数式接口的实例时，我们可以使用lambda表达式提供此实例。当满足一定条件下，我们还可以使用方法引用或构造器引用替换lambda表达式。</p><p>因此<strong>方法引用也可以作为函数式接口的实例</strong></p><p><strong>格式：</strong></p><ol><li><p><code>对象::实例方法(非静态方法)</code>：</p><p>要求：函数式接口中的抽象方实现时调用的对象的某个方法b的形参列表和返回值类型都相同此时，可以考虑使用方法b实现对方法a的替换、覆盖。此替换或覆盖即为方法引用。</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">//1.通过new的方式创建</span>Consumer&lt;String&gt; consumer = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Consumer</span>&lt;String&gt;() &#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">accept</span><span class="hljs-params">(String s)</span> &#123;        System.out.println(s);    &#125;&#125;;<span class="hljs-comment">//2.使用lambda表达式</span>Consumer&lt;String&gt; consumer1 = s -&gt; System.out.println(s);<span class="hljs-comment">//3.使用方法引用</span>Consumer&lt;String&gt; consumer2 = System.out::println;</code></pre></div></li><li><p><code>类::静态方法</code>：</p><p>要求：同上。</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">//1.通过new的方式创建</span>Comparator&lt;Integer&gt; comparator = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Comparator</span>&lt;Integer&gt;() &#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">compare</span><span class="hljs-params">(Integer o1, Integer o2)</span> &#123;        <span class="hljs-keyword">return</span> Integer.compare(o1, o2);    &#125;&#125;;<span class="hljs-comment">//2.使用lambda表达式</span>Comparator&lt;Integer&gt; comparator1 = (o1, o2) -&gt; o1.compareTo(o2);<span class="hljs-comment">//3.使用方法引用</span>Comparator&lt;Integer&gt; comparator3 = Integer::compare;</code></pre></div></li><li><p><code>类::实例方法</code>：</p><p>要求：函数式接口中的抽象方法a与其内部实现时调用的对象的某个方法b的返回值类型相同。同时，抽象方法a中有n个参数，方法b中有n-1个参数，且抽象方法a的第1个参数作为方法b的调用者，且抽象方法a的后n-1个参数与方法b的n-1个参数的类型相同（或一致）。则可以考虑使用方法b实现对方法a的替换、覆盖。此替换或覆盖即为方法引用。</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">//1.通过new的方式创建</span>Comparator&lt;String&gt; comparator = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Comparator</span>&lt;String&gt;() &#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">compare</span><span class="hljs-params">(String o1, String o2)</span> &#123;        <span class="hljs-keyword">return</span> o1.compareTo(o2);    &#125;&#125;;<span class="hljs-comment">//2.使用lambda表达式</span>Comparator&lt;String&gt; comparator1 = (o1, o2) -&gt; o1.compareTo(o2);<span class="hljs-comment">//3.使用方法引用</span>Comparator&lt;String&gt; comparator3 = String::compareTo;</code></pre></div></li></ol><h4 id="构造器引用"><a href="#构造器引用" class="headerlink" title="构造器引用"></a>构造器引用</h4><ol><li>空参构造器：<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">//1.通过new的方式创建</span>Supplier&lt;Apple&gt; supplier = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Supplier</span>&lt;Apple&gt;() &#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> Apple <span class="hljs-title function_">get</span><span class="hljs-params">()</span> &#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Apple</span>();    &#125;&#125;;<span class="hljs-comment">//2.使用lambda表达式</span>Supplier&lt;Apple&gt; supplier1 = () -&gt; <span class="hljs-keyword">new</span> <span class="hljs-title class_">Apple</span>();<span class="hljs-comment">//3.使用方法引用</span>Supplier&lt;Apple&gt; supplier2 = Apple::<span class="hljs-keyword">new</span>;</code></pre></div></li><li>有参构造器：<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">//1.通过new的方式创建</span>BiFunction&lt;String, Float, Employee&gt; biFunction = <span class="hljs-keyword">new</span> <span class="hljs-title class_">BiFunction</span>&lt;String, Float, Employee&gt;() &#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> Employee <span class="hljs-title function_">apply</span><span class="hljs-params">(String name, Float sal)</span> &#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Employee</span>(name, sal);    &#125;&#125;;<span class="hljs-comment">//2.使用lambda表达式</span>BiFunction&lt;String, Float, Employee&gt; biFunction1 = (name, sal) -&gt; <span class="hljs-keyword">new</span> <span class="hljs-title class_">Employee</span>(name, sal);<span class="hljs-comment">//3.使用方法引用</span>BiFunction&lt;String, Float, Employee&gt; biFunction2 = Employee::<span class="hljs-keyword">new</span>;</code></pre></div></li></ol><br/><h3 id="Stream-API"><a href="#Stream-API" class="headerlink" title="Stream API"></a>Stream API</h3><blockquote><p>java对数据处理的一种补充，对集合数据进行操作，类似于使用SQL执行的数据查询</p></blockquote><p><strong>背景：</strong></p><p>实际开发中，项目中多数数据源都来自于Mysql，Oracle等。但现在数据源可以更多了，有MongDB，Radis等，而这些NOSQL的数据就需要Java层面去处理</p><p><strong>Stream 和 Collection 集合的区别</strong></p><p>Collection 是一种静态的内存数据结构，而 Stream 是有关计算的。</p><p>Collection 主要面向内存，存储在内存中，后者主要是面向 CPU，通过 CPU 实现计算。</p><p><strong>注意事项</strong></p><ol><li>Stream自己不会储存数据</li><li>Stream不会改变源对象。相反，他们会返回一个持有结果的新Stream</li><li>Stream操作时延迟执行的。这意味着他们会等到需要结果的时候才执行</li></ol><p><strong>Stream的三个操作</strong></p><ol><li><p>创建Stream</p><p>一个数据源（集合、数组等），获取一个流</p></li><li><p>中间操作</p><p>一个中间操作链，对数据源的数据进行处理（filter、map等）</p></li><li><p>终止操作（终端操作）</p><p>一旦执行终止操作，<strong>才会执行中间操作链</strong>，并产生结果。<strong>之后该Stream不会在被使用</strong></p></li></ol><p><img src="/../img/java/b79aa6b3d93ccbae45268b16f2d3e3fd.png"></p><h4 id="Stream的实例化："><a href="#Stream的实例化：" class="headerlink" title="Stream的实例化："></a><strong>Stream的实例化：</strong></h4><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">//创建方式一：通过集合创建</span>ArrayList&lt;Object&gt; lsit = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();Stream&lt;Object&gt; stream = lsit.stream();<span class="hljs-comment">//顺序流</span>Stream&lt;Object&gt; stream1 = lsit.parallelstream();<span class="hljs-comment">//并行流</span><span class="hljs-comment">//创建方式二：通过数组创建</span><span class="hljs-type">int</span>[] ints=<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">5</span>];<span class="hljs-type">IntStream</span> <span class="hljs-variable">stream2</span> <span class="hljs-operator">=</span> Arrays.stream(ints);<span class="hljs-comment">//创建方式三：通过Stream.of()创建</span>Stream&lt;Integer&gt; integerStream = Stream.of(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>);<span class="hljs-comment">//迭代</span><span class="hljs-comment">//遍历前10个偶数</span>Stream.iterate(<span class="hljs-number">0</span>, s -&gt; s + <span class="hljs-number">2</span>).limit(<span class="hljs-number">10</span>).forEach(System.out::print);<span class="hljs-comment">//生成</span><span class="hljs-comment">//生成10个随机数</span>Stream.generate(Math::random).limit(<span class="hljs-number">10</span>).forEach((System.out::print));</code></pre></div><h4 id="Stream的中间操作"><a href="#Stream的中间操作" class="headerlink" title="Stream的中间操作"></a><strong>Stream的中间操作</strong></h4><p><strong>筛选与切片</strong></p><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td><code>filert(Predicate p)</code></td><td>接收lambda，从流中排除某些元素</td></tr><tr><td><code>distinct()</code></td><td>去重，通过<code>hashcode()</code>和<code>equals()</code>实现</td></tr><tr><td><code>limit(long maxSize)</code></td><td>截断，使其元素不超过<code>maxSize</code></td></tr><tr><td><code>skip(long n)</code></td><td>返回跳过了前<code>n</code>个元素的流</td></tr></tbody></table><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">//filter(Predicate p)--从流中排除某些元素</span>Stream&lt;Employee&gt; stream = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;Employee&gt;().stream();stream.filter(e-&gt;e.getSalary()&gt;<span class="hljs-number">1000</span>)<span class="hljs-comment">//limit(n)--截断流。使其元素不超过指定数量</span>stream.limit(<span class="hljs-number">3</span>)<span class="hljs-comment">//skip(n)--跳过元素。返回一个扔掉前n个元素的流</span>stream.skip(<span class="hljs-number">3</span>)<span class="hljs-comment">//distinct()--去重。通过流所生成元素的hashcode和equals去除重复元素</span>stream.distinct()</code></pre></div><p><strong>映射</strong></p><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td><code>map(Function f)</code></td><td>接收一个函数作为参数，该函数会被应用到每个元素上并将其映射成一个新的元素。</td></tr><tr><td><code>mapToXXX(ToXXXFunction f)</code></td><td>同上，其中<code>XXX</code>表示数据基本类型</td></tr><tr><td><code>flagMap(Function f)</code></td><td>接收一个函数作为参数，将流中的每个值都换成另一个流，然后把所有的流连接成一个流</td></tr></tbody></table><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">//map(Function f)--接受一个函数作为参数，将元素转换成其他形式或提取信息</span>Stream&lt;Integer&gt; integerStream = Stream.of(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>);integerStream.map(s-&gt;s+<span class="hljs-number">1</span>).forEach(System.out::print);<span class="hljs-comment">//flatMap(Function f)--接受一个函数作为参数，将流中的每个值都换成另一个流并且展开存放</span>List&lt;String&gt; list = Arrays.asList(<span class="hljs-string">&quot;aa&quot;</span>,<span class="hljs-string">&quot;bb&quot;</span>,<span class="hljs-string">&quot;cc&quot;</span>);Stream&lt;Character&gt; characterStream = list.stream().flatMap(text::fromStringToStream);characterStream.forEach(System.out::print);<span class="hljs-comment">//将字符串的每个字符转成steam流</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Stream&lt;Character&gt; <span class="hljs-title function_">fromStringToStream</span><span class="hljs-params">(String str)</span> &#123;    ArrayList&lt;Character&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();    <span class="hljs-keyword">for</span> (Character c : str.toCharArray()) &#123;        list.add(c);    &#125;    <span class="hljs-keyword">return</span> list.stream();&#125;<span class="hljs-comment">//flagMap和map的区别？</span><span class="hljs-comment">//如果使用map：stream中包含的是stream(Character)</span>Stream&lt;Stream&lt;Character&gt;&gt; streamStream = list.stream().map(text::fromStringToStream);streamStream.forEach(s-&gt;&#123;    s.forEach(System.out::print);&#125;);<span class="hljs-comment">//而使用flatMap：stream中包含的是Character</span>Stream&lt;Character&gt; characterStream = list.stream().flatMap(text::fromStringToStream);<span class="hljs-comment">//综上，区别在于flatMap会将元素为stream流给展开再填入</span></code></pre></div><p><strong>排序</strong></p><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td><code>sorted()</code></td><td>产生一个新流，按其中自然排序排序</td></tr><tr><td><code>sorted()</code></td><td>产生一个新流，按其中比较器顺序排序</td></tr></tbody></table><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">//sorted()--自然排序（小-&gt;大）前提：实现了Comparable接口！！！</span>Stream&lt;Integer&gt; integerStream = Stream.of(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>);integerStream.sorted().foreach(System.out::print);<span class="hljs-comment">//sorted(Comparator com)--定制排序</span>List&lt;Employee&gt; list = EmployeeData.getEmployee();<span class="hljs-comment">//拿到list</span>list.stream().sorted((e1,e2) -&gt; Integer.compare(e1.getAge(),e2.getAge()));</code></pre></div><h4 id="Stream终止操作"><a href="#Stream终止操作" class="headerlink" title="Stream终止操作"></a>Stream终止操作</h4><p><strong>匹配与查找</strong></p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">//allMatch(Predicate p)--检查是否匹配所有元素</span><span class="hljs-comment">//是否所有的员工年龄都大于18？</span><span class="hljs-type">boolean</span> <span class="hljs-variable">allMatch</span> <span class="hljs-operator">=</span> employees.stream().allMatch(e-&gt;e.getAge()&gt;<span class="hljs-number">18</span>);<span class="hljs-comment">//anyMatch(Predicate p)--检查是否匹配任意一个元素</span><span class="hljs-comment">//是否有员工的工资大于10000？</span><span class="hljs-type">boolean</span> <span class="hljs-variable">anyMatch</span> <span class="hljs-operator">=</span> employees.stream().anyMatch(e-&gt;e.getSalary()&gt;<span class="hljs-number">10000</span>);<span class="hljs-comment">//noneMatch(Predicate p)--检查是否没有匹配的元素</span><span class="hljs-comment">//是否有员工姓雷？</span><span class="hljs-type">boolean</span> <span class="hljs-variable">noneMatch</span> <span class="hljs-operator">=</span> employees.stream().noneMatch(e-&gt;e.getName().startsWith(<span class="hljs-string">&quot;雷&quot;</span>));<span class="hljs-comment">//findFirst()--返回第一个元素</span>Optional&lt;Employee&gt; employee = employees.stream().findFirst();<span class="hljs-comment">//count()--返回个数</span><span class="hljs-type">long</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> employees.stream().filter(e-&gt;e.getSalary()&gt;<span class="hljs-number">5000</span>).count();<span class="hljs-comment">//max(Comparator c)--返回最大值（排序最右边）</span>Optional&lt;Double&gt; maxSalary = employees.stream().map(e-&gt;e.getSalary()).max(Double::compare);<span class="hljs-comment">//min(Comparator c)--返回最小值（排序最左边）</span>Optional&lt;Double&gt; employee = employees.stream().min((e1,e2)-&gt;Double.compare(e1.getSalary(),e2.getSalary));</code></pre></div><p><strong>归约</strong></p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">//reduce(T identity,BinaryOperator)--可以将流中元素发布反复结合起来，得到一个值。</span><span class="hljs-comment">//计算1-10的自然数和</span>List&lt;Integer&gt; list = Array.asList(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>,<span class="hljs-number">10</span>);<span class="hljs-type">Integer</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> list.stream().reduce(<span class="hljs-number">0</span> , Integer::sum);</code></pre></div><p><strong>收集</strong></p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">//collect(Collector c)--可以将流中元素转成list、set、map</span>List&lt;Integer&gt; list = Array.asList(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>,<span class="hljs-number">10</span>);List&lt;Integer&gt; list2 = list.stream().filter(e-&gt;e&gt;<span class="hljs-number">5</span>).collect(Collectors.toList());</code></pre></div><h3 id="Optional类"><a href="#Optional类" class="headerlink" title="Optional类"></a>Optional类</h3><blockquote><p>Optional<T>类(java.util.Optional) 是一个容器类，它可以保存类型T的值，代表这个值存在。或者仅仅保存null，表示这个值不存在。原来用 null 表示一个值不存在，现在 Optional 可以更好的表达这个概念。并且可以避免空指针异常。</p></blockquote><br/><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-type">Boy</span> <span class="hljs-variable">boy</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Boy</span>(<span class="hljs-string">&quot;张三&quot;</span>);<span class="hljs-comment">//Optional.of(T t)--不能存放空的对象，为空返回空指针异常</span>boy=<span class="hljs-literal">null</span>;Optional&lt;Boy&gt; o = Optional.of(boy);<span class="hljs-comment">//java.lang.NullPointerException</span><span class="hljs-comment">//Optional.ofNullable(T t)--允许存在空的对象，为空返回Optional.empty</span>boy=<span class="hljs-literal">null</span>;Optional&lt;Boy&gt; o = Optional.ofNullable(boy);System.out.println(o);<span class="hljs-comment">//Optional.empty</span><span class="hljs-comment">//optional对象的isPresent()--判断optional容器中是否包含对象，返回boolean</span><span class="hljs-comment">//optional对象的orElse(T other)--如果为空则返回other，否则返回原本的值</span>boy=<span class="hljs-literal">null</span>;Optional&lt;Boy&gt; o = Optional.ofNullable(boy);<span class="hljs-type">Boy</span> <span class="hljs-variable">boy1</span> <span class="hljs-operator">=</span> o.orElse(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Boy</span>(<span class="hljs-string">&quot;李四&quot;</span>));System.out.println(boy1);<span class="hljs-comment">//Boy&#123;name=&#x27;李四&#x27;&#125;</span></code></pre></div><h3 id="JDK8新日期时间API"><a href="#JDK8新日期时间API" class="headerlink" title="JDK8新日期时间API"></a>JDK8新日期时间API</h3><blockquote><p>仅展示常用的</p></blockquote><br/><h4 id="LocalDate、LocalTime、LocalDateTime"><a href="#LocalDate、LocalTime、LocalDateTime" class="headerlink" title="LocalDate、LocalTime、LocalDateTime"></a>LocalDate、LocalTime、LocalDateTime</h4><p>**静态方法(实例化)**：<code>now()</code>、<code>of()</code></p><p>获取时间：<code>getXXX()</code></p><p>设置时间：<code>setXXX()</code>，返回新的对象（体现出不可变性）</p><p>添加减去：<code>plusXXX()</code>、<code>minusXXX()</code></p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">//now() 根据当前时间创建对象</span><span class="hljs-type">LocalDate</span> <span class="hljs-variable">localDate</span> <span class="hljs-operator">=</span> LocalDate.now(); <span class="hljs-comment">// 获取当前日期 yyyy-MM-dd</span><span class="hljs-type">LocalDate</span> <span class="hljs-variable">localTime</span> <span class="hljs-operator">=</span> LocalTime.now(); <span class="hljs-comment">// 获取当前时间 HH:mm:MM.xxxxx</span><span class="hljs-type">LocalDate</span> <span class="hljs-variable">localDateTime</span> <span class="hljs-operator">=</span> LocalDateTime.now(); <span class="hljs-comment">// 获取当前日期和时间 yyyy-MM-dd HH:mm:MM.xxxxx</span><span class="hljs-comment">//of() 根据指定日期创建对象</span><span class="hljs-type">LocalDate</span> <span class="hljs-variable">localDate</span> <span class="hljs-operator">=</span> LocalDate.of(<span class="hljs-number">2023</span>,<span class="hljs-number">11</span>,<span class="hljs-number">22</span>); <span class="hljs-comment">// 设置日期 yyyy-MM-dd</span><span class="hljs-type">LocalDate</span> <span class="hljs-variable">localTime</span> <span class="hljs-operator">=</span> LocalTime.of(<span class="hljs-number">11</span>,<span class="hljs-number">02</span>,<span class="hljs-number">30</span>,<span class="hljs-number">1234</span>); <span class="hljs-comment">// 设置时间 HH:mm:MM.xxxxx</span><span class="hljs-type">LocalDate</span> <span class="hljs-variable">localDateTime</span> <span class="hljs-operator">=</span> LocalDateTime.of(); <span class="hljs-comment">// 设置日期和时间 yyyy-MM-dd HH:mm:MM.xxxxx</span></code></pre></div><h3 id="Instant"><a href="#Instant" class="headerlink" title="Instant"></a>Instant</h3><blockquote><p>瞬时，类似Date</p></blockquote><p>实例化：<code>now()</code>，<code>ofEpochMilli()</code></p><p><code>toEpochMilli()</code>：获取当前的毫秒数（时间戳）</p><br/><h3 id="DateTimeFormatter"><a href="#DateTimeFormatter" class="headerlink" title="DateTimeFormatter"></a>DateTimeFormatter</h3><blockquote><p>日期时间格式化</p></blockquote><p>静态方法：<code>ofPattern()</code>返回一个指定字符格式的<code>DateTimeFormatter</code></p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">//自定义格式</span><span class="hljs-type">DateTimeFormatter</span> <span class="hljs-variable">dateTimeFormatter</span> <span class="hljs-operator">=</span> DateTimeFormatter.ofPattern(<span class="hljs-string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);<span class="hljs-comment">//将日期转换为自定义格式字符串</span><span class="hljs-type">LocalDateTime</span> <span class="hljs-variable">localDateTime</span> <span class="hljs-operator">=</span> LocalDateTime.now();<span class="hljs-type">String</span> <span class="hljs-variable">strDateTime</span> <span class="hljs-operator">=</span> dateTimeFormatter.format(localDateTime); <span class="hljs-comment">//2023-11-22 15:23:42</span><span class="hljs-comment">//将字符串转换为日期</span><span class="hljs-type">TemporalAccessor</span> <span class="hljs-variable">temporalAccessor</span> <span class="hljs-operator">=</span> dateTimeFormatter.parse(<span class="hljs-string">&quot;2023-11-22 15:23:42&quot;</span>); <span class="hljs-comment">//TemporalAccessor是一个接口，已被日期等实现</span><span class="hljs-type">LocalDateTime</span> <span class="hljs-variable">localDateTime</span> <span class="hljs-operator">=</span> LocalDateTime.from(temporalAccessor);  <span class="hljs-comment">//将TemporalAccessor转换为LocalDateTime，2023-11-22T15:23:42</span></code></pre></div>]]></content>
    
    
    <categories>
      
      <category>学习</category>
      
      <category>笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>义无反顾的青春里 爱情不过是寥寥几笔</title>
    <link href="/2023/03/27/%E4%B9%89%E6%97%A0%E5%8F%8D%E9%A1%BE%E7%9A%84%E9%9D%92%E6%98%A5%E9%87%8C-%E7%88%B1%E6%83%85%E4%B8%8D%E8%BF%87%E6%98%AF%E5%AF%A5%E5%AF%A5%E5%87%A0%E7%AC%94/"/>
    <url>/2023/03/27/%E4%B9%89%E6%97%A0%E5%8F%8D%E9%A1%BE%E7%9A%84%E9%9D%92%E6%98%A5%E9%87%8C-%E7%88%B1%E6%83%85%E4%B8%8D%E8%BF%87%E6%98%AF%E5%AF%A5%E5%AF%A5%E5%87%A0%E7%AC%94/</url>
    
    <content type="html"><![CDATA[<blockquote><p>这篇影评可能有剧透</p></blockquote><p><strong>永远会对勇敢善良的女孩子心动💗</strong></p><p><img src="/img/35371261/p2872805536.jpg"></p><p>会担心擦肩而过的陌生人误入危险废墟而狂奔，会给流浪的小猫咪喂小鱼干，会帮助陌生人关上危险与未知并存的门。</p><br/><p>一个人去“旅行🧳”，去看富士山，去“拯救世界”，去拯救爱的人，去做她认为正确的事，去帮助身边能帮到的人。</p><br/><p>电影里没有傻白甜的高中生、也没有恋爱脑的小女生、也没有毫无理由叛逆的熊孩子，有的是勇敢、善良、闪闪发光的铃芽。</p><br/><p>我太喜欢这种剧本，<strong>女孩子也可以勇敢的做任何事情，或大或小，都充满无限可能</strong>。</p><br/><p>铃芽和姨妈之间纠结的亲情，芹泽和草太之简单的友情，大臣和铃芽之间纯粹的喜爱，讲铃芽和草太之间懵懂的感情，篇幅简短，但真诚入人心。</p><p>在不为人知的地方总有人在默默守护一方平安，或许在被人忽视的角落，有一批又一批人渐渐沉睡。或许不能做什么，但不能遗忘。</p><p>曾经以为难捱无法度过的日子，在未来也不过是一场短暂的梦。“<strong>所以别再担心了，未来并不可怕，你也会遇到很多非常喜欢你的人，虽然你觉得世界一片黑暗，但是黎明终会到来，你会在阳光之下长大成人，未来一定会是这样的，因为那已经是注定好的事了。</strong>”</p><br/><p>能治愈你的永远只有自己。</p><br/><p><strong>或许我没有勇气一个人旅行，没有勇气放弃自己去拯救世界，但人生最奇妙的事情就在于，一切都充满可能吧🥹</strong></p><p><img src="/img/35371261/p2886845591.jpg"></p>]]></content>
    
    
    <categories>
      
      <category>生活</category>
      
      <category>影评</category>
      
    </categories>
    
    
    <tags>
      
      <tag>影评</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>人总不满足于现状 幻想着能与他人交换人生</title>
    <link href="/2023/02/01/%E4%BA%BA%E6%80%BB%E4%B8%8D%E6%BB%A1%E8%B6%B3%E4%BA%8E%E7%8E%B0%E7%8A%B6-%E5%B9%BB%E6%83%B3%E7%9D%80%E8%83%BD%E4%B8%8E%E4%BB%96%E4%BA%BA%E4%BA%A4%E6%8D%A2%E4%BA%BA%E7%94%9F/"/>
    <url>/2023/02/01/%E4%BA%BA%E6%80%BB%E4%B8%8D%E6%BB%A1%E8%B6%B3%E4%BA%8E%E7%8E%B0%E7%8A%B6-%E5%B9%BB%E6%83%B3%E7%9D%80%E8%83%BD%E4%B8%8E%E4%BB%96%E4%BA%BA%E4%BA%A4%E6%8D%A2%E4%BA%BA%E7%94%9F/</url>
    
    <content type="html"><![CDATA[<blockquote><p>这篇影评可能有剧透</p></blockquote><p>《交换人生》一听这个名字，仿佛剧情都能猜到七八分。大概就是奇幻啦、穿越啦，我穿到你身上、你穿到我身上，这样的剧本。</p><p>俗套的剧情，<strong>用最质朴的方式表达，反而最打动人心。</strong></p><br/><p>利益熏心不分黑白的律师为获利而故意输掉一场人命关天的官司；十六七岁热血的少年却喜欢上了三十多岁的“女孩儿”；被妈妈逼着催婚却只是为了还债的大龄剩女。不同世界的人，却奇妙的串联到一起。</p><br/><p>他们讲友情，就讲少年换到了大叔身上，无人相信走投无路找到自己的死党，即使眼前的人无比陌生也仍能认出自己的好朋友，帮他想办法实现愿望。即使吵架闹别扭，关键时刻还是为你着想还不忘给朋友买下喜欢的游戏皮肤，幼稚却又轰轰烈烈的少年情。</p><br/><p>他们讲爱情，就讲即使相差十几岁，有趣的灵魂依然能相互吸引，一起看万家灯火、一起在游戏厅打游戏、一起转圈圈看漫天流星，无关利益，只有开心。我和你在一起开心，这不就是爱情吗，像少年时最纯粹最简单的感情。</p><br/><p>他们讲家庭，讲为了唤起患阿尔兹海默症奶奶的记忆，全家陪着奶奶每天做一样的事情，一起唱歌，一起看房子，同样的剧情不厌其烦，只为了让奶奶想起那些旧事。讲家庭，他们讲父母的相互扶持，讲平淡生活里的苦中作乐，讲家的温暖。</p><br/><p>他们讲人生，讲如果换一种生活，我会不会实现我的愿望？好，换！  换成了喜欢的人的男朋友，却失去了温暖的家庭，换成了功成名就的大律师，却丧失了道德的底线。有所得就一定有所失。最后千帆过尽，还是自己的生活最美好、最珍贵。</p><br/><p>这一场闹剧式的交换人生，又何尝不是人生中的波折呢。你迫切想拥有的，或许是别人唾手可得的。你说曾忽视的，或许是别人梦寐以求的。<strong>人生最奇妙的，就是人皆不同。</strong></p><br/><p><strong>一千个世界有一千个哈姆雷特，一千个人亦有一千种人生。</strong></p><p><img src="/img/14956604/p2889176899.jpg"></p>]]></content>
    
    
    <categories>
      
      <category>生活</category>
      
      <category>影评</category>
      
    </categories>
    
    
    <tags>
      
      <tag>影评</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>将故事封存在最美好的时刻</title>
    <link href="/2023/01/17/%E5%B0%86%E6%95%85%E4%BA%8B%E5%B0%81%E5%AD%98%E5%9C%A8%E6%9C%80%E7%BE%8E%E5%A5%BD%E7%9A%84%E6%97%B6%E5%88%BB/"/>
    <url>/2023/01/17/%E5%B0%86%E6%95%85%E4%BA%8B%E5%B0%81%E5%AD%98%E5%9C%A8%E6%9C%80%E7%BE%8E%E5%A5%BD%E7%9A%84%E6%97%B6%E5%88%BB/</url>
    
    <content type="html"><![CDATA[<blockquote><p>这篇影评可能有剧透</p></blockquote><p>每次和朋友们说起我没看过泰坦尼克号，每次都能收获一大波震惊🤯 今天终于有空有时间看了这部经典电影🎬</p><br/><p>路易十六的钻石被分割后制成了价值连城的“海洋之星”，利益驱使着人们对沉没在海底的泰坦尼克号展开一次次搜寻。在黑暗的海底中人们用潜水艇一次次照亮久居黑暗的泰坦尼克，用科技复原它沉船的过程，人们渐渐了解泰坦尼克号的故事，但却见不到它的辉煌。</p><p><img src="/img/1292722/p1482527907.jpg"></p><br/><p>Rose奶奶用回忆带我们回到那艘“永不会沉没”的泰坦尼克号上。那是她还是个年轻漂亮的上流名媛，与未婚夫踏上泰坦尼克开启未知的“旅程”。是对旅行的未知，也是对婚姻的未知。</p><p>Rose厌倦了整日茶会、餐会这样无趣的生活。Rose试图结束这无趣的生活，但Jack的出现，给她无趣的生活带来了一丝光亮。他带着她一起尝试许多从未尝试过的事情，画画、跳舞、喝酒，甚至学习怎么像男士一样吐痰。救了Rose的他受邀参加他们的晚宴，即使不太懂上流生活的一些礼仪，但他迅速学习并隐藏在人群中；虽然身无分文，但胆识、眼界和心胸是无法掩藏的。</p><p>Jack在晚宴上被频频刁难，但他却从容应对，大方承认自己的处境与生活，豁达开朗的态度，反而让人感到佩服。也逐渐让Rose对Jack有了不一样的感情。但母亲却制止Rose，提醒她家庭的责任需要她的婚姻来承担。Rose决定放弃。</p><p><img src="/img/1292722/p1460629869.jpg"></p><p><img src="/img/1292722/p1460631725.jpg"></p><p>看到这里其实我觉得，最后沉船反而是最好的结局。如果没有沉船，Rose和Jack的轰轰烈烈爱情或许只会是上流人士茶余饭后的谈资，在权利和金钱面前，在亲情和家庭面前，善良的Rose或许没办法抛弃母亲与Jack远走高飞。惯用金钱的未婚夫或许会拿金钱权势压的Jack无能为力。我想过很多种不同的结局，却仍然认为，沉船是最好的结局。故事暂停在最美好的时刻，Rose带着这最美好的回忆重新开始新的生活。也不失为是一种浪漫。</p><br/><p>剧中还有很多坦然赴死的人们，让我为之动容。躺在床上相拥等待死亡来临的老夫妻；站在甲板上坚持完成作品的音乐家们；在船舱里讲故事哄孩子们睡去的母亲；站在壁炉前深情凝望着泰坦尼克画像的设计师；面对仓皇逃生巨大压力下自杀倒下的船员；还有坚守岗位与船只一起沉入海底的老船长。他们不怕死吗，我想也是怕的，可是在绝望的处境中坦然面对对他们来说反而是最好的选择，或许是因为年迈、因为热爱、因为幼小、因为深爱、因为压力、因为愧疚… </p><br/><p>反之有许许多多人们，慌乱之中漏出了人性丑恶嘴脸。没有危险的地方人性最为致命。枪杀、踩踏、争抢、跳海、翻船、割绳，还有冷漠。在求生面前什么人性本善都是放屁，人人脑中只有一句话，我要活下去。我不是神，面对这样的恐惧我也不知道我会做出什么选择，所以我没有资格指责他们什么。我只感到悲哀，为跳入海中的人们悲哀、为被无辜枪杀的人们悲哀、为那些在海面上冻成雕像的人们悲哀。</p><br/><p>若只看感情，这是妥妥的浪漫结局；但若看事件，这是一部极大的悲剧，沉船的悲剧和人性的悲剧。</p>]]></content>
    
    
    <categories>
      
      <category>生活</category>
      
      <category>影评</category>
      
    </categories>
    
    
    <tags>
      
      <tag>影评</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
