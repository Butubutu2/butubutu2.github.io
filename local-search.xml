<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>梦入故山人未去</title>
    <link href="/2023/08/03/%E6%A2%A6%E5%A2%83/"/>
    <url>/2023/08/03/%E6%A2%A6%E5%A2%83/</url>
    
    <content type="html"><![CDATA[<blockquote><p>这是关于追捕玛卡巴卡的一夜梦，趁还还在便记录下来&#x3D;&#x3D;</p></blockquote><p>这几天感冒了，可能是空调连夜吹导致的，湖北的天气总是如此，夏天和冬天。</p><p>8月2日回到宿舍的时候，舍友H还在图书馆为上岸做准备，轮次换的饮水机纯净水他还没换，两天了都。</p><p>本着不过多消耗体能的目的，我去除了不必要的人体活动，去了床上，宿舍锁门之前，舍友H回来了，给我说起考研自习室的见闻，顺带提起了这两天楼下没有水可以换，但他给我准备了冰红茶在冰箱里云云。</p><p>第一场梦是关于另一位宿舍Y，他有床位但是没在宿舍住，他拎着两个礼盒回来了一趟，说是家里有什么喜事，礼盒里的东西嘛，一瓶奶茶不知道什么牌子，还有一桶柠檬红茶喊很大一桶，我见是他拎回来的，也觉着口渴，便喝了起来，只消一口那桶便见了底，刚尝了点味的我更渴了。</p><p>这时候人是已经醒了的，由于晚上没摄入水分的缘故，嘴里干的难受，想着冰箱里还有一瓶冰红茶，于是迅速下床，直本冰箱而去，看了看时间，凌晨三点多，一边吨吨吨喝一边窝在沙发椅中，再次上床的时候已经四点了。</p><p>第二场梦中，我是在医院，梦里的身体对比现实有缩水的成分在里面，大约是11-14岁的年纪，住院的原因是这副身体的主人感冒了，住院打点滴。在我隔壁床是一个小朋友，七八岁的样子只有，到了中午饭点，小朋友的父母来探望他，并且一起吃午饭病房里，我当时没有很饿就没有吃，直接拉上窗帘午睡。</p><p>我是被我妈喊醒的，在我午睡的时候，来看我的人很多，我爸我妈，兄长两个妹妹以及小学后就多年未见的爷爷奶奶，也给我带了家里做的饭，正好中午也没吃饭，在我吃饭的时候隔壁床的小孩也醒了，眼巴巴的看着我的食物，见状我分了一部分给他，他也就在他床上吃起来。</p><p>这个时候从门外进来查房的护士，看见这么多小孩就问，你家里几个小孩啊？我爸开着玩笑说：喏喏喏这五个都是我家的。</p><p>那个护士听完惊讶的走开了，那之后，我的病房靠走廊那边的玻璃上不时都会倒映出三三两两人影来，毕竟对于群众而言，一个家庭五个孩子在这个时代是极为罕见的。</p><p>在这场围观中，群众的内心都是很满足的，除了我们一家。这时不知谁提议说下午出去逛逛吧，于是就商量了起来。</p><p>我很开心，因为我也在他们的提议中。商讨完毕我爸我妈他们就出去了，去医院外面等我和我哥，我哥在这陪着我待我整理好后和我一块过去。</p><p>不得不说，这个医院是真的很大，我只知道我住的地方是住院部，我从病房出来到住院部的门就要弯弯绕绕好久，住院部的门到医院大门的距离更别说要多远了，百草园到三味书屋那么远吧。</p><p>当我整理好，我和我哥就开始出发，我们弯弯绕绕走到住院部门的时候，我突然想起自己有一个卡片没带，这个卡片是我可以出门的证明。</p><p>没有办法我只好返回去拿卡片，但是我让我哥自己先去医院门口等我，自己一个人回去。</p><p>不得不说，这个年纪的身体就是有活力，我返回是跑着的，一路上看见护士和护工在搬运医疗器械或者桌椅什么的，我当时的想法就是，读护理专业的话如果么有很好的资源就只能在医院里找工作，然后出力出人。</p><p>无心感慨其他，我拿到卡片后继续往医院门口跑去。</p><p>出了住院部，整个医院全貌堪堪一窥。待我到达医院门口的时候，当时已经下午16:00左右，我因为自己耽误大家一个小时余而没有很高的兴致，但是家人没有因为这个有所抱怨。</p><p>再次有意识是在一座高山山顶，这具身体已经和现实中我年龄一样了，我和我的二十余位兄弟来此听讲师讲课。我问她，人这一生最珍贵的是什么？她说，得不到的和已经失去的。</p><p>听完这句话，我疯了，披头散发狂奔在山上，然后跳下山崖。</p><p>我的二十余位兄弟见状，献祭自己，为了让我重活一世。</p><p>当我再次醒来，在医院的病床上，我当时就想，上面的经历是真还是假，或者是是这具身体主人睡觉时的异想罢了。</p><p>床边的医生告诉我，下午我就可以出院了，我看了看时间，过去两天半。</p><p>下午离开的时候，医院的场景和我见到的一模一样。</p><p>在住院部门口，和一个大爷擦肩而过。</p><p>后面的生活里，我好像是失去了什么，一时间也没有印象，便没有在意。</p><p>后来我读完大学，去一个地方工作，又遇到了那个大爷，他在这当门卫，工资待遇非常人可比。</p><p>闲聊时我问他每个月多少米，这时候他却告诉我他有超能力，因为用我和他擦肩而过的方式，把能力传导到了公司老板的儿子，不过是一个从天而降一个拔地而起。</p><p>我第一次见到老板儿子的感觉就是，他是三级阀点觉醒，后提升到了四级。</p><p>门卫大爷是一级阀点，一级异能。</p><p>现在关于我失去的那部分印象，我全记起来了。</p><p>他们的能力来源于我，异能传导方式为相向运动。</p><p>随着记忆回复的，还有我的能力，本着平常心，我仍在这里工作。</p><p>后经人说媒，认识一个女生，在烟草局工作，人美声甜。</p><p>万恶的相亲，唉</p><p>确认关系以后，我也带着她她也见过我父母。</p><p>但是我还没去她家，醒了。</p><p>所以，婚没结成( •̥́ ˍ •̀ू )</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>今朝有酒今朝醉</title>
    <link href="/2023/07/10/%E4%BB%8A%E6%9C%9D%E6%9C%89%E9%85%92%E4%BB%8A%E6%9C%9D%E9%86%89/"/>
    <url>/2023/07/10/%E4%BB%8A%E6%9C%9D%E6%9C%89%E9%85%92%E4%BB%8A%E6%9C%9D%E9%86%89/</url>
    
    <content type="html"><![CDATA[<p>长安三万里，强推给喜欢唐诗宋词，有文艺情怀的人。</p><p>画面美不胜收，有浪漫唯美，有诗情画意，也有悲凉壮阔。</p><p><img src="/img/36035676/p2886577292.jpg"></p><p>当听到熟悉的诗词在相契合的场景被念出的时候，真的很激动。</p><p>前一刻还在感概，少年人的今夕何在，下一刻又沉浸在诗人烂漫的幻想里。</p><p><img src="/img/36035676/p2894008733.jpg"></p><p>肆意才情，山河卫戍，从不夜长安的盛景到国破残楼。</p><p>一个像块坚石，在边塞沙场领将涉命，也在梁园乡野搁置过，国破家亡之时最能明白普通人连守常都无法拥有的那种惊恐失措，更看得清政治斗争之下的暗流。</p><p><img src="/img/36035676/p2895393518.jpg"></p><p>而另一个是潇洒饮者，桀骜也同样天真幼稚，官场入世不得便寻出世山河，最后却还是离不开乱世的抱负，又再惊慌入世，却被政治裹挟，但不管在盛世还是乱世，斗酒纵情只为当下能有片刻就已是生命中最大的欢欣与不易，他的醉意人生更成为了唐、唐诗、诗人都不及的神话，这样一个人，仅存在过就已经是盛唐最好的历史留影。</p><p><img src="/img/36035676/2175717127b8aedcec3b248f8ceebc1.jpg"></p><p>没有像妖猫传一样恢弘的唐宫视觉，它只是在追看两个人的生命，是曾坐在教室背诗的我不曾看过的那一面生命，始终对这个时代满怀热情，一心当为大鹏；始终羁绊朋友念及家人，不舍情义二字；始终把断续的离合都当作最后一次去互勉，你我终会如愿；始终把今朝当作最后一瞬去生活，终其一生，仅此而已。</p><p>再多的科学预测与冷静，也无法完全应对人生所有的冲击，这时神话的语言反而更加贴切，而这两颗星辰以及身边那些同样灼灼的星辰，就是那个时代最浪漫不渝、勇敢不屈的神话。</p><p><img src="/img/36035676/p2895317039.jpg"></p><p><img src="/img/36035676/1ae6e889e15a88fbff53d348d5b135e.jpg"></p><p>可能是到目前为止看过的最浪漫的一部国漫了，至交情谊，一起亲历，是另一种程度的浪漫！电影故事暗含了人的一生，借用少年时的鹏程万里，青年时的上下求索，中年时的事与愿违，老年时的盛极而衰。将中式浪漫展现极致：<strong>无论如何，人生漫漫，总有再会时!</strong></p><p><em><strong>只要黄鹤楼的诗还在，黄鹤楼就在；只要诗在，长安，就会在~</strong></em></p><p><img src="/img/36035676/305a015eec5b2ca4f59c2784283b1ec.jpg"></p>]]></content>
    
    
    <categories>
      
      <category>影评</category>
      
    </categories>
    
    
    <tags>
      
      <tag>影评</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Mysql基础</title>
    <link href="/2023/07/07/Mysql%E5%9F%BA%E7%A1%80/"/>
    <url>/2023/07/07/Mysql%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<h1 id="Mysql数据库基础"><a href="#Mysql数据库基础" class="headerlink" title="Mysql数据库基础"></a>Mysql数据库基础</h1><blockquote><p>很基础的语法知识，真的很基础，等需要学到进阶一点再更新</p></blockquote><br/><h2 id="–建表"><a href="#–建表" class="headerlink" title="–建表"></a>–建表</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs mysql">create table `table_name`<br>(<br>    `fieid` datatype,<br>    `fieid` datatype,<br>)character set collate engine<br></code></pre></td></tr></table></figure><p><strong>fieid</strong>：列名</p><p><strong>datatype</strong>：列类型（字段类型）</p><p><strong>character set</strong>：字符集（不指定默认为数据库类型）</p><p><strong>collate</strong>：校对规则（不指定默认为数据库校对规则）</p><p><strong>engine</strong>：引擎</p><br/><br/><br/><h2 id="–char与varchar"><a href="#–char与varchar" class="headerlink" title="–char与varchar"></a>–char与varchar</h2><ul><li>char（n） n是固定字符数，不论是中文或是英文都存放n个固定字符数，就算没有达到n也会占用n个字符空间</li><li>varchar（n） n是可变字符数，根据实际值占用相对应的空间，具体占用多少字节空间取决于编码格式（utf是2n，gdk是3n）</li><li>varchar（n） 本身会占用1-3个字节空间用于记录存放字节的长度，因此实际可使用的字节空间要小于n</li><li>char的查询速度比varchar要快</li></ul><br/><br/><br/><h2 id="–基本函数"><a href="#–基本函数" class="headerlink" title="–基本函数"></a>–基本函数</h2><p>暂略</p><br/><br/><h2 id="–表的操作"><a href="#–表的操作" class="headerlink" title="–表的操作"></a>–表的操作</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs mysql">--新增列<br>alter table `table_name`<br>      add `fieid` varchar(32) not null default ``--设置不允许为空，默认值为null<br>      after `fieid`<br><br>--显示表结构<br>desc `table_name`<br><br>--修改列的长度<br>alter table `table_name`<br>      modify `fieid` varchar(60) not null default ``<br><br>--删除列<br>alter table `table_name`<br>      drop `fieid`<br><br>--修改表名<br>rename table `table_name` to `newTable_name`<br><br>--修改表的字符集<br>alter table `table_name` character set utf-8<br><br>--修改列名<br>alter table `table_name`<br>      change `fieid` `newFieid` varchar(32) not null default ``<br></code></pre></td></tr></table></figure><br/><br/><h2 id="–CRUD"><a href="#–CRUD" class="headerlink" title="–CRUD"></a>–CRUD</h2><p><strong>Create</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mysql">insert into `table_name` (fieid , fieid ,fieid)<br>  values(`` , `` , ``),(`` , `` , `` )--此处顺序需要与列字段一致<br><br>--如果想指定列的某个字段默认值，在创建表的时候设置默认值即可<br></code></pre></td></tr></table></figure><p><strong>Update</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mysql">update `table_name` <br>  set `fieid` = xxx ，`fieid` = xxx<br>  where `fieid`= xxx--条件，修改哪一行，不写默认修改全部<br></code></pre></td></tr></table></figure><p><strong>Delete</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">delete from `table_name`<br>  where `filed` = xxx<br></code></pre></td></tr></table></figure><p><strong>Retrieve</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs mysql">select (distinct) `fieid` , `fieid` from `table_name` --（distinct只有每个字段都相同才会去重）<br>  where `条件`                      <br><br>--使用运算和别名的方式查询<br>select `fieid` , (`fieid` + `fieid`) as `别名` from `table_name`<br><br>--排序<br>select `fieid` from `table_name`<br>  where `xxx`<br>    order by `fieid`（也可以使用别名） ase  --升序（默认）/ desc 降序<br><br>--统计和平均值<br>--count()不会统计为NULL的行<br>select sum(`fieid`) , avg(`fieid`) , count(`fieid`) from `table_name`<br><br>--最值<br>select max(`fieid`) , min(`fieid`) from `table_name`<br><br>--group by 与 having<br>--group by：对重复的元素转成一组<br>--having：对分组后的数据进行过滤，作用替代where<br>select avg(`fieid1`) as `avg_fieid1`, min(`fieid2`) , `fieid3` <br>  from `table_name` --处fieid3列在表中含有多个相同的元素<br>    group by `fieid3` having `avg_fieid1`&lt;2000 --使用别名效率高，避免重复使用计算平均数函数<br><br>--分页<br>--start：开始的数量，表从start+1开始取<br>--row：显示多少行<br>select... limit(start , row)<br>--每页展示n条数据，显示第m页 ：<br>select... limit(n*(m-1),n)<br><br>--语法顺序：分组-&gt;过滤-&gt;排序<br>select xxx from xxx<br>  group by xxx<br>    having xxx<br>      order by xxx desx<br>        limit xxx<br>  <br></code></pre></td></tr></table></figure><br/><p><strong>多表查询</strong></p><blockquote><p>user</p></blockquote><table><thead><tr><th>id</th><th>name</th><th>depId</th></tr></thead><tbody><tr><td>1</td><td>小明</td><td>10</td></tr><tr><td>2</td><td>小张</td><td>20</td></tr></tbody></table><blockquote><p>dep</p></blockquote><table><thead><tr><th>depId</th><th>address</th></tr></thead><tbody><tr><td>10</td><td>NewYork</td></tr><tr><td>20</td><td>China</td></tr></tbody></table><br/><p>两表联立查询</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">select * from user , dep<br></code></pre></td></tr></table></figure><blockquote><p>user , dep</p></blockquote><table><thead><tr><th>id</th><th>name</th><th>depId</th><th>depId</th><th>address</th></tr></thead><tbody><tr><td>1</td><td>小明</td><td>10</td><td>10</td><td>NewYork</td></tr><tr><td>1</td><td>小明</td><td>10</td><td>20</td><td>China</td></tr><tr><td>2</td><td>小张</td><td>20</td><td>10</td><td>NewYork</td></tr><tr><td>2</td><td>小张</td><td>20</td><td>20</td><td>China</td></tr></tbody></table><p>可见多表联立查询，是以笛卡尔积的方式组合在一起的，会有很多重复项</p><p>因此我们可以根据where条件限定两表相同的内容（或者包含的内容）从而进行筛选（where限制条件不能少于表-1）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">select * from user , dep where user.depId = dep.depId<br></code></pre></td></tr></table></figure><blockquote><p>user , dep</p></blockquote><table><thead><tr><th>id</th><th>name</th><th>depId</th><th>depId</th><th>address</th></tr></thead><tbody><tr><td>1</td><td>小明</td><td>10</td><td>10</td><td>NewYork</td></tr><tr><td>2</td><td>小张</td><td>20</td><td>20</td><td>China</td></tr></tbody></table><p>因为两表都含有depId列，查询depId字段时需要指定说明查询哪个表的depId，尽管两表相同。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">select `name` , `user.depId` ,`address` from user , dep where user.depId = dep.depId<br></code></pre></td></tr></table></figure><table><thead><tr><th>name</th><th>depId</th><th>address</th></tr></thead><tbody><tr><td>小明</td><td>10</td><td>NewYork</td></tr><tr><td>校长</td><td>20</td><td>China</td></tr></tbody></table><br/><p><strong>自连接</strong></p><blockquote><p>1.把一个表当作两个表来使用</p><p>2.为了易读性，需要给表名取别名，同理列名也可以取别名</p></blockquote><br/><blockquote><p>user</p></blockquote><table><thead><tr><th>id</th><th>name</th><th>bossId</th></tr></thead><tbody><tr><td>1</td><td>jack</td><td>5</td></tr><tr><td>2</td><td>mike</td><td>5</td></tr><tr><td>3</td><td>smith</td><td>2</td></tr><tr><td>4</td><td>roly</td><td>2</td></tr><tr><td>5</td><td>king</td><td>NULL</td></tr></tbody></table><p>需求：列出每个员工的姓名以及上级姓名</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mysql">select work.name as `职工` , boss.name as `老板`<br>  from user work , user boss<br>    where work.bossId = boss.id<br></code></pre></td></tr></table></figure><p><strong>外连接</strong></p><blockquote><p>左外连接后依然会保留左边表的全部内容，没有相关联的内容为NULL</p><p>右外连接后依然会保留右边表的全部内容，没有相关联的内容为NULL</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mysql">select xxx from<br>  `table1` left join `table2`<br>    on xxx --条件<br></code></pre></td></tr></table></figure><p>同理右外连接为</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mysql">select xxx from<br>  `table1` right join `table2`<br>    on xxx --条件<br></code></pre></td></tr></table></figure><p><strong>子查询</strong></p><blockquote><p>嵌套使用select语句，包括单行子查询和多行子查询，多行子查询用in</p><p>子查询的结果也可以当作临时表来使用</p></blockquote><br/><blockquote><p>user</p></blockquote><table><thead><tr><th>id</th><th>name</th><th>depId</th><th>sal</th></tr></thead><tbody><tr><td>1</td><td>jack</td><td>2</td><td>100</td></tr><tr><td>2</td><td>mike</td><td>2</td><td>150</td></tr><tr><td>3</td><td>lucy</td><td>1</td><td>400</td></tr><tr><td>4</td><td>smith</td><td>3</td><td>300</td></tr><tr><td>5</td><td>north</td><td>4</td><td>88</td></tr><tr><td>6</td><td>eric</td><td>4</td><td>50</td></tr><tr><td>7</td><td>a</td><td>1</td><td>1000</td></tr><tr><td>8</td><td>b</td><td>2</td><td>99</td></tr><tr><td>9</td><td>c</td><td>3</td><td>299</td></tr><tr><td>10</td><td>d</td><td>4</td><td>10</td></tr></tbody></table><p>需求：列出与jack在同一部门的员工</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs mysql">select * from user<br>  where depId = (<br>    select depId <br>    from user<br>    where `name` = `jack`<br>  )<br></code></pre></td></tr></table></figure><p>需求：列出比b工资高的同事</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs mysql">--方法一<br>select name from user<br>  where sal &gt; all(select sal from user<br>    where depId = 2)<br>    <br>--方法二<br>select name from user<br>  where sal &gt; (select max(sal) from user<br>    where depId = 2)<br>    <br>--可以看出，max操作的对象是列，而all或者any操作的对象是整个表<br></code></pre></td></tr></table></figure><p>子查询当作临时表来使用：</p><p>需求：列出每个部门中高于当前部门平均工资的员工</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs mysql">select name from user , (<br>    select depId , avg(sal) as avg_sal<br>    from user <br>    group by depId<br>  ) as temp<br>      where user.depId = temp.depId , user.sal &gt; temp.avg_sal<br></code></pre></td></tr></table></figure><br/><br/><h2 id="–约束"><a href="#–约束" class="headerlink" title="–约束"></a>–约束</h2><br/><h3 id="主键"><a href="#主键" class="headerlink" title="主键"></a>主键</h3><blockquote><p>约束一个表中的唯一列，该列的关键字不能重复且不能为空</p></blockquote><p><strong>语法：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs mysql">--方式一<br>create table `table1`(<br>  id int primary key,<br>  `name` varchar(32),<br>  email varchar(32),<br>)<br>--方式二<br>create table `table1`(<br>  id int,<br>  `name` varchar(32),<br>  email varchar(32),<br>  primary key(id)<br>)<br></code></pre></td></tr></table></figure><p><strong>一个表中只能拥有一个主键，但是可以用有复合主键</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs mysql">create table `table1`(<br>  id int ,<br>  `name` varchar(32),<br>  email varchar(32),<br>  primary key(id , `name`) --复合主键<br>)<br></code></pre></td></tr></table></figure><p>这种情况下，id与name组合成为了一个复合组件，只有当他们俩都相同的时候，才违反了主键不能重复的原则</p><br/><h3 id="unique"><a href="#unique" class="headerlink" title="unique"></a>unique</h3><blockquote><p>约束该列的值唯一，不可以重复</p></blockquote><p><strong>语法：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs mysql">create table `table1`<br>  id int unique,<br>  `name` varchar(32),<br>  email varchar(32),<br>)<br></code></pre></td></tr></table></figure><p><strong>如果该列没有指定非空（NOT NULL），则可以允许多个NULL值</strong></p><p><strong>一个表中可以允许多个unique存在</strong></p><br/><h3 id="外键"><a href="#外键" class="headerlink" title="外键"></a>外键</h3><blockquote><p>约束两个表的直接联系，外键所在表和主表相绑定，从此无法轻易添加或删除</p></blockquote><p><strong>语法：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs mysql">--主表<br>create table my_class(<br>  id int primary key,<br>  `name` varchar(32) not null default ` `);<br><br>--从表<br>create table my_stu(<br> id int primary key,<br> `name` varchar(32) not null default ` `,<br> classId int,<br> foreign key (classId) references my_class(id)--指定外键关系<br></code></pre></td></tr></table></figure><p><strong>外键所指向主表的列必须为主键或者有unique约束，且数据类型必须一致</strong></p><p><strong>表的类型必须为innodb才支持外键</strong></p><p><strong>外键的值必须与所指向主表中列的值保持一致，但如果外键允许为空，则该外键也可以添加为NULL的字段。</strong></p><br/><h3 id="check"><a href="#check" class="headerlink" title="check"></a>check</h3><blockquote><p>指定某个字段的范围，在MySQL中只做了语法校验，并没有生效（Mysql8以上除外）</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mysql">create table my_class(<br>  id int primary key,<br>  `sex` varchar(6) check(sex in(`man`,`woman`)));--sex只能是man/woman<br></code></pre></td></tr></table></figure><br/><h3 id="自增长"><a href="#自增长" class="headerlink" title="自增长"></a>自增长</h3><blockquote><p>指定某一列自动增长，需要配合unique或者主键使用</p></blockquote><p><strong>语法：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs mysql">create table my_class(<br>  id int primary key auto_increment,<br>  `sex` varchar(6) check(sex in(`man`,`woman`)));--sex只能是man/woman<br><br>--修改自增长开始数<br>alter table my_class auto_increment = 10;<br></code></pre></td></tr></table></figure><p><strong>一般情况下，我们在新增数据时，无需顾及到自增长的字段，它会自动增长，无需手动赋值</strong></p><p><strong>但如果我们手动给自增长字段赋值，那么该字段的值不会自增长，成为你赋的值，同时下一个数据自增长从你赋的值开始（类似于走后门，同时不建议这么做）</strong></p><br/><br/><h2 id="–索引"><a href="#–索引" class="headerlink" title="–索引"></a>–索引</h2><blockquote><p>对列（字段）增加索引可以大幅度增加查询速度</p><p>以空间换时间</p></blockquote><p><strong>语法：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs mysql">--关键字：index ... on<br>create index `索引名字` on my_table(`字段`)<br><br>--查询表中的所有索引<br>show index from my_table<br>show keys from my_table<br><br>--删除索引<br>drop index `索引名` on my_table<br><br>--删除主键索引<br>alter table my_table drop primary key<br><br>--修改索引：需要先删除，再增加新的索引。<br></code></pre></td></tr></table></figure><br/><p><strong>为什么加了索引查询会快很多？</strong></p><ul><li><p>在不加索引的情况下：</p><p>默认会对表中的所有数据进行扫描（遍历），即使查询的数据就在表的第一个也会继续向下查找，判断有没有重复相同的项目。因此不加索引是对表全盘扫描。</p></li><li><p>索引的原理是什么：</p><p>实质是对表进行了一种数据结构的排序，比如二叉树，B+树等，这里以二叉树为例子。</p><p>二叉树在表有顺序的情况下，拿取中间的数作为顶端数头，同时把数据分成两个部分，其余部分依次以二分法的方式拿取值，依次与树头进行比较。</p><p>比数头小的放在左边，大的放在右边，一次堆叠成一棵树。</p><p>这样查询时只需要和每一个树头的大小进行比较就可以快速定位至目标数。</p><p>例如，找到id&#x3D;4只需要先比较5-&gt;2-&gt;3-&gt;4即可。</p><p>因此加了索引，不是对表进行全盘扫描诶个读取，速度自然快很多。<img src="/img/mysql/23b88c3a4f567d045572606e0e6fabdf.png"></p></li></ul><br/><p><strong>使用索引的代价是什么？</strong></p><ol><li>占用更大的储存空间。以800万的数据为例，不创建索引时，文件大小500MB左右，加了一个索引后，文件大小有637MB左右。是以牺牲空间来换取查询时间的。</li><li>对增删改效率有影响。以上述二叉树为例，增删改会重新生成二叉树，对索引进行维护。</li></ol><br/><p><strong>索引的分类：</strong></p><ol><li>主键索引，创建主键的时候即为主键索引。</li><li>唯一索引，创建unique的时候为唯一索引。</li><li>普通索引，手动index创建的，与上面的区别在于允许值重复。</li><li>全文索引，fulltext关键字，mysql自带的不建议使用，一般开发使用全文搜索框架：Solr和ElasticSearch（ES）。</li></ol><br/><br/><h2 id="–事务"><a href="#–事务" class="headerlink" title="–事务"></a>–事务</h2><blockquote><p>保证事务的一致性，要么全部成功，要么全部失败。情景：转账</p></blockquote><p><strong>语法：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs mysql">start transaction --开始一个事务<br>set autocommit --同上，第二种写法<br>savepoint `保存点名`--设置保存点<br>rollback to `保存点名`--回退事务到保存点名<br>rollback --回退所有事务<br>commit --提交事务，所有操作生效，不能回退<br></code></pre></td></tr></table></figure><p><strong>当回退到一个保存点后，该表存点之后的所有保存点都将失效。</strong></p><p><strong>InnoDB引擎支持事务，MYISAM不支持事务。</strong></p><br/><p><strong>事务的acid特性</strong></p><ul><li><p><strong>原子性</strong></p><p>指事务是一个不可分割的工作单位，事务中的操作要么全部发生，要么全部不发生。</p></li><li><p><strong>一致性</strong></p><p>事务必须使数据库从一个一致性状态变换到另外一个一致性状态。</p></li><li><p><strong>隔离性</strong></p><p>事务的隔离性是多个用户并发访问数据库时，数据库为每个用户开启的事务，不能被其他事务的操作数据所干扰，多个并发事务之间要相互隔离。</p></li><li><p><strong>持久性</strong></p><p>指一个事务一旦被提交，他对数据库中数据的改变就是永久性的，接下来即使数据库发生故障也不应该对其有任何影响。</p></li></ul><br/><h3 id="事务的隔离"><a href="#事务的隔离" class="headerlink" title="事务的隔离"></a>事务的隔离</h3><blockquote><p>在多链接的情况下，防止多个用户对同一个数据操作产生的差异，类似多线程</p></blockquote><br/><ul><li><p><strong>脏读：</strong></p><p>  可以看到一方在未提交时改变的数据及为脏读。</p></li><li><p><strong>不可重复读：</strong></p><p>  可以看到一方在未提交时对数据所做的更改和删除及为不可重复读。</p></li><li><p><strong>幻读：</strong></p><p>  可以看到一方在未提交时新增的数据及为幻读。</p></li></ul><br/><p><strong>事务的隔离级别：</strong></p><table><thead><tr><th align="center">Mysql隔离级别（4种）</th><th align="center">脏读</th><th align="center">不可重复读</th><th align="center">幻读</th><th align="center">加锁读</th></tr></thead><tbody><tr><td align="center">读未提交（Read uncommitted）</td><td align="center">V</td><td align="center">V</td><td align="center">V</td><td align="center">不加锁</td></tr><tr><td align="center">读已提交（Read committed）</td><td align="center">X</td><td align="center">V</td><td align="center">V</td><td align="center">不加锁</td></tr><tr><td align="center">可重复读（Repeatable read）</td><td align="center">X</td><td align="center">X</td><td align="center">X</td><td align="center">不加锁</td></tr><tr><td align="center">可串行化（Serializable）</td><td align="center">X</td><td align="center">X</td><td align="center">X</td><td align="center">加锁</td></tr></tbody></table><br/><p><strong>语法：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mysql">set session transaction isolation level --设置隔离级别<br><br>select @@transaction_isolation;--查看当前隔离级别<br></code></pre></td></tr></table></figure><br/><h2 id="–引擎"><a href="#–引擎" class="headerlink" title="–引擎"></a>–引擎</h2><ul><li><p><strong>innodb</strong></p><p>默认的引擎，支持事务，支持外键，支持行级锁</p></li><li><p><strong>myisam</strong></p><p>添加速度快，不支持事务，不支持外键，支持表级锁</p></li><li><p><strong>memory</strong></p><p>数据储存在内存中（关闭Mysql，数据丢失，表结构还存在），执行速度很快（内存中没有io读写），默认支持索引，基于哈希表，不支持事务，不支持外键</p></li></ul><br/><h2 id="–视图"><a href="#–视图" class="headerlink" title="–视图"></a>–视图</h2><blockquote><p>选择一个表&#x2F;视图，可以控制该表展示哪些内容，类似权限控制</p><p>视图是根据基本表来创建的，视图是一个虚拟的表，数据也来源于基表</p><p>视图与基表之间是映射关系</p></blockquote><p><strong>语法</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mysql">create view `视图名` as select `字段` , `字段` , `字段` from `基表`<br><br>--删除视图<br>drop view `视图名`, `视图名`<br></code></pre></td></tr></table></figure><p><strong>多表查询的结果可以用视图保存，方便下一次查询</strong></p>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>mysql</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java基础</title>
    <link href="/2023/07/06/Java%E5%9F%BA%E7%A1%80/"/>
    <url>/2023/07/06/Java%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<h1 id="Java基础"><a href="#Java基础" class="headerlink" title="Java基础"></a>Java基础</h1><blockquote><p>基于jdk8，学习后会更新</p></blockquote><h2 id="—-static"><a href="#—-static" class="headerlink" title="—-static"></a><strong>—-static</strong></h2><ul><li><p>可以直接调用，不需要类名（对象名）。</p></li><li><p>static修饰的方法中只能调用static修饰的变量（包括方法），而普通方法中可以调用所有的变量和方法。（遵守修饰符规定）</p></li><li><p>static修饰的变量和方法，随着类的加载而加载，因此在对象<strong>未实例化时</strong>也可直接调用。</p></li><li><p>static修饰的代码块只会执行一次。</p></li></ul><br/><h2 id="—-类加载、构造器、执行顺序"><a href="#—-类加载、构造器、执行顺序" class="headerlink" title="—-类加载、构造器、执行顺序"></a><strong>—-类加载、构造器、执行顺序</strong></h2><br/><p><img src="/img/java/2b6a7fae7706d956d62fc60bd0932ec2.png"></p><p>静态加载：在编译时就加载相关的类，依赖性强</p><p>动态加载：运行时加载需要的类，不需要时不加载，降低依赖性</p><br/><p><strong>类什么时候加载？</strong></p><ol><li>实例化对象时(new)，静态加载</li><li>子类被加载时，父类也会加载，静态加载</li><li>调用类的静态成员时，静态加载</li><li>通过反射，动态加载</li></ol><br/><p><strong>注意事项：</strong></p><ul><li><p>类的加载不代表对象的实例，只有对象的实例才会引起类的构造器。</p></li><li><p>类只会加载一次。</p></li><li><p>static和final一起使用的变量不会引起类的加载。</p></li></ul><br/><p><strong>实例类的执行顺序：</strong></p><ul><li>同一个类的情况下：</li></ul><ol><li>静态代码块和静态属性（根据定义顺序）</li><li>普通代码块和普通属性（根据定义顺序）</li><li>构造器</li></ol><ul><li>继承的情况下：</li></ul><ol><li>父类的静态代码块和静态属性（根据定义顺序）</li><li>子类的静态代码块和静态属性（根据定义顺序）</li><li>父类的普通代码块和普通属性（根据定义顺序）</li><li>父类的构造器</li><li>子类的普通代码块和普通属性（根据定义顺序）</li><li>子类的构造器</li></ol><br/><p><strong>设计模式：</strong></p><p><strong>饿汉式单例模式（在类加载时便创建对象）</strong></p><ol><li>构造器私有化</li><li>在类加载时创建对象</li><li>对外暴露调用对象的静态方法</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Cat</span>&#123;<br>  <span class="hljs-keyword">private</span> String name;<br>  <span class="hljs-keyword">private</span> <span class="hljs-title function_">Cat</span><span class="hljs-params">(String name)</span>&#123;   <span class="hljs-comment">//构造器私有化</span><br>    <span class="hljs-built_in">this</span>.name = name;<br>  &#125;<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Cat cat=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Cat</span>(<span class="hljs-string">&quot;小白&quot;</span>);   <span class="hljs-comment">//static下不创建对象直接调用</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Cat <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span>&#123;    <span class="hljs-comment">//static下不创建对象对外暴露对象接口</span><br>    <span class="hljs-keyword">return</span> cat;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><br/><p>**懒汉式单例模式（类加载时不创建对象，需要时才创建对象） **</p><ol><li>构造器私有化</li><li>定义一个static的静态对象</li><li>在对外暴露调用对象的静态方法时再创建对象</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Cat</span>&#123;<br>  <span class="hljs-keyword">private</span> String name;<br>  <span class="hljs-keyword">private</span> <span class="hljs-title function_">Cat</span><span class="hljs-params">(String name)</span>&#123;   <span class="hljs-comment">//构造器私有化</span><br>    <span class="hljs-built_in">this</span>.name = name;<br>  &#125;<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Cat cat;   <span class="hljs-comment">//创建但不实例化</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Cat <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-keyword">if</span>(cat == <span class="hljs-literal">null</span>)&#123;    <span class="hljs-comment">//判断是否实例化</span><br>      cat = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Cat</span>(<span class="hljs-string">&quot;小白&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> cat;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><br/><h2 id="—-接口"><a href="#—-接口" class="headerlink" title="—-接口"></a><strong>—-接口</strong></h2><br/><p>接口是对继承的一种补充</p><ul><li>接口中的属性默认修饰为public static final。</li><li>接口可以被接口继承，被类实现。</li></ul><br/><p>只要有基本数据类型和包装类进行比较，比较的是值是否相等，Integer的源码可知，-128~127之间的自动包装不会new一个新的对象。</p><br/><h2 id="—-异常"><a href="#—-异常" class="headerlink" title="—-异常"></a>—-异常</h2><blockquote><p>防止因为外部因素程序出错导致的程序终止。</p></blockquote><p>运行时异常：程序运行时发生的异常。</p><p>编译时异常：程序编译时发生的异常。</p><br/><p><strong>异常处理机制：</strong></p><br/><br/><br/><h2 id="—-String、StringBuffer与StringBuilder"><a href="#—-String、StringBuffer与StringBuilder" class="headerlink" title="—-String、StringBuffer与StringBuilder"></a>—-String、StringBuffer与StringBuilder</h2><br/><p><strong>String</strong></p><p>String保存的是字符串常量，里面的值不能更改，每次更新String类，并不是在原先的值上做改动，而是在池中<strong>新增</strong>或者<strong>匹配</strong>已经存在改动后的值，由value指向它。<strong>实际上String类的更新，是更新它所指向的地址。</strong></p><p><strong>常量相加，看的是池，变量相加，看的是堆。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;abc&quot;</span>;<br><span class="hljs-type">String</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;123&quot;</span>;<br><span class="hljs-type">String</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> a + b;<br><span class="hljs-comment">//源码分析：在c这一步中：</span><br>StringBuilder sb=<span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();<br>sb.apend(a);<br>sb.apend(b);<br><span class="hljs-type">String</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> sb.toString();<span class="hljs-comment">//toString()方法会在池中创建一个新的对象</span><br><span class="hljs-comment">//在堆中新建了一个value[]对象，由c指向它。</span><br><span class="hljs-comment">//在池中新建了一个对象，用于存放拼接好的字符串，由value[]对象指向它。</span><br></code></pre></td></tr></table></figure><img src="/img/java/719d7e0c5ac64eb1cd5833aa4322d5ce.png" alt="screen-capture" style="zoom:60%;" /><br/><p><strong>StringBuffer与StringBuilder</strong></p><br/><p>StringBuffer默认为16字符串数组的容器，与String不同的是，他指向的地址可以保持不变，改变其中的值，而不改变地址。在超出容量之后，才会改变地址指向新增的扩容后的地址，他们都在堆中。</p><br/><p>String与StringBuffer相互转换中，append方法与StringBuffer构造器方法的区别：</p><ul><li><p>apped方法添加空指针的字符串会手动拼接长度为4的null的字符数组。</p></li><li><p>利用构造器会判断传入字符串的长度，调用.length方法，会报空指针异常。</p></li></ul><table><thead><tr><th align="center"></th><th align="center">效率</th><th align="center">线程安全</th><th align="center">区别</th></tr></thead><tbody><tr><td align="center"><strong>String</strong></td><td align="center">低</td><td align="center">-</td><td align="center">改变的是地址而非值，复用性最高</td></tr><tr><td align="center"><strong>StringBuffer</strong></td><td align="center">中</td><td align="center">多线程安全</td><td align="center">改变值，在不超出容量的前提下不改变地址</td></tr><tr><td align="center"><strong>StringBuilder</strong></td><td align="center">高</td><td align="center">多线程不安全，适合单线程</td><td align="center">改变值，在不超出容量的前提下不改变地址</td></tr></tbody></table><br/><br/><h2 id="—-HashSet"><a href="#—-HashSet" class="headerlink" title="—-HashSet"></a>—-HashSet</h2><br/><p>本质是一个数组链表（相邻表）。<strong>不可添加相同的数据</strong>，并且数据在表中排序与数据添加<strong>先后顺序无关</strong>，与该数据的Hash值有关，且输出顺序固定。</p><p>添加：</p><img src="/img/java/fc5d88bc104e9822e57e6334f41f439b.png" alt="HashSet.png" style="zoom:80%;" /><p>如上图Dog添加到表中，优先将Dog对象的hashCode根据算法算出Hash值，再根据Hash值匹配table序列，如果匹配到的序列中没有存放值，则直接添加到首位，否则继续一次匹配该序列中该对象和链表中的每一个值（此处调用equals）是否相同。</p><ol><li>HashSet的底层是HashMap。</li><li>添加一个元素时，会根据该元素的HashCode-&gt;Hash值，这个Hash-&gt;索引值。</li><li>判断该索引值在table数据表中是否存在，不存在则直接添加，存在则继续下一步判断。</li><li>调用equals比较，如果相同则放弃添加，不同则直接在链表末尾添加。</li></ol><br/><p><strong>注意事项：</strong></p><br/><ol><li>新增值时，可以手动重写该对象的HashCode方法和Equals方法，人为控制哪些元素是否是相同的</li><li>HashSet的table表默认长度为16，但并不会等填满16个元素 之后才扩容，而是在总长度*0.75个长度单位时就会以2倍总长度扩容，并在下次达到临界值（x0.75）时继续扩容，例如：16（12）-&gt;32（24）-&gt;64（48）-&gt;…</li><li>如果一条链表的元素个数超过8，并且table的总长度&gt;&#x3D;64，才会进行树化（红黑树）</li></ol><br/><h2 id="—-HashMap与HashTable"><a href="#—-HashMap与HashTable" class="headerlink" title="—-HashMap与HashTable"></a>—-HashMap与HashTable</h2><br/><table><thead><tr><th align="center"></th><th align="center">版本</th><th align="center">线程同步</th><th align="center">效率</th><th align="center">允许null键和值</th><th align="center">扩容</th><th align="center">初始容量</th></tr></thead><tbody><tr><td align="center"><strong>HashMap</strong></td><td align="center">1.2</td><td align="center">不同步</td><td align="center">高</td><td align="center">是</td><td align="center">2倍</td><td align="center">16（12）</td></tr><tr><td align="center"><strong>HashTable</strong></td><td align="center">1.0</td><td align="center">同步</td><td align="center">低</td><td align="center">否</td><td align="center">2倍+1</td><td align="center">11（8）</td></tr></tbody></table><br/><br/><h2 id="—-线程"><a href="#—-线程" class="headerlink" title="—-线程"></a>—-线程</h2><br/><p>在一个线程start（）方法中，真正开启线程的并不是start（）方法里面的run（）方法，而是start0（），它是一个native本地方法，由JVM调用，底层是C&#x2F;C++实现的。</p><p><img src="/img/java/5542f47236383d1b2f3524fa9427bff4.png"></p><br/><br/><h2 id="—-IO流"><a href="#—-IO流" class="headerlink" title="—-IO流"></a>—-IO流</h2><br/><br/><table><thead><tr><th align="center"></th><th align="center">字节流</th><th align="center">字符流</th></tr></thead><tbody><tr><td align="center"><strong>输入流</strong></td><td align="center">InputStream</td><td align="center">Reader</td></tr><tr><td align="center"><strong>输出流</strong></td><td align="center">OutputStream</td><td align="center">Writer</td></tr></tbody></table><br/><p>字节流与字符流：</p><ul><li><p>字节流（8bit）二进制文件，通常保存声音，视频，图片，pdf，word等。</p></li><li><p>字符流，按照字符形式读取，适合读取文本信息。</p></li></ul><br/><table><thead><tr><th align="center">分类</th><th align="center">功能</th><th align="center">类型</th></tr></thead><tbody><tr><td align="center">FileXXX</td><td align="center">访问文件</td><td align="center">节点流</td></tr><tr><td align="center">StringXXX</td><td align="center">访问字符串</td><td align="center">节点流</td></tr><tr><td align="center">BuffereXXXXX</td><td align="center">访问字符串</td><td align="center">处理流</td></tr><tr><td align="center">ObjectXXX</td><td align="center">序列化和反序列化</td><td align="center">处理流</td></tr></tbody></table><br/><p>节点流和处理流（包装流）：</p><ul><li>节点流是底层流，直接和数据源相连。</li><li>处理流，对节点流的一种包装，可以实现各种节点流，消除不同节点流的实现差异，采用了<strong>修饰器设计模式</strong>，体现了多态的特点。</li></ul><br/><p>fileWrite必须要在close（）或者flush（）方法之后才会写入数据，否则只会将数据保存在内存中。</p><br/><p>序列化和反序列化：</p><ul><li><p>序列化：在保存数据时，保存数据的<strong>数据类型</strong>与值；</p></li><li><p>反序列化：在恢复数据时，恢复数据的<strong>数据类型</strong>与值；</p></li></ul><p>要实现序列化机制，必须实现以下两个接口之一：</p><ul><li>Serializable（标记接口，里面没有任何方法）</li><li>Externalizable</li></ul><br/><p><del>Buffere是按照字符读取的，不可以读取二进制文件，可能造成文件损坏。</del></p><br/><p>ObjectXXX在序列化和反序列化时的使用注意事项：</p><ol><li>读写顺序要一致。</li><li>要求序列化和反序列化，需要实现Serializable接口，其对象属性也需要实现该接口。</li><li>序列化时候建议添加上SerialVersionUID属性，为了提高版本兼容性。（待定详细解释）</li><li>序列化对象时，默认将所有属性都进行序列化，有static和transient修饰的除外。</li><li>具备继承性。其子类也默认继承实现了Serialization接口。</li></ol><br/><p>项目：<a href="https://">多用户通讯系统</a></p><br/><h2 id="—-反射"><a href="#—-反射" class="headerlink" title="—-反射"></a>—-反射</h2><blockquote><p>不更改类的前提下控制程序</p><p>在框架方面会大量运用</p><p>jdk11以上</p></blockquote><p>Java反射机制可以完成：</p><ol><li>在程序运行时判断任意一个对象所属的类</li><li>在程序运行时构造任意一个类的对象</li><li>在程序运行时得到任意一个类所具有的成员变量和方法</li><li>在程序运行时调用任意一个对象的成员变量和方法</li><li>生成动态代理</li></ol><br/><p>通过反射获取类，该类的构造器、变量、方法等：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//目标类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">dog</span>&#123;<br>    <span class="hljs-keyword">public</span> String name;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> num;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> age;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">dog</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;无参构造器被调用&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">dog</span><span class="hljs-params">(String name, <span class="hljs-type">int</span> num)</span> &#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>        <span class="hljs-built_in">this</span>.num = num;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">hi</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;hi~&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">hi</span><span class="hljs-params">(<span class="hljs-type">int</span> num)</span>&#123;<br>        <span class="hljs-built_in">this</span>.num=num;<br>    &#125;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">eat</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;i want eat&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">private</span> String <span class="hljs-title function_">play</span><span class="hljs-params">(String name,Integer age)</span>&#123;<br>        <span class="hljs-keyword">return</span> name+<span class="hljs-string">&quot; &quot;</span>+age;<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;dog&#123;&quot;</span> +<br>                <span class="hljs-string">&quot;name=&#x27;&quot;</span> + name + <span class="hljs-string">&#x27;\&#x27;&#x27;</span> +<br>                <span class="hljs-string">&quot;age=&#x27;&quot;</span> + age + <span class="hljs-string">&#x27;\&#x27;&#x27;</span> +<br>                <span class="hljs-string">&quot;, num=&quot;</span> + num +<br>                <span class="hljs-string">&#x27;&#125;&#x27;</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//获取该类的Class对象</span><br>        Class&lt;?&gt; dogCls = Class.forName(<span class="hljs-string">&quot;Reflection.dog&quot;</span>);<br>        <span class="hljs-comment">//通过无参构造器创建实例</span><br>        <span class="hljs-type">Object</span> <span class="hljs-variable">dog</span> <span class="hljs-operator">=</span> dogCls.getDeclaredConstructor().newInstance();<br>        <span class="hljs-comment">//通过有参构造器创建实例</span><br>        <span class="hljs-type">Object</span> <span class="hljs-variable">dog1</span> <span class="hljs-operator">=</span> dogCls.getDeclaredConstructor(String.class, <span class="hljs-type">int</span>.class).newInstance(<span class="hljs-string">&quot;hello&quot;</span>, <span class="hljs-number">1</span>);<br>        System.out.println(dog.getClass());<span class="hljs-comment">//运行类型</span><br>        System.out.println(dog);<br>        System.out.println(dog1);<br>        System.out.println(dog1==dog);<span class="hljs-comment">//实例化的两个类不是同一个</span><br><br>        <span class="hljs-comment">//获取该类的属性   （属性名.对象名）</span><br>        <span class="hljs-type">Field</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> dogCls.getField(<span class="hljs-string">&quot;name&quot;</span>);<span class="hljs-comment">//获取该类的public属性</span><br>        name.set(dog,<span class="hljs-string">&quot;mike&quot;</span>);<span class="hljs-comment">//设置属性</span><br>        System.out.println(name.get(dog));<span class="hljs-comment">//获取属性</span><br>        <span class="hljs-type">Field</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span> dogCls.getDeclaredField(<span class="hljs-string">&quot;num&quot;</span>);<span class="hljs-comment">//获取该类的非public属性</span><br>        num.setAccessible(<span class="hljs-literal">true</span>);<span class="hljs-comment">//爆破，允许对非public进行操作</span><br>        num.set(dog,<span class="hljs-number">10</span>);<br>        System.out.println(num.get(dog));<br>        <span class="hljs-type">Field</span> <span class="hljs-variable">age</span> <span class="hljs-operator">=</span> dogCls.getDeclaredField(<span class="hljs-string">&quot;age&quot;</span>);<br>        age.setAccessible(<span class="hljs-literal">true</span>);<br>        age.set(<span class="hljs-literal">null</span>,<span class="hljs-number">20</span>);<span class="hljs-comment">//当该属性为static时，可以在对象形参写空，因为静态变量与类相绑定，而不是该类的对象</span><br>        System.out.println(age.get(<span class="hljs-literal">null</span>));<br><br>        <span class="hljs-comment">//获取该类的方法    （方法名.invoke(对象名)）</span><br>        <span class="hljs-type">Method</span> <span class="hljs-variable">hi</span> <span class="hljs-operator">=</span> dogCls.getMethod(<span class="hljs-string">&quot;hi&quot;</span>);<br>        hi.invoke(dog);<br>        <span class="hljs-type">Method</span> <span class="hljs-variable">eat</span> <span class="hljs-operator">=</span> dogCls.getDeclaredMethod(<span class="hljs-string">&quot;eat&quot;</span>);<br>        eat.setAccessible(<span class="hljs-literal">true</span>);<br>        eat.invoke(<span class="hljs-literal">null</span>);<br>        <span class="hljs-type">Method</span> <span class="hljs-variable">play</span> <span class="hljs-operator">=</span> dogCls.getDeclaredMethod(<span class="hljs-string">&quot;play&quot;</span>, String.class, Integer.class);<br>        play.setAccessible(<span class="hljs-literal">true</span>);<br>        <span class="hljs-type">Object</span> <span class="hljs-variable">john</span> <span class="hljs-operator">=</span> play.invoke(dog, <span class="hljs-string">&quot;John&quot;</span>, <span class="hljs-number">100</span>);<br>        System.out.println(john);<br></code></pre></td></tr></table></figure><br/><h2 id="JDBC"><a href="#JDBC" class="headerlink" title="JDBC"></a>JDBC</h2><blockquote><p>JDBC为访问不同的数据库提供了统一的接口，为使用者屏蔽了细节问题。</p></blockquote><br/><h3 id="—JDBC的原理示意图"><a href="#—JDBC的原理示意图" class="headerlink" title="—JDBC的原理示意图"></a>—JDBC的原理示意图</h3><p><img src="/img/java/c38ab5aa61256011e6c0473b01a13928.png"></p><br/><h3 id="—JDBC程序编写步骤"><a href="#—JDBC程序编写步骤" class="headerlink" title="—JDBC程序编写步骤"></a>—JDBC程序编写步骤</h3><ol><li>注册驱动-加载Driver类</li><li>获取链接-得到Connection</li><li>执行增删改查-发送SQL给数据库</li><li>释放资源-关闭相关链接</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//前置工作：需要将jar包导入到项目工程（add as library）</span><br><br><span class="hljs-comment">//1.注册驱动</span><br><span class="hljs-type">Driver</span> <span class="hljs-variable">driver</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Driver</span>();<br><br><span class="hljs-comment">//2.得到连接-底层是socket</span><br><span class="hljs-comment">//创建连接字符串</span><br>String url=<span class="hljs-string">&quot;jdbc:mysql://localhost:3306/数据库名字&quot;</span><br><span class="hljs-comment">//将用户名和密码放入一个Properties对象中</span><br><span class="hljs-type">Properties</span> <span class="hljs-variable">properties</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Properties</span>();<br>properties.setProperty(<span class="hljs-string">&quot;user&quot;</span>,<span class="hljs-string">&quot;root&quot;</span>)<span class="hljs-comment">//properties的key是规定好的</span><br>properties.setProperty(<span class="hljs-string">&quot;password&quot;</span>,<span class="hljs-string">&quot;123456&quot;</span>);<br><span class="hljs-comment">//获取连接</span><br><span class="hljs-type">Connection</span> <span class="hljs-variable">connect</span> <span class="hljs-operator">=</span> dirver.connect(url,properties);<br><br><span class="hljs-comment">//3.执行sql</span><br>String sql=<span class="hljs-string">&quot;xxx&quot;</span><br><span class="hljs-comment">//statement用于执行静态SQL语句并返回其生成结果的对象</span><br><span class="hljs-type">Statement</span> <span class="hljs-variable">statement</span> <span class="hljs-operator">=</span> connect.creatStatement();<br><span class="hljs-type">int</span> rows - statement.executeUpdate(sql);<span class="hljs-comment">//返回受影响的行数</span><br><br><span class="hljs-comment">//4.关闭连接资源</span><br>statement.close();<br>connect.close();<br></code></pre></td></tr></table></figure><br/><p><strong>连接的五种方式</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//1.直接创建</span><br><span class="hljs-type">Driver</span> <span class="hljs-variable">driver</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Driver</span>();<br><br><span class="hljs-comment">//2.通过反射动态加载，更加灵活，减少依赖性</span><br>Class&lt;?&gt; aClass = Class.forName(<span class="hljs-string">&quot;com.mysql.jdbc.Driver&quot;</span>);<br><span class="hljs-type">Driver</span> <span class="hljs-variable">driver</span> <span class="hljs-operator">=</span> (Driver)aClass.newInstance();<br><br><span class="hljs-comment">//3.通过DriverManager来统一管理</span><br>Class&lt;?&gt; aClass = Class.forName(<span class="hljs-string">&quot;com.mysql.jdbc.Driver&quot;</span>);<br><span class="hljs-type">Driver</span> <span class="hljs-variable">driver</span> <span class="hljs-operator">=</span> (Driver)aClass.newInstance();<br><br>String url=<span class="hljs-string">&quot;jdbc:mysql://localhost:3306/xxx&quot;</span>；<br>String user=<span class="hljs-string">&quot;root&quot;</span>;<br>String password=<span class="hljs-string">&quot;123456&quot;</span>;<br><br>DriverManager.registerDriver(driver);<span class="hljs-comment">//注册Driver驱动</span><br><span class="hljs-type">Connection</span> <span class="hljs-variable">connection</span> <span class="hljs-operator">=</span> DriverManager.getConnection(url,user,password);<br><br><span class="hljs-comment">//4.使用Class.forName自动完成注册驱动，简化代码</span><br>Class.forName(<span class="hljs-string">&quot;com.mysql.jdbc.Driver&quot;</span>);<br><br>String url=<span class="hljs-string">&quot;jdbc:mysql://localhost:3306/xxx&quot;</span>；<br>String user=<span class="hljs-string">&quot;root&quot;</span>;<br>String password=<span class="hljs-string">&quot;123456&quot;</span>;<br><br><span class="hljs-type">Connection</span> <span class="hljs-variable">connection</span> <span class="hljs-operator">=</span> DriverManager.getConnection(url,user,password);<br><span class="hljs-comment">//1.mysqL驱动5.1.6可以无需CLass .forName(“com.mysqljdbc.Driver”);</span><br><span class="hljs-comment">//2.从jdk1.5以后使用了jdbc4,不再需要显示调用class.forName()</span><br><span class="hljs-comment">//注册驱动而是自动调用驱动jar包下META-IN\services\java.sql.Driver文本中的类名称去注册</span><br><span class="hljs-comment">//3.建议还是写上 CLass .forName(“com.mysql.jdbc.Driver”),更加明确</span><br><br><span class="hljs-comment">//5.将url，user，password写入properties文件中动态调用</span><br>Properties properties=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Properties</span>();<br>Properties.load(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(<span class="hljs-string">&quot;src\\xxx.properties&quot;</span>));<br><span class="hljs-comment">//获取相关值</span><br><span class="hljs-type">String</span> <span class="hljs-variable">url</span> <span class="hljs-operator">=</span> properties.getProperty(<span class="hljs-string">&quot;url&quot;</span>);<br><span class="hljs-type">String</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> properties.getProperty(<span class="hljs-string">&quot;user&quot;</span>);<br><span class="hljs-type">String</span> <span class="hljs-variable">password</span> <span class="hljs-operator">=</span> properties.getProperty(<span class="hljs-string">&quot;password&quot;</span>);<br><span class="hljs-type">String</span> <span class="hljs-variable">driver</span> <span class="hljs-operator">=</span> properties.getProperty(<span class="hljs-string">&quot;driver&quot;</span>);<br><br>Class.forName(driver);<br><span class="hljs-type">Connection</span> <span class="hljs-variable">connection</span> <span class="hljs-operator">=</span> DriverManager.getConnection(url,user,password);<br></code></pre></td></tr></table></figure><br/><h3 id="—部分API"><a href="#—部分API" class="headerlink" title="—部分API"></a>—部分API</h3><br/><p><img src="/img/java/77e5d258add9dbd3530994aac680206b.png"></p><br/><ul><li><p><strong>ResultSet</strong></p><p>在执行查询语句后，返回的结果以ResultSet结果集保存，本身也是模拟的一张表。它拥有一个光标，默认指向第一行，通过next方法，它会向下一行移动，如果没有下一行，则会返回flase（-1）。</p><p>resultSet包含了很多数据，其中结果数据存放位置在rowData的rows中。rows是一个ArrayList链表，其中的size代表查询返回多少行数据，真正储存的数据在rows的elementData中。  elementData是一个对象数组，长度取决查询得到的行数，即上面的size，他代表着每行的数据。  elementData数组中又包含internalRowData，他是一个字节数组，代表着每列的数据，长度取决于当前行中列的数量，其中每一个位置该行该列的数据。</p><p>rows：ArrayList链表</p><p>elemetData：Object数组</p><p>internalRowData：byte数组</p><p>因此数据储存的范围：</p><p>rowData -&gt; rows -&gt; elemetData（每行） -&gt; internalRowData（每列）</p></li></ul><p><img src="/img/java/b9c45d5fb0fe8d4a6869b578cc1aa651.png"></p><br/><ul><li><p><strong>Statement和PreparedStatement</strong> </p><p>我们在建立连接之后，需要对数据库进行访问，执行命令或者是sql语句，可以通过statement用于执行静态sql语句，并返回结果对象。</p><p>statement存在sql注入，不要使用！preparedStatement经过预处理后不会存在sql注入问题。</p><p>preparedStatement可以对需要执行的sql语句中的参数用 “ ？”来占位，调用setXXX（）方法来设置这些参数。setXXX（）有两个参数，第一个为占位符所在的索引（下标从1开始），第二个为需要赋的值。</p><p><strong>PreparedStatement的好处：</strong></p><p>1.利于拼接sql语句，减少语法错误。</p><p>2.有效解决了sql注入问题。</p><p>3.大大减少了编译次数，效率更高。</p></li></ul><br/><h3 id="—JDBC中事务与批处理"><a href="#—JDBC中事务与批处理" class="headerlink" title="—JDBC中事务与批处理"></a>—JDBC中事务与批处理</h3><p><strong>事务的操作：</strong></p><p>默认情况下，commition是默认自动提交的，要想将很多sql语句作为一个整体，需要手动关掉connection的setAutoCommit为flase，这样需要手动connection.commit（）提交如果捕获到异常，可以在异常处理中手动回滚rollback()，默认回滚到事务开启的地方。</p><br/><p><strong>批处理：</strong></p><p>当需要成批插入或者更新记录时，可以采用java的批量处理机制，这一机制允许多条语句一次性成批提交给数据库处理，通常情况下比单独处f理更加有效。批处理往往和PreparedStatement一起使用，既可以减少编译次数，又可以减少运行次数，效率大大提高。</p><p><strong>要使用批处理，需要对url中添加rewriteBatchedStatements&#x3D;true,否则不会生效</strong></p><p>JDBC批处理的方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java">String url=<span class="hljs-string">&quot;jdbc:mysql://localhost:3306/xxx?rewriteBatchedStatements=true&quot;</span>；<br>preparedStatement.addBatch();<span class="hljs-comment">//添加需要批处理的sql语句或参数；</span><br>preparedStatement.executeBatch();<span class="hljs-comment">//执行批量处理语句；</span><br>preparedStatement.clearBatch();<span class="hljs-comment">//清空批处理包的语句；</span><br><br><br></code></pre></td></tr></table></figure><p>preparedStatement.addBatch()后，sql语句储存在preparedStatement中的batchedArgs的elementData对象数组中。并且elementData对象数组默认为10的大小，以1.5倍扩容。其中每一个sql对象中的问号占位符参数存放在parameterStrings字节数组中。</p><p>preparedStatement：预处理对象。</p><p>batchedArgs：属于preparedStatement对象中。是一个ArrayList数组，存放批处理的sql语句的主要位置。</p><p>elementData：属于batchedArgs中，是一个对象数组，存放每个sql对象。</p><p>parameterStrings：存放占位符的参数。</p><p>因此批量处理的sql储存的范围为：</p><p>preparedStatement -&gt; batchedArgs -&gt; elementData</p><p><img src="/img/java/6923c6bd8b5ca60dff00076776647d31.png"></p><p><img src="/img/java/d67d3e9c5ca7c15a0b7e655cc4b80e61.png"></p><br/><h3 id="—JavaBean"><a href="#—JavaBean" class="headerlink" title="—JavaBean"></a>—JavaBean</h3><blockquote><p>通过数据集拿到的数据，不方便分类管理和拿取，且需要和connection相关联，因此此时JavaBean出现了</p><p>将得到的数据当成一个对象，其中每个列名即为该对象的一个字段，很多条数据就很多个对象，用集合来储存。这便是JavaBean，一种处理方式&#x2F;逻辑，体现了java面向对象和多态的特点，方便管理和规划 。同时它也叫做PoJO，domain，实体类</p></blockquote><p>JavaBean中数据类型与Mysql数据库中数据类型的对应关系：</p><table><thead><tr><th align="center">Mysql中</th><th align="center">JavaBean中</th></tr></thead><tbody><tr><td align="center">int</td><td align="center">Integer</td></tr><tr><td align="center">char、varchar</td><td align="center">String</td></tr><tr><td align="center">double</td><td align="center">Double</td></tr><tr><td align="center">date</td><td align="center">date&#x2F;String</td></tr></tbody></table><p>注：int,double 等在 Java 中都用包装类，因为 mysql 中的所有类型都可能是NULL，而 Java 只有引用数据类型才有NULL值。</p><br/><h3 id="—数据库连接池"><a href="#—数据库连接池" class="headerlink" title="—数据库连接池"></a>—数据库连接池</h3><blockquote><p>传统的JDBC数据库连接使用 DriverManager来获取，每次向数据库建立连接的时候都要将 Connection 加载到内存中再验证IP地址，用户名和密码(0.05s~1s时间)。需要数据库连接的时候就向数据库要求一个，频繁的进行数据库连接操作将占用很多的系统资源，容易造成服务器崩溃。</p><p>每一次数据库连接，使用完后都得断开，如果程序出现异常而未能关闭，将导致数据库内存泄漏，最终将导致重启数据库。</p><p>传统获取连接的方式，不能控制创建的连接数量，如连接过多，也可能导致内存泄漏，MySQL崩溃。</p><p>简而言之，传统JDBC方法对connection没有任何优化，用户持有connection过多会影响其他用户的连接等待。这里需要做的就是对connection进行代理优化和控制。</p></blockquote><p><strong>特点：</strong></p><ol><li>预先在缓冲池中放入一定数量的连接，当需要建立数据库连接时，只需从“缓冲池”中取出一个，使用完毕之后再放回去。</li><li>数据库连接池负责分配、管理和释放数据库连接，它允许应用程序重复使用一个现有的数据库连接，而不是重新建立一个。</li><li>当应用程序向连接池请求的连接数超过最大连接数量时，这些请求将被加入到等待队列中。</li></ol><p><img src="/img/java/aca234ed3f28f8bc2977e6de9bda6c16.png"></p><p>Java官方为数据库连接池提供了接口：DataSource，第三方去实现。</p><p><strong>几种常用数据库连接池：</strong></p><ol><li>C3PO数据库连接池，速度相对较慢，稳定性不错 （hibernate, spring）；</li><li>Druid(德鲁伊) 是阿里提供的数据库连接池，集DBCP 、C3PO 、Proxool优点于一身的数据库连接池 （推荐使用）</li></ol><br/><p><strong>C3P0</strong></p><p>需要在libs下手动加入jar包 -&gt; 引入项目（add as liarbry）</p><p>配置文件拷贝到项目的src目录</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//获取相关信息（driver，url，user，psw）</span><br><span class="hljs-comment">//创建一个数据源对象</span><br><span class="hljs-type">ComboPooledDataSource</span> <span class="hljs-variable">comboPooledDataSource</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ComboPooledDataSource</span>();<br><span class="hljs-comment">//设置相关参数</span><br>comboPooledDataSource.setDriverClass(driver);<br>comboPooledDataSource.setJdbcUrl(url);<br>comboPooledDataSource.setUser(user);<br>comboPooledDataSource.setPassword(password);<br><span class="hljs-comment">//初始化连接数</span><br>comboPooledDataSource.setInitialPoorSize(<span class="hljs-number">10</span>);<br><span class="hljs-comment">//设置最大连接</span><br>comboPooledDataSource.setMaxPoorSize(<span class="hljs-number">50</span>);<br><span class="hljs-comment">//connection</span><br><span class="hljs-type">Connection</span> <span class="hljs-variable">connection</span> <span class="hljs-operator">=</span> comboPooledDataSource.getConnection();<br><br><br><br><span class="hljs-comment">//方法二：通过配置文件直接更改。</span><br><span class="hljs-type">ComboPooledDataSource</span> <span class="hljs-variable">comboPooledDataSource</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ComboPooledDataSource</span>(<span class="hljs-string">&quot;配置文件名字&quot;</span>);<br><span class="hljs-type">Connection</span> <span class="hljs-variable">connection</span> <span class="hljs-operator">=</span> comboPooledDataSource.getConnection();<br></code></pre></td></tr></table></figure><br/><p><strong>Druid</strong></p><p>需要在libs下手动加入jar包 -&gt; 引入项目（add as liarbry）</p><p>配置文件拷贝到项目的src目录</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//获取配置文件</span><br><span class="hljs-type">Properties</span> <span class="hljs-variable">properties</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Properties</span>();<br>properties.load(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(<span class="hljs-string">&quot;src\\druid.properties&quot;</span>));<br><span class="hljs-comment">//创建一个指定参数的数据库连接池</span><br><span class="hljs-type">DataSource</span> <span class="hljs-variable">dataSource</span> <span class="hljs-operator">=</span> DruidDataSourceFactory.createDataSource(properties);<br><span class="hljs-type">Connection</span> <span class="hljs-variable">connection</span> <span class="hljs-operator">=</span> dataSource.getConnection();<br></code></pre></td></tr></table></figure><br/><h3 id="—结果集工具类"><a href="#—结果集工具类" class="headerlink" title="—结果集工具类"></a>—结果集工具类</h3><blockquote><p>有很多时候查询出来的结果需要多次使用，查询返回的ResultSet结果集是与connection相关的，一旦连接关闭，则结果集就无法使用。</p><p>用户也不能一直持有connection，因此需要对查询得到的结果进行转存。</p></blockquote><p><img src="/img/java/a0c5c6aaf4bfe683afc0874250ec1984.png"></p><p><strong>核心思路：</strong>将得到的结果集中每行以一个对象的形式储存，最后将每行数据（对象）存在集合中，这样脱离出来了ResultSet，也脱离了connection。</p><br/><p><strong>Apache-DBUtils</strong></p><ol><li>commons-dbutils 是 Apache 组织提供的一个开源 JDBC工具类库，它是对JDBC的封装，使用dbutils能极大简化jdbc编码的工作量。</li><li>QueryRunner类: 该类封装了SQL的执行，是线程安全的。可以实现增、删、改、查、批处理</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//大致方法：</span><br>ArrayHandler: <span class="hljs-comment">//把结果集中的第一行数据转成对象数组</span><br>ArrayListHandler: <span class="hljs-comment">//把结果集中的每一行数据都转成一个数组，再存放到List中</span><br>BeanHandler: <span class="hljs-comment">//将结果集中的第一行数据封装到一个对应的JavaBean实例中</span><br>BeanListHandler: <span class="hljs-comment">//将结果集中的每一行数据都封装到一个对应的JavaBean实例中，存放到List里</span><br>ColumnListHandler: <span class="hljs-comment">//将结果集中某一列的数据存放到List中</span><br>KeyedHandler(name): <span class="hljs-comment">//将结果集中的每行数据都封装到Map里，再把这些map再存到一个map里，其key为指定的key</span><br>MapHandler: <span class="hljs-comment">//将结果集中的第一行数据封装到一个Map里，key是列名，value就是对应的值</span><br>MapListHandler: <span class="hljs-comment">//将结果集中的每一行数据都封装到一个Map里，然后再存放到List</span><br><br>ScalarHandler();<span class="hljs-comment">//返回单行单列</span><br>BeanHandler();<span class="hljs-comment">//返回单行多列</span><br>BeanListHandler<span class="hljs-comment">//返回多行多列</span><br><br><span class="hljs-comment">//举例：</span><br><span class="hljs-type">Connection</span> <span class="hljs-variable">connection</span> <span class="hljs-operator">=</span> JDBCUtilsByRruid.getConnection();<span class="hljs-comment">//获取连接</span><br><span class="hljs-type">QueryRunner</span> <span class="hljs-variable">queryRunner</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">QueryRunner</span>();<span class="hljs-comment">//创建QueryRunner类</span><br><span class="hljs-type">String</span> <span class="hljs-variable">sql</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;select * from xxx where id = ?&quot;</span>;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment">* 1.query方法是执行sql语句，得到 resultSet -&gt; 封装到 ArrayList 集合中</span><br><span class="hljs-comment">* 2.new BeanListHandler&lt;&gt;(Actor.class):在 resultSet -&gt; Actor对象 -&gt; 封装到 ArrayList中</span><br><span class="hljs-comment">* 3.这个“1”是可变参数，是sql语句中“？”占位符的赋值，此处是查找id = 1的数据</span><br><span class="hljs-comment">* 4.底层得到的resultSet、preparedStatement，会在query这个方法中关闭，无需手动关闭</span><br><span class="hljs-comment">*/</span><br>List&lt;Actor&gt; list =<br>    queryRunner.query(connection , sql , <span class="hljs-keyword">new</span> <span class="hljs-title class_">BeanListHandler</span>&lt;&gt;(Actor.class) , <span class="hljs-number">1</span>);<br><span class="hljs-comment">//dml的操作：</span><br><span class="hljs-type">int</span> <span class="hljs-variable">affectedRow</span> <span class="hljs-operator">=</span> queryRunner.upDate(connection , sql , <span class="hljs-string">&quot;&quot;</span> ,<span class="hljs-string">&quot;&quot;</span>);<span class="hljs-comment">//返回受影响的行数</span><br></code></pre></td></tr></table></figure><br/><h3 id="—DAO的引出"><a href="#—DAO的引出" class="headerlink" title="—DAO的引出"></a>—DAO的引出</h3><blockquote><p>DAO &#x3D; data access object ，数据访问对象。</p></blockquote><p>上述用apache-dbutil（结果集） + Druid（连接池）简化了JDBC的开发，但是还是有很多不足：</p><ol><li>sql语句固定，不能通过参数传入，通用性不佳。</li><li>对于查询操作，返回值不能固定，需要使用泛型。</li><li>只能对单一表进行操作，无法实现业务需求复杂的情况。</li></ol><br/><p>因此，我们可以对上述进行优化，将写sql的地方单独拿出来，如下图：</p><p><img src="/img/java/401b85c552f4f1c10f96a39387f0dd27.png"></p><br/><h2 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h2><blockquote><p>处理文本的利器</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>义无反顾的青春里 爱情不过是寥寥几笔</title>
    <link href="/2023/03/27/%E4%B9%89%E6%97%A0%E5%8F%8D%E9%A1%BE%E7%9A%84%E9%9D%92%E6%98%A5%E9%87%8C-%E7%88%B1%E6%83%85%E4%B8%8D%E8%BF%87%E6%98%AF%E5%AF%A5%E5%AF%A5%E5%87%A0%E7%AC%94/"/>
    <url>/2023/03/27/%E4%B9%89%E6%97%A0%E5%8F%8D%E9%A1%BE%E7%9A%84%E9%9D%92%E6%98%A5%E9%87%8C-%E7%88%B1%E6%83%85%E4%B8%8D%E8%BF%87%E6%98%AF%E5%AF%A5%E5%AF%A5%E5%87%A0%E7%AC%94/</url>
    
    <content type="html"><![CDATA[<blockquote><p>这篇影评可能有剧透</p></blockquote><p><strong>永远会对勇敢善良的女孩子心动💗</strong></p><p><img src="/img/35371261/p2872805536.jpg"></p><p>会担心擦肩而过的陌生人误入危险废墟而狂奔，会给流浪的小猫咪喂小鱼干，会帮助陌生人关上危险与未知并存的门。</p><br/><p>一个人去“旅行🧳”，去看富士山，去“拯救世界”，去拯救爱的人，去做她认为正确的事，去帮助身边能帮到的人。</p><br/><p>电影里没有傻白甜的高中生、也没有恋爱脑的小女生、也没有毫无理由叛逆的熊孩子，有的是勇敢、善良、闪闪发光的铃芽。</p><br/><p>我太喜欢这种剧本，<strong>女孩子也可以勇敢的做任何事情，或大或小，都充满无限可能</strong>。</p><br/><p>铃芽和姨妈之间纠结的亲情，芹泽和草太之简单的友情，大臣和铃芽之间纯粹的喜爱，讲铃芽和草太之间懵懂的感情，篇幅简短，但真诚入人心。</p><p>在不为人知的地方总有人在默默守护一方平安，或许在被人忽视的角落，有一批又一批人渐渐沉睡。或许不能做什么，但不能遗忘。</p><p>曾经以为难捱无法度过的日子，在未来也不过是一场短暂的梦。“<strong>所以别再担心了，未来并不可怕，你也会遇到很多非常喜欢你的人，虽然你觉得世界一片黑暗，但是黎明终会到来，你会在阳光之下长大成人，未来一定会是这样的，因为那已经是注定好的事了。</strong>”</p><br/><p>能治愈你的永远只有自己。</p><br/><p><strong>或许我没有勇气一个人旅行，没有勇气放弃自己去拯救世界，但人生最奇妙的事情就在于，一切都充满可能吧🥹</strong></p><p><img src="/img/35371261/p2886845591.jpg"></p>]]></content>
    
    
    <categories>
      
      <category>影评</category>
      
    </categories>
    
    
    <tags>
      
      <tag>影评</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>人总不满足于现状 幻想着能与他人交换人生</title>
    <link href="/2023/02/01/%E4%BA%BA%E6%80%BB%E4%B8%8D%E6%BB%A1%E8%B6%B3%E4%BA%8E%E7%8E%B0%E7%8A%B6-%E5%B9%BB%E6%83%B3%E7%9D%80%E8%83%BD%E4%B8%8E%E4%BB%96%E4%BA%BA%E4%BA%A4%E6%8D%A2%E4%BA%BA%E7%94%9F/"/>
    <url>/2023/02/01/%E4%BA%BA%E6%80%BB%E4%B8%8D%E6%BB%A1%E8%B6%B3%E4%BA%8E%E7%8E%B0%E7%8A%B6-%E5%B9%BB%E6%83%B3%E7%9D%80%E8%83%BD%E4%B8%8E%E4%BB%96%E4%BA%BA%E4%BA%A4%E6%8D%A2%E4%BA%BA%E7%94%9F/</url>
    
    <content type="html"><![CDATA[<blockquote><p>这篇影评可能有剧透</p></blockquote><p>《交换人生》一听这个名字，仿佛剧情都能猜到七八分。大概就是奇幻啦、穿越啦，我穿到你身上、你穿到我身上，这样的剧本。</p><p>俗套的剧情，<strong>用最质朴的方式表达，反而最打动人心。</strong></p><br/><p>利益熏心不分黑白的律师为获利而故意输掉一场人命关天的官司；十六七岁热血的少年却喜欢上了三十多岁的“女孩儿”；被妈妈逼着催婚却只是为了还债的大龄剩女。不同世界的人，却奇妙的串联到一起。</p><br/><p>他们讲友情，就讲少年换到了大叔身上，无人相信走投无路找到自己的死党，即使眼前的人无比陌生也仍能认出自己的好朋友，帮他想办法实现愿望。即使吵架闹别扭，关键时刻还是为你着想还不忘给朋友买下喜欢的游戏皮肤，幼稚却又轰轰烈烈的少年情。</p><br/><p>他们讲爱情，就讲即使相差十几岁，有趣的灵魂依然能相互吸引，一起看万家灯火、一起在游戏厅打游戏、一起转圈圈看漫天流星，无关利益，只有开心。我和你在一起开心，这不就是爱情吗，像少年时最纯粹最简单的感情。</p><br/><p>他们讲家庭，讲为了唤起患阿尔兹海默症奶奶的记忆，全家陪着奶奶每天做一样的事情，一起唱歌，一起看房子，同样的剧情不厌其烦，只为了让奶奶想起那些旧事。讲家庭，他们讲父母的相互扶持，讲平淡生活里的苦中作乐，讲家的温暖。</p><br/><p>他们讲人生，讲如果换一种生活，我会不会实现我的愿望？好，换！  换成了喜欢的人的男朋友，却失去了温暖的家庭，换成了功成名就的大律师，却丧失了道德的底线。有所得就一定有所失。最后千帆过尽，还是自己的生活最美好、最珍贵。</p><br/><p>这一场闹剧式的交换人生，又何尝不是人生中的波折呢。你迫切想拥有的，或许是别人唾手可得的。你说曾忽视的，或许是别人梦寐以求的。<strong>人生最奇妙的，就是人皆不同。</strong></p><br/><p><strong>一千个世界有一千个哈姆雷特，一千个人亦有一千种人生。</strong></p><p><img src="/img/14956604/p2889176899.jpg"></p>]]></content>
    
    
    <categories>
      
      <category>影评</category>
      
    </categories>
    
    
    <tags>
      
      <tag>影评</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>将故事封存在最美好的时刻</title>
    <link href="/2023/01/17/%E5%B0%86%E6%95%85%E4%BA%8B%E5%B0%81%E5%AD%98%E5%9C%A8%E6%9C%80%E7%BE%8E%E5%A5%BD%E7%9A%84%E6%97%B6%E5%88%BB/"/>
    <url>/2023/01/17/%E5%B0%86%E6%95%85%E4%BA%8B%E5%B0%81%E5%AD%98%E5%9C%A8%E6%9C%80%E7%BE%8E%E5%A5%BD%E7%9A%84%E6%97%B6%E5%88%BB/</url>
    
    <content type="html"><![CDATA[<blockquote><p>这篇影评可能有剧透</p></blockquote><p>每次和朋友们说起我没看过泰坦尼克号，每次都能收获一大波震惊🤯 今天终于有空有时间看了这部经典电影🎬</p><br/><p>路易十六的钻石被分割后制成了价值连城的“海洋之星”，利益驱使着人们对沉没在海底的泰坦尼克号展开一次次搜寻。在黑暗的海底中人们用潜水艇一次次照亮久居黑暗的泰坦尼克，用科技复原它沉船的过程，人们渐渐了解泰坦尼克号的故事，但却见不到它的辉煌。</p><p><img src="/img/1292722/p1482527907.jpg"></p><br/><p>Rose奶奶用回忆带我们回到那艘“永不会沉没”的泰坦尼克号上。那是她还是个年轻漂亮的上流名媛，与未婚夫踏上泰坦尼克开启未知的“旅程”。是对旅行的未知，也是对婚姻的未知。</p><p>Rose厌倦了整日茶会、餐会这样无趣的生活。Rose试图结束这无趣的生活，但Jack的出现，给她无趣的生活带来了一丝光亮。他带着她一起尝试许多从未尝试过的事情，画画、跳舞、喝酒，甚至学习怎么像男士一样吐痰。救了Rose的他受邀参加他们的晚宴，即使不太懂上流生活的一些礼仪，但他迅速学习并隐藏在人群中；虽然身无分文，但胆识、眼界和心胸是无法掩藏的。</p><p>Jack在晚宴上被频频刁难，但他却从容应对，大方承认自己的处境与生活，豁达开朗的态度，反而让人感到佩服。也逐渐让Rose对Jack有了不一样的感情。但母亲却制止Rose，提醒她家庭的责任需要她的婚姻来承担。Rose决定放弃。</p><p><img src="/img/1292722/p1460629869.jpg"></p><p><img src="/img/1292722/p1460631725.jpg"></p><p>看到这里其实我觉得，最后沉船反而是最好的结局。如果没有沉船，Rose和Jack的轰轰烈烈爱情或许只会是上流人士茶余饭后的谈资，在权利和金钱面前，在亲情和家庭面前，善良的Rose或许没办法抛弃母亲与Jack远走高飞。惯用金钱的未婚夫或许会拿金钱权势压的Jack无能为力。我想过很多种不同的结局，却仍然认为，沉船是最好的结局。故事暂停在最美好的时刻，Rose带着这最美好的回忆重新开始新的生活。也不失为是一种浪漫。</p><br/><p>剧中还有很多坦然赴死的人们，让我为之动容。躺在床上相拥等待死亡来临的老夫妻；站在甲板上坚持完成作品的音乐家们；在船舱里讲故事哄孩子们睡去的母亲；站在壁炉前深情凝望着泰坦尼克画像的设计师；面对仓皇逃生巨大压力下自杀倒下的船员；还有坚守岗位与船只一起沉入海底的老船长。他们不怕死吗，我想也是怕的，可是在绝望的处境中坦然面对对他们来说反而是最好的选择，或许是因为年迈、因为热爱、因为幼小、因为深爱、因为压力、因为愧疚… </p><br/><p>反之有许许多多人们，慌乱之中漏出了人性丑恶嘴脸。没有危险的地方人性最为致命。枪杀、踩踏、争抢、跳海、翻船、割绳，还有冷漠。在求生面前什么人性本善都是放屁，人人脑中只有一句话，我要活下去。我不是神，面对这样的恐惧我也不知道我会做出什么选择，所以我没有资格指责他们什么。我只感到悲哀，为跳入海中的人们悲哀、为被无辜枪杀的人们悲哀、为那些在海面上冻成雕像的人们悲哀。</p><br/><p>若只看感情，这是妥妥的浪漫结局；但若看事件，这是一部极大的悲剧，沉船的悲剧和人性的悲剧。</p>]]></content>
    
    
    <categories>
      
      <category>影评</category>
      
    </categories>
    
    
    <tags>
      
      <tag>影评</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
